<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investiční Kalkulačka</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap');

        :root {
            color-scheme: light;
            --bg-start: #F8FCFF;
            --bg-end: #F3F6FA;
            --primary: #0d2c54;
            --primary-strong: #0d2c54;
            --accent: #4DB1C8;
            --accent-strong: #2690a8;
            --accent-warm: #E0A899;
            --text: #1f2a37;
            --muted: #6b7280;
            --muted-soft: #9aa3af;
            --border: #E5EAF0;
            --border-strong: #CFD9E3;
            --surface: #ffffff;
            --surface-alt: #f5f7fb;
            --shadow: 0 10px 25px -10px rgba(13, 44, 84, 0.10);
            --shadow-hover: 0 18px 38px -18px rgba(13, 44, 84, 0.15);
            --danger: #d94b4b;
            --danger-bg: rgba(217, 75, 75, 0.12);
            --positive: #2f9b6c;
        }
        *, *::before, *::after { box-sizing: border-box; }
        body {
            font-family: 'Montserrat', ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Helvetica Neue", sans-serif;
            scroll-behavior: smooth;
            background: linear-gradient(180deg, var(--bg-start) 0%, var(--bg-end) 100%);
            color: var(--text);
            min-height: 100vh;
            margin: 0;
            font-size: 1rem;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }
        a { color: inherit; text-decoration: none; }
        .tabular-nums { font-variant-numeric: tabular-nums; }
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }
        details > summary { list-style: none; cursor: pointer; }
        details > summary::-webkit-details-marker { display: none; }
        details > summary .summary-arrow { transition: transform 0.2s ease; }
        details[open] > summary .summary-arrow { transform: rotate(90deg); }
        .toast-stack { position: fixed; top: 1.5rem; right: 1.5rem; z-index: 50; display: flex; flex-direction: column; gap: 0.75rem; }
        .toast {
            display: flex;
            align-items: center;
            padding: 1rem 1.1rem;
            border-radius: 0.9rem;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            background: var(--surface);
            color: var(--text);
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.4s cubic-bezier(0.21, 1.02, 0.73, 1);
        }
        .toast.show { opacity: 1; transform: translateX(0); }
        .toast-success { border-color: rgba(77, 177, 200, 0.55); background: rgba(77, 177, 200, 0.16); color: var(--primary); }
        .toast-error { border-color: rgba(217, 75, 75, 0.55); background: rgba(217, 75, 75, 0.18); color: var(--danger); }
        .app-shell { max-width: 1160px; margin: 0 auto; padding: 0 1.75rem; position: relative; z-index: 1; }
        @media (max-width: 640px) { .app-shell { padding: 0 1.25rem; } }
        header.brand-header { padding: 3.5rem 0 4.25rem; position: relative; }
        .brand-backdrop {
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.96) 0%, rgba(255, 255, 255, 0.9) 60%, rgba(247, 250, 253, 0.92) 100%);
            border-bottom-left-radius: 36px;
            border-bottom-right-radius: 36px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }
        .brand-header-inner { position: relative; z-index: 1; display: grid; gap: 2.5rem; }
        @media (min-width: 1024px) {
            .brand-header-inner { grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr); align-items: center; }
        }
        .hero-intro { display: flex; flex-direction: column; gap: 1.6rem; }
        .brand-identity { display: flex; flex-direction: column; align-items: flex-start; gap: 0.75rem; }
        .brand-logo {
            font-weight: 700;
            font-size: 1.1rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--primary);
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
        }
        .brand-logo span { color: var(--accent); }
        .hero-kicker {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.55rem 1.4rem;
            border-radius: 999px;
            background: rgba(13, 44, 84, 0.08);
            border: 1px solid rgba(13, 44, 84, 0.14);
            font-size: 0.78rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--primary);
            font-weight: 600;
        }
        .hero-title {
            font-size: clamp(2.4rem, 5vw, 3.8rem);
            font-weight: 700;
            letter-spacing: -0.025em;
            margin: 1.2rem 0 1.4rem;
            color: var(--primary);
        }
        .hero-title-upper { text-transform: uppercase; }
        .hero-description {
            font-size: 1rem;
            line-height: 1.75;
            max-width: 520px;
            color: var(--muted);
        }
        .hero-card-stack { display: grid; gap: 1.35rem; }
        .surface-card {
            position: relative;
            overflow: hidden;
            background: var(--surface);
            border-radius: 1.5rem;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            padding: 1.9rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
        }
        .surface-card > * { position: relative; z-index: 1; }
        .surface-card:hover { border-color: var(--border-strong); box-shadow: var(--shadow-hover); transform: translateY(-2px); }
        .surface-card small {
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            font-size: 0.75rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--muted);
            font-weight: 600;
        }
        .surface-card h3 { margin: 0.8rem 0 0.75rem; font-size: 1.1rem; font-weight: 600; color: var(--primary); }
        .surface-card p { margin: 0; font-size: 0.95rem; line-height: 1.6; color: var(--muted); }
        .hero-disclaimer {
            margin-top: 2.2rem;
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            color: var(--muted);
            font-size: 0.9rem;
        }
        .hero-disclaimer strong { color: var(--primary); font-weight: 600; }
        main { margin-top: -48px; position: relative; z-index: 2; }
        @media (max-width: 768px) { main { margin-top: -32px; } }
        .content-stack { display: flex; flex-direction: column; gap: 2.5rem; padding-bottom: 4.5rem; }
        .card-section {
            background: var(--surface);
            border-radius: 1.4rem;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            padding: clamp(1.75rem, 2.5vw, 2.65rem);
            transition: border-color 0.25s ease, box-shadow 0.25s ease, transform 0.25s ease;
        }
        .card-section:hover { border-color: var(--border-strong); box-shadow: var(--shadow-hover); transform: translateY(-2px); }
        .card-header { display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1.5rem; }
        @media (min-width: 768px) { .card-header { flex-direction: row; justify-content: space-between; align-items: flex-start; } }
        .card-header-title { font-size: 1.5rem; font-weight: 600; letter-spacing: -0.01em; color: var(--primary); }
        .card-header-sub { font-size: 0.95rem; color: var(--muted); max-width: 580px; }
        .badge-pill {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.45rem 1.05rem;
            border-radius: 999px;
            background: rgba(77, 177, 200, 0.12);
            border: 1px solid rgba(77, 177, 200, 0.35);
            font-size: 0.72rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--primary);
            font-weight: 600;
        }
        .meta-deck { display: flex; flex-wrap: wrap; gap: 0.75rem; }
        .meta-card {
            border: 1px solid var(--border);
            background: var(--surface);
            border-radius: 1rem;
            padding: 0.95rem 1.15rem;
            color: var(--muted);
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            min-width: 190px;
            box-shadow: var(--shadow);
        }
        .meta-label { font-size: 0.7rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--muted); font-weight: 600; }
        .meta-value { font-size: 1rem; font-weight: 600; color: var(--primary); }
        .meta-card .input { width: 100%; }
        .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.45rem; padding: 0.7rem 1.5rem; border-radius: 0.9rem; font-weight: 600; font-size: 0.92rem; letter-spacing: 0.02em; cursor: pointer; border: 1px solid transparent; transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background-color 0.2s ease; }
        .btn:hover { transform: translateY(-2px); }
        .btn-primary { background: var(--primary); border-color: var(--primary); color: #fff; box-shadow: var(--shadow); }
        .btn-primary:hover { background: #12386c; border-color: #12386c; box-shadow: var(--shadow-hover); }
        .btn-primary:active { transform: translateY(0); box-shadow: none; }
        .btn-secondary { background: var(--surface); color: var(--primary); border-color: var(--border); box-shadow: none; }
        .btn-secondary:hover { border-color: var(--border-strong); box-shadow: var(--shadow); }
        .btn-secondary.active { background: rgba(77, 177, 200, 0.12); border-color: rgba(77, 177, 200, 0.35); }
        .btn-danger { background: var(--danger-bg); color: var(--danger); border-color: rgba(217, 75, 75, 0.32); }
        .btn-danger:hover { background: rgba(217, 75, 75, 0.2); box-shadow: var(--shadow); }
        .control-bar { display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; }
        .input, select { font-family: inherit; border-radius: 0.75rem; border: 1px solid var(--border); padding: 0.65rem 0.95rem; background: #fff; transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease; font-size: 0.95rem; color: var(--text); }
        .input:focus, select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 4px rgba(77, 177, 200, 0.18); background: #fff; }
        .input::placeholder { color: var(--muted-soft); }
        .input-ghost { background: var(--surface-alt); }
        .icon-button { width: 2.25rem; height: 2.25rem; border-radius: 50%; border: 1px solid var(--border); background: var(--surface); color: var(--muted); display: inline-flex; align-items: center; justify-content: center; transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease, background-color 0.2s ease; }
        .icon-button:hover { border-color: var(--border-strong); color: var(--primary); background: var(--surface-alt); box-shadow: var(--shadow); }
        .overflow-x-auto { overflow-x: auto; }
        table { width: 100%; border-collapse: separate; border-spacing: 0; }
        thead th {
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: var(--muted);
            padding: 0.75rem 0.75rem;
            border-bottom: 1px solid var(--border);
            background: var(--surface-alt);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        tbody td {
            padding: 0.85rem 0.75rem;
            border-bottom: 1px solid var(--border);
            font-size: 0.92rem;
            color: var(--text);
            background: #fff;
        }
        tbody tr:nth-child(even) td { background: #f9fbff; }
        tbody tr:hover td { background: rgba(77, 177, 200, 0.1); }
        tbody tr:last-child td { border-bottom: none; }
        .table-actions { text-align: right; }
        .table-input {
            width: 100%;
            border-radius: 0.7rem;
            border: 1px solid var(--border);
            padding: 0.55rem 0.85rem;
            background: #fff;
            font-size: 0.92rem;
            color: var(--text);
            transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
        }
        .table-input:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 4px rgba(77, 177, 200, 0.18); background: #fff; }
        .table-select { width: 100%; }
        .info-grid { display: grid; gap: 1.25rem; }
        @media (min-width: 520px) { .info-grid { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); } }
        .timeline-slider { margin-top: 2.2rem; display: flex; flex-direction: column; gap: 1.15rem; }
        .timeline-slider-header { display: flex; flex-wrap: wrap; gap: 1.5rem; justify-content: space-between; align-items: flex-end; }
        .timeline-slider-meta { display: flex; flex-direction: column; gap: 0.25rem; min-width: 160px; }
        .timeline-slider-label { font-size: 0.72rem; letter-spacing: 0.18em; text-transform: uppercase; font-weight: 600; color: var(--muted); }
        .timeline-slider-value { font-size: 1.05rem; font-weight: 600; color: var(--primary); }
        .timeline-slider-track {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 999px;
            background: linear-gradient(
                90deg,
                var(--accent) 0%,
                var(--accent) var(--slider-progress, 0%),
                rgba(13, 44, 84, 0.12) var(--slider-progress, 0%),
                rgba(13, 44, 84, 0.12) 100%
            );
            outline: none;
            cursor: pointer;
            transition: box-shadow 0.2s ease;
        }
        .timeline-slider-track:focus-visible { box-shadow: 0 0 0 3px rgba(77, 177, 200, 0.35); }
        .timeline-slider-track:disabled { cursor: not-allowed; background: rgba(13, 44, 84, 0.12); opacity: 0.6; }
        .timeline-slider-track::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--surface);
            border: 2px solid var(--accent);
            box-shadow: 0 4px 12px rgba(13, 44, 84, 0.25);
            transition: transform 0.2s ease;
        }
        .timeline-slider-track::-webkit-slider-thumb:hover { transform: scale(1.08); }
        .timeline-slider-track::-webkit-slider-thumb:active { transform: scale(1.12); }
        .timeline-slider-track::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--surface);
            border: 2px solid var(--accent);
            box-shadow: 0 4px 12px rgba(13, 44, 84, 0.25);
            transition: transform 0.2s ease;
        }
        .timeline-slider-track::-moz-range-thumb:hover { transform: scale(1.08); }
        .timeline-slider-track::-moz-range-thumb:active { transform: scale(1.12); }
        .timeline-slider-track::-moz-range-track {
            height: 6px;
            border-radius: 999px;
            background: rgba(13, 44, 84, 0.12);
        }
        .timeline-slider-track::-moz-range-progress {
            height: 6px;
            border-radius: 999px;
            background: var(--accent);
        }
        .timeline-slider-scale { display: flex; justify-content: space-between; font-size: 0.82rem; color: var(--muted); }
        .timeline-slider-scale span { white-space: nowrap; }
        .timeline-slider-invested { font-size: 0.88rem; color: var(--muted); }
        .timeline-narrative { margin-top: 2.15rem; padding: 1.6rem; border-radius: 1.25rem; background: linear-gradient(135deg, rgba(77, 177, 200, 0.08), rgba(13, 44, 84, 0.03)); border: 1px solid rgba(13, 44, 84, 0.08); box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6); display: grid; gap: 0.85rem; }
        .timeline-narrative-title { font-size: 0.78rem; letter-spacing: 0.22em; text-transform: uppercase; font-weight: 700; color: var(--primary); }
        .timeline-narrative-text { margin: 0; font-size: 0.95rem; line-height: 1.7; color: var(--muted); }
        .info-card {
            border: 1px solid var(--border);
            border-radius: 1.25rem;
            padding: 1.45rem;
            background: var(--surface);
            box-shadow: var(--shadow);
            transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
        }
        .info-card:hover { border-color: var(--border-strong); box-shadow: var(--shadow-hover); transform: translateY(-2px); }
        .info-card-title { font-size: 0.78rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--muted); font-weight: 600; }
        .info-card-value { font-size: 1.6rem; font-weight: 600; color: var(--primary); margin-top: 0.6rem; }
        .info-card-sub { font-size: 0.78rem; color: var(--muted); margin-top: 0.35rem; }
        .highlight-positive { color: var(--positive); font-weight: 600; }
        .highlight-negative { color: var(--danger); font-weight: 600; }
        .tooltip {
            position: absolute;
            z-index: 10;
            padding: 0.6rem 0.8rem;
            background: #fff;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            border-radius: 0.75rem;
            font-size: 0.85rem;
            color: var(--text);
            pointer-events: none;
            display: none;
        }
        .tooltip.show { display: block; }
        .chart-container { position: relative; height: 22rem; width: 100%; }
        .chart-axis-text { fill: var(--muted); font-size: 0.68rem; font-family: 'Montserrat', ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Helvetica Neue", sans-serif; }
        .chart-grid-line { stroke: #E5EAF0; }
        .chart-line-accent { stroke: var(--primary); stroke-width: 2.2; fill: none; }
        .chart-dot { stroke: var(--accent); stroke-width: 2; fill: #fff; }
        .chart-marker-hints {
            margin-top: 1.35rem;
            padding: 0.95rem 1.2rem;
            border-radius: 1rem;
            border: 1px solid var(--border);
            background: var(--surface);
            box-shadow: var(--shadow);
            display: flex;
            flex-wrap: wrap;
            gap: 0.85rem 1.35rem;
            align-items: center;
        }
        .chart-marker-hints-label {
            font-size: 0.65rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: var(--primary-strong);
            font-weight: 600;
        }
        .chart-marker-hints-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem 1.1rem;
        }
        .chart-marker-hint {
            display: inline-flex;
            align-items: center;
            gap: 0.55rem;
            font-size: 0.85rem;
            color: var(--text);
        }
        .chart-marker-icon {
            position: relative;
            width: 1.75rem;
            height: 1.75rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .chart-marker-icon span {
            position: relative;
            z-index: 1;
            font-weight: 600;
        }
        .chart-marker-icon--deposit::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: rgba(77, 177, 200, 0.16);
            border: 2px solid var(--accent);
        }
        .chart-marker-icon--deposit span {
            color: var(--primary);
            font-size: 0.95rem;
        }
        .chart-marker-icon--default::before {
            content: '';
            position: absolute;
            inset: 0.08rem;
            border-radius: 0.45rem;
            background: rgba(217, 75, 75, 0.16);
            border: 2px solid var(--danger);
            transform: rotate(45deg);
        }
        .chart-marker-icon--default span {
            color: var(--danger);
            font-size: 0.85rem;
        }
        .chart-marker-icon--mixed::before {
            content: '';
            position: absolute;
            inset: 0.08rem;
            border-radius: 0.45rem;
            background: rgba(217, 75, 75, 0.16);
            border: 2px solid var(--danger);
            transform: rotate(45deg);
        }
        .chart-marker-icon--mixed::after {
            content: '';
            position: absolute;
            inset: 0.25rem;
            border-radius: 50%;
            background: rgba(77, 177, 200, 0.2);
            border: 2px solid var(--accent);
        }
        .chart-marker-icon--mixed .chart-marker-icon-symbol {
            color: var(--danger);
            font-size: 0.8rem;
            z-index: 2;
        }
        .chart-marker-icon--mixed .chart-marker-icon-plus {
            position: absolute;
            top: 0.25rem;
            left: 0;
            right: 0;
            text-align: center;
            color: var(--primary-strong);
            font-size: 0.75rem;
            z-index: 2;
        }
        .legend { display: flex; flex-wrap: wrap; gap: 1.2rem; margin-top: 1rem; font-size: 0.8rem; color: var(--muted); }
        .legend-item { display: inline-flex; align-items: center; gap: 0.35rem; }
        .legend-dot { width: 0.6rem; height: 0.6rem; border-radius: 50%; }
        .pie-stage-controls { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        .pie-stage-controls .btn { padding-inline: 1.1rem; font-size: 0.8rem; }
        .pie-stage-controls .btn[disabled] { opacity: 0.55; cursor: not-allowed; transform: none; box-shadow: none; }
        .pie-chart-wrapper { position: relative; width: 100%; max-width: 320px; margin: 0 auto; display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .pie-legend { display: grid; gap: 0.85rem; }
        .pie-legend-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 0.75rem 0.95rem;
            background: var(--surface);
            box-shadow: var(--shadow);
            transition: border-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        }
        .pie-legend-item:hover { border-color: var(--border-strong); transform: translateX(4px); box-shadow: var(--shadow-hover); }
        .pie-legend-name { font-weight: 600; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: flex; align-items: center; gap: 0.55rem; }
        .pie-legend-value { color: var(--accent); font-weight: 600; }
        .pie-legend-dot { width: 0.85rem; height: 0.85rem; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 0 1px var(--border); }
        .pie-segment { cursor: pointer; transition: transform 0.2s ease, filter 0.2s ease; transform-origin: center center; filter: none; }
        .pie-segment:hover { transform: scale(1.03); filter: drop-shadow(0 12px 28px rgba(13, 44, 84, 0.25)); }
        .responsive-grid-two { display: grid; gap: 2.5rem; align-items: center; }
        @media (min-width: 768px) { .responsive-grid-two { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
        .card-subheading { margin: 0; font-size: 1.05rem; font-weight: 600; color: var(--primary); letter-spacing: -0.01em; }
        .summary-table-container {
            overflow-x: auto;
            border: 1px solid var(--border);
            border-radius: 1rem;
            box-shadow: var(--shadow);
            background: var(--surface);
        }
        .summary-table {
            width: 100%;
            min-width: 520px;
            border-collapse: separate;
            border-spacing: 0;
            font-variant-numeric: tabular-nums;
        }
        .summary-table thead th {
            font-size: 0.72rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: var(--muted);
            font-weight: 600;
            padding: 0.85rem 1.1rem;
            text-align: left;
            background: rgba(77, 177, 200, 0.1);
            border-bottom: 1px solid var(--border);
        }
        .summary-table tbody td {
            padding: 0.95rem 1.1rem;
            border-bottom: 1px solid var(--border);
            font-size: 0.95rem;
            color: var(--text);
            vertical-align: middle;
        }
        .summary-table tbody td.tabular-nums { white-space: nowrap; }
        .summary-table tbody tr:last-child td { border-bottom: none; }
        .summary-table tbody tr:hover { background: rgba(77, 177, 200, 0.06); }
        .summary-table tbody tr.is-positive .gain-value { color: var(--positive); background: rgba(47, 155, 108, 0.15); box-shadow: inset 0 0 0 1px rgba(47, 155, 108, 0.18); }
        .summary-table tbody tr.is-negative .gain-value { color: var(--danger); background: rgba(217, 75, 75, 0.12); box-shadow: inset 0 0 0 1px rgba(217, 75, 75, 0.18); }
        .summary-table tbody tr.is-neutral .gain-value { color: var(--muted); background: rgba(31, 42, 55, 0.08); box-shadow: inset 0 0 0 1px rgba(31, 42, 55, 0.12); }
        .summary-table .gain-cell {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 0.6rem;
            width: 100%;
        }
        .summary-table .gain-value {
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            padding: 0.35rem 0.85rem;
            border-radius: 999px;
            font-weight: 600;
            transition: transform 0.2s ease;
            letter-spacing: -0.01em;
        }
        .summary-table tbody tr:hover .gain-value { transform: translateY(-1px); }
        .summary-table .gain-value-icon {
            display: inline-flex;
            width: 1.05rem;
            height: 1.05rem;
            border-radius: 50%;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.65);
            font-size: 0.7rem;
        }
        .summary-table .crash-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.15rem 0.6rem;
            border-radius: 999px;
            background: var(--danger-bg);
            color: var(--danger);
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            white-space: nowrap;
        }
        .summary-table .crash-indicator[data-tooltip] {
            position: relative;
            cursor: help;
        }
        .summary-table .crash-indicator[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: calc(100% + 0.55rem);
            right: 0;
            min-width: 220px;
            max-width: 260px;
            padding: 0.65rem 0.75rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border-strong);
            background: var(--surface);
            box-shadow: var(--shadow-hover);
            color: var(--text);
            font-size: 0.75rem;
            line-height: 1.35;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-4px);
            transition: opacity 0.18s ease, transform 0.18s ease;
            white-space: pre-line;
            z-index: 20;
        }
        .summary-table .crash-indicator[data-tooltip]::before {
            content: '';
            position: absolute;
            top: calc(100% + 0.2rem);
            right: 1rem;
            width: 0.55rem;
            height: 0.55rem;
            transform: rotate(45deg);
            border: 1px solid var(--border-strong);
            border-left-color: transparent;
            border-top-color: transparent;
            background: var(--surface);
            opacity: 0;
            transition: opacity 0.18s ease, transform 0.18s ease;
            z-index: 19;
        }
        .summary-table .crash-indicator[data-tooltip]:hover::after,
        .summary-table .crash-indicator[data-tooltip]:focus-visible::after,
        .summary-table .crash-indicator[data-tooltip]:hover::before,
        .summary-table .crash-indicator[data-tooltip]:focus-visible::before {
            opacity: 1;
            transform: translateY(0);
        }
        .summary-table tbody tr.has-crash { background: rgba(217, 75, 75, 0.06); }
        .summary-table tbody tr.has-crash:hover { background: rgba(217, 75, 75, 0.12); }
        .text-right { text-align: right; }
        .table-col-name { min-width: 220px; width: 26%; }
        .table-col-return { min-width: 110px; width: 110px; }
        .table-col-amount { min-width: 150px; }
        .table-col-default { min-width: 130px; }
        .table-col-drop { min-width: 140px; }
        .table-col-portfolio { min-width: 150px; }
        .propad-control {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        .propad-note {
            color: var(--muted);
            font-size: 0.85rem;
            line-height: 1.3;
            text-align: right;
        }
        .pie-total {
            margin-top: 0.75rem;
            padding: 1rem 1.2rem;
            border-radius: 1rem;
            border: 1px solid var(--border);
            background: var(--surface);
            box-shadow: var(--shadow);
            display: inline-flex;
            flex-direction: column;
            gap: 0.35rem;
            align-items: flex-start;
            align-self: center;
        }
        .pie-total-label { font-size: 0.7rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--muted); font-weight: 600; }
        .pie-total-value { font-size: 1.1rem; font-weight: 600; color: var(--primary-strong); }
        .note-block {
            border: 1px solid var(--border);
            border-radius: 1.2rem;
            padding: 1.25rem;
            background: var(--surface);
            box-shadow: var(--shadow);
            font-size: 0.9rem;
            color: var(--muted);
        }
        .note-block.alert { border-color: rgba(217, 75, 75, 0.32); background: var(--danger-bg); color: var(--danger); }
        footer { padding: 3rem 0; color: var(--muted); font-size: 0.78rem; text-align: center; }
        .app-error {
            max-width: 560px;
            margin: 4rem auto;
            padding: 2rem;
            border-radius: 1.5rem;
            border: 1px solid var(--border-strong);
            background: var(--surface);
            box-shadow: var(--shadow);
            text-align: center;
            color: var(--danger);
            font-weight: 600;
        }
        @media (max-width: 768px) {
            .hero-description { font-size: 0.95rem; }
            .card-header { gap: 0.5rem; }
        }
        @media print {
            body { background: #fff; }
            .card-section, .surface-card, .info-card, .pie-legend-item, .note-block { box-shadow: none !important; }
            .toast-stack, .tooltip { display: none !important; }
            .btn { display: none !important; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script
        type="text/babel"
        data-presets="env,react"
        data-plugins="proposal-class-properties,proposal-object-rest-spread,proposal-optional-chaining,proposal-nullish-coalescing-operator"
    >
        const { useState, useMemo, useEffect, useRef, Fragment, useCallback, useContext } = React;

        const BASE_CURRENCY = 'CZK';
        const Y = 15;
        const randomId = () =>
            (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
                ? crypto.randomUUID()
                : `id-${Math.random().toString(36).slice(2, 11)}-${Date.now().toString(36)}`);
        const currencyFormatter = new Intl.NumberFormat('cs-CZ', { style: 'currency', currency: BASE_CURRENCY, maximumFractionDigits: 0 });
        const percentFormatter = new Intl.NumberFormat('cs-CZ', { style: 'percent', minimumFractionDigits: 2, maximumFractionDigits: 2 });
        const shortPercentFormatter = new Intl.NumberFormat('cs-CZ', { style: 'percent', minimumFractionDigits: 1, maximumFractionDigits: 1 });
        const dateFormatter = new Intl.DateTimeFormat('cs-CZ', { day: '2-digit', month: '2-digit', year: 'numeric' });
        const monthYearFormatter = new Intl.DateTimeFormat('cs-CZ', { month: 'long', year: 'numeric' });

        const parseMoney = (value) => {
            if (typeof value === 'number') return value;
            if (!value) return 0;
            const normalized = String(value).replace(/\s+/g, '').replace(/[^\d,.-]/g, '').replace(',', '.');
            const parsed = Number(normalized);
            return Number.isFinite(parsed) ? parsed : 0;
        };

        const parsePercentValue = (value) => {
            if (value === null || value === undefined || value === '') return 0;
            if (typeof value === 'number') return value / 100;
            const normalized = String(value).replace(/%/g, '').replace(',', '.');
            const parsed = Number(normalized);
            return Number.isFinite(parsed) ? parsed / 100 : 0;
        };

        const parseRate = (value) => {
            if (typeof value === 'number') return value / 100;
            return parsePercentValue(value);
        };

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        const parseISODate = (value) => {
            if (!value) return null;
            const [year, month, day] = value.split('-').map(Number);
            if (!year || !month || !day) return null;
            return new Date(Date.UTC(year, month - 1, day));
        };

        const toInputDate = (date) => {
            if (!(date instanceof Date)) return '';
            return date.toISOString().slice(0, 10);
        };

        const startOfToday = () => {
            const now = new Date();
            return new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));
        };

        const diffInYears = (start, end) => {
            if (!(start instanceof Date) || !(end instanceof Date)) return 0;
            return (end.getTime() - start.getTime()) / (365.2425 * 24 * 60 * 60 * 1000);
        };

        const addYears = (date, count) => {
            if (!(date instanceof Date)) return null;
            return new Date(Date.UTC(date.getUTCFullYear() + count, date.getUTCMonth(), date.getUTCDate()));
        };

        const formatCurrency = (value) => currencyFormatter.format(Math.round(value));
        const formatPercent = (value) => value === null || value === undefined ? '—' : percentFormatter.format(value);
        const formatShortPercent = (value) => value === null || value === undefined ? '—' : shortPercentFormatter.format(value);
        const formatDate = (date) => date instanceof Date ? dateFormatter.format(date) : '—';
        const formatMonthYear = (date) => date instanceof Date ? monthYearFormatter.format(date) : '—';

        const formatDuration = (years) => {
            if (!Number.isFinite(years) || years <= 0) return '0 let';
            const totalMonths = Math.round(years * 12);
            const fullYears = Math.floor(totalMonths / 12);
            const months = totalMonths % 12;
            const segments = [];
            if (fullYears > 0) segments.push(`${fullYears} ${fullYears === 1 ? 'rok' : fullYears < 5 ? 'roky' : 'let'}`);
            if (months > 0) segments.push(`${months} ${months === 1 ? 'měsíc' : months < 5 ? 'měsíce' : 'měsíců'}`);
            return segments.join(' ');
        };
        const getTimeString = () => new Date().toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' });
        const ToastContext = React.createContext({ push: () => {} });

        const TOAST_DURATION_MS = 3200;
        const TOAST_FADE_MS = 280;

        const ToastProvider = ({ children }) => {
            const [toasts, setToasts] = useState([]);
            const timersRef = useRef(new Map());

            const clearTimers = useCallback((id) => {
                const timers = timersRef.current.get(id);
                if (Array.isArray(timers)) {
                    timers.forEach((handle) => clearTimeout(handle));
                }
                timersRef.current.delete(id);
            }, []);

            const removeToast = useCallback((id) => {
                clearTimers(id);
                setToasts((prev) => prev.filter((toast) => toast.id !== id));
            }, [clearTimers]);

            const push = useCallback((message, tone = 'success') => {
                if (!message) return;
                const id = randomId();
                setToasts((prev) => [...prev, { id, message, tone, visible: true }]);
                const hideTimer = setTimeout(() => {
                    setToasts((prev) =>
                        prev.map((toast) => (toast.id === id ? { ...toast, visible: false } : toast)),
                    );
                }, TOAST_DURATION_MS);
                const removalTimer = setTimeout(() => removeToast(id), TOAST_DURATION_MS + TOAST_FADE_MS);
                timersRef.current.set(id, [hideTimer, removalTimer]);
            }, [removeToast]);

            useEffect(() => () => {
                timersRef.current.forEach((handles) => handles.forEach((handle) => clearTimeout(handle)));
                timersRef.current.clear();
            }, []);

            return (
                <ToastContext.Provider value={{ push }}>
                    {children}
                    <div className="toast-stack" aria-live="polite" aria-atomic="true">
                        {toasts.map((toast) => (
                            <div
                                key={toast.id}
                                className={`toast toast-${toast.tone} ${toast.visible ? 'show' : ''}`}
                                role="status"
                            >
                                <span>{toast.message}</span>
                            </div>
                        ))}
                    </div>
                </ToastContext.Provider>
            );
        };

        const useToasts = () => useContext(ToastContext);

        const MoneyInput = ({ value, onChange, placeholder }) => {
            const [displayValue, setDisplayValue] = useState(value);
            const inputRef = useRef(null);

            useEffect(() => {
                if (document.activeElement !== inputRef.current) {
                    const numericValue = parseMoney(value);
                    setDisplayValue(numericValue > 0 ? currencyFormatter.format(numericValue) : '');
                }
            }, [value]);

            const handleFocus = (event) => {
                const numericValue = parseMoney(event.target.value);
                setDisplayValue(numericValue === 0 ? '' : numericValue);
            };

            const handleBlur = (event) => {
                const numericValue = parseMoney(event.target.value);
                onChange(String(numericValue));
                setDisplayValue(numericValue > 0 ? currencyFormatter.format(numericValue) : '');
            };

            const handleChange = (event) => {
                setDisplayValue(event.target.value);
            };

            return (
                <input
                    ref={inputRef}
                    type="text"
                    inputMode="numeric"
                    className="table-input tabular-nums"
                    value={displayValue}
                    placeholder={placeholder}
                    onChange={handleChange}
                    onFocus={handleFocus}
                    onBlur={handleBlur}
                    autoComplete="off"
                    style={{ textAlign: 'right' }}
                />
            );
        };

        const PercentInput = ({ value, onChange, placeholder, disabled = false }) => (
            <input
                type="text"
                inputMode="decimal"
                className="table-input tabular-nums"
                value={value}
                placeholder={placeholder}
                onChange={(event) => onChange(event.target.value)}
                disabled={disabled}
                style={{ textAlign: 'right' }}
            />
        );

        const createFund = (
            name = 'Nový fond',
            rate = 5,
            segment = 'CODYA',
            startDate = toInputDate(startOfToday()),
            options = {},
        ) => {
            const normalizedStartDate = (() => {
                if (startDate instanceof Date) {
                    return toInputDate(startDate);
                }
                if (typeof startDate === 'string' && startDate) {
                    const parsed = parseISODate(startDate);
                    return parsed ? toInputDate(parsed) : startDate;
                }
                return toInputDate(startOfToday());
            })();

            return {
                id: randomId(),
                name,
                currency: BASE_CURRENCY,
                amountStr: '0',
                returnStr: String(rate),
                startDate: normalizedStartDate,
                segment,
                topUpStr: '0',
                crashYear: '0',
                crashMode: 'haircut',
                haircutStr: '50',
                defaultKey: options.defaultKey || null,
            };
        };

        const sanitizeFund = (fund, fallbackStartDate) => {
            const fallback = fallbackStartDate instanceof Date ? fallbackStartDate : startOfToday();
            const startDateInstance = fallback instanceof Date ? fallback : startOfToday();
            const startDateStr = toInputDate(startDateInstance);
            const rawHaircut = fund?.haircutStr;
            const normalizedHaircut = (() => {
                if (rawHaircut === undefined || rawHaircut === null) return '50';
                const trimmed = String(rawHaircut).trim();
                return trimmed === '' ? '50' : trimmed;
            })();

            const legacyZeroDrop = fund?.crashMode === 'zero';

            return {
                id: fund?.id || randomId(),
                name: fund?.name || 'Fond',
                currency: fund?.currency || BASE_CURRENCY,
                amountStr: String(fund?.amountStr ?? '0'),
                returnStr: String(fund?.returnStr ?? '0'),
                startDate: startDateStr,
                segment: fund?.segment || 'CODYA',
                topUpStr: String(fund?.topUpStr ?? fund?.amountStrY1 ?? '0'),
                crashYear: String(fund?.crashYear ?? fund?.failureYear ?? '0'),
                crashMode: 'haircut',
                haircutStr: legacyZeroDrop ? '100' : normalizedHaircut,
                defaultKey: fund?.defaultKey || null,
            };
        };

        const sanitizeTopUp = (topUp) => ({
            id: topUp?.id || randomId(),
            fundId: topUp?.fundId || '',
            date: topUp?.date || toInputDate(startOfToday()),
            amountStr: String(topUp?.amountStr ?? '0'),
        });

        const sanitizeCrash = (crash) => {
            return {
                id: crash?.id || randomId(),
                fundId: crash?.fundId || '',
                date: crash?.date || toInputDate(startOfToday()),
                mode: 'haircut',
                haircutStr: String(
                    crash?.haircutStr
                        ?? (crash?.mode === 'zero' ? '100' : '50')
                ),
            };
        };

        const deriveScenarioStartDate = (fundList) => {
            const anchor = startOfToday();
            let earliest = null;
            if (Array.isArray(fundList)) {
                fundList.forEach((fund) => {
                    const parsed = parseISODate(fund?.startDate);
                    if (parsed instanceof Date) {
                        if (!earliest || parsed < earliest) {
                            earliest = parsed;
                        }
                    }
                });
            }
            if (earliest instanceof Date && earliest.getTime() > anchor.getTime()) {
                return earliest;
            }
            return anchor;
        };

        const prepareScenarioInput = (funds) => {
            const today = startOfToday();
            const scenarioStart = deriveScenarioStartDate(funds);
            const preparedFunds = [];
            const topUps = [];
            const crashes = [];
            (funds || [])
                .map((fund) => sanitizeFund(fund, scenarioStart))
                .forEach((fund) => {
                    const startDate = parseISODate(fund.startDate) || scenarioStart || today;
                const startDateStr = toInputDate(startDate);
                preparedFunds.push({
                    id: fund.id,
                    name: fund.name,
                    currency: fund.currency || BASE_CURRENCY,
                    amountStr: String(fund.amountStr ?? '0'),
                    returnStr: String(fund.returnStr ?? '0'),
                    startDate: startDateStr,
                });
                const topUpAmount = parseMoney(fund.topUpStr);
                if (topUpAmount > 0) {
                    const topUpDate = addYears(startDate, 1);
                    topUps.push({
                        id: `${fund.id}-topup`,
                        fundId: fund.id,
                        date: toInputDate(topUpDate),
                        amountStr: String(topUpAmount),
                    });
                }
                    const crashYear = parseInt(fund.crashYear, 10);
                    if (Number.isFinite(crashYear) && crashYear > 0) {
                        const crashDate = addYears(startDate, crashYear);
                        crashes.push({
                            id: `${fund.id}-crash`,
                            fundId: fund.id,
                            date: toInputDate(crashDate),
                            mode: 'haircut',
                            haircutStr: String(fund.haircutStr ?? '50'),
                        });
                    }
                });
            return { funds: preparedFunds, topUps, crashes };
        };

        const STORAGE_KEY = 'fkiPurchaseScenarioState';
        function analyzeScenario(funds, topUps, crashes) {
            const scenarioStart = deriveScenarioStartDate(funds);
            const parsedFunds = (funds || []).map((fund) => sanitizeFund(fund, scenarioStart));
            const fundMap = new Map();
            parsedFunds.forEach((fund) => {
                fundMap.set(fund.id, {
                    ...fund,
                    rate: parseRate(fund.returnStr),
                    startDate: parseISODate(fund.startDate),
                });
            });

            const eventMap = new Map();
            const ensureEntry = (date) => {
                const time = date.getTime();
                if (!eventMap.has(time)) {
                    eventMap.set(time, { date, deposits: [], crashes: [], control: false });
                }
                return eventMap.get(time);
            };

            const cashFlows = [];
            let earliestDate = null;
            let latestDate = null;
            let topUpCount = 0;
            let crashCount = 0;
            const crashBreakdown = { propad: 0 };
            const MIN_HAIRCUT = 0.0005;

            fundMap.forEach((fund) => {
                const initialAmount = parseMoney(fund.amountStr);
                if (initialAmount > 0 && fund.startDate instanceof Date) {
                    const entry = ensureEntry(fund.startDate);
                    entry.deposits.push({
                        type: 'start',
                        fundId: fund.id,
                        amount: initialAmount,
                        label: 'Počáteční vklad',
                        fundName: fund.name,
                    });
                    cashFlows.push({ amount: -initialAmount, date: fund.startDate });
                    earliestDate = earliestDate ? (fund.startDate < earliestDate ? fund.startDate : earliestDate) : fund.startDate;
                    latestDate = latestDate ? (fund.startDate > latestDate ? fund.startDate : latestDate) : fund.startDate;
                }
            });

            (topUps || []).map(sanitizeTopUp).forEach((topUp) => {
                const fund = fundMap.get(topUp.fundId);
                const amount = parseMoney(topUp.amountStr);
                const date = parseISODate(topUp.date);
                if (!fund || !date || amount <= 0) return;
                if (fund.startDate instanceof Date && date < fund.startDate) return;
                const entry = ensureEntry(date);
                entry.deposits.push({
                    type: 'topup',
                    fundId: fund.id,
                    amount,
                    label: 'Dokup',
                    fundName: fund.name,
                });
                cashFlows.push({ amount: -amount, date });
                earliestDate = earliestDate ? (date < earliestDate ? date : earliestDate) : date;
                latestDate = latestDate ? (date > latestDate ? date : latestDate) : date;
                topUpCount += 1;
            });

            (crashes || []).map(sanitizeCrash).forEach((crash) => {
                const fund = fundMap.get(crash.fundId);
                const date = parseISODate(crash.date);
                if (!fund || !date) return;
                if (fund.startDate instanceof Date && date < fund.startDate) return;
                const entry = ensureEntry(date);
                const haircut = clamp(parsePercentValue(crash.haircutStr), 0, 1);
                if (haircut <= MIN_HAIRCUT) {
                    return;
                }
                entry.crashes.push({
                    type: 'default',
                    fundId: fund.id,
                    mode: 'haircut',
                    haircut,
                    fundName: fund.name,
                });
                earliestDate = earliestDate ? (date < earliestDate ? date : earliestDate) : date;
                latestDate = latestDate ? (date > latestDate ? date : latestDate) : date;
                crashCount += 1;
                crashBreakdown.propad = (crashBreakdown.propad || 0) + 1;
            });

            if (!earliestDate || eventMap.size === 0) {
                return {
                    hasData: false,
                    totalInvested: 0,
                    currentValue: 0,
                    pl: 0,
                    plPercent: 0,
                    xirr: null,
                    depositCount: topUpCount,
                    crashCount,
                    crashSummary: crashCount ? 'Bez aktivních vkladů' : 'Bez dat',
                    controlPoints: [],
                    markers: [],
                    timeline: [],
                    finalAllocations: [],
                    totalCrashLoss: 0,
                };
            }

            const today = startOfToday();
            const horizonDate = earliestDate ? addYears(earliestDate, Y) : null;
            const finalDateCandidates = [today];
            if (latestDate) finalDateCandidates.push(latestDate);
            if (horizonDate) finalDateCandidates.push(horizonDate);
            const finalDate = new Date(Math.max(...finalDateCandidates.map((date) => date.getTime())));
            ensureEntry(finalDate).control = true;

            const stageDefinitions = [];

            if (earliestDate) {
                ensureEntry(earliestDate).control = true;
                stageDefinitions.push({
                    key: 'start',
                    label: 'První nákup',
                    buttonLabel: '1. nákup',
                    targetDate: earliestDate,
                });
            }
            if (horizonDate) {
                ensureEntry(horizonDate).control = true;
            }

            if (earliestDate) {
                const stageOffsets = [
                    { key: 'afterTopUp', years: 1, label: 'Po roce (po dokupu)', buttonLabel: 'Po roce' },
                    { key: 'year5', years: 5, label: '5. rok', buttonLabel: '5. rok' },
                    { key: 'year10', years: 10, label: '10. rok', buttonLabel: '10. rok' },
                    { key: 'year15', years: 15, label: '15. rok', buttonLabel: '15. rok' },
                ];
                stageOffsets.forEach((stage) => {
                    const target = addYears(earliestDate, stage.years);
                    if (target && target <= finalDate) {
                        ensureEntry(target).control = true;
                        stageDefinitions.push({
                            key: stage.key,
                            label: stage.label,
                            buttonLabel: stage.buttonLabel,
                            targetDate: target,
                        });
                    }
                });
            }

            let controlCandidate = addYears(earliestDate, 3);
            while (controlCandidate && controlCandidate < finalDate) {
                ensureEntry(controlCandidate).control = true;
                controlCandidate = addYears(controlCandidate, 3);
            }

            const sortedEntries = Array.from(eventMap.values()).sort((a, b) => a.date - b.date);
            sortedEntries.forEach((entry) => {
                entry.deposits.sort((a, b) => {
                    if (a.type === b.type) return a.fundName.localeCompare(b.fundName);
                    return a.type === 'start' ? -1 : 1;
                });
            });

            const fundStates = new Map();
            fundMap.forEach((fund) => {
                fundStates.set(fund.id, {
                    id: fund.id,
                    name: fund.name,
                    rate: Number.isFinite(fund.rate) ? fund.rate : 0,
                    value: 0,
                    invested: 0,
                    status: 'pending',
                    canGrow: false,
                    hadDeposit: false,
                    locked: false,
                });
            });

            const applyGrowth = (from, to) => {
                if (!(from instanceof Date) || !(to instanceof Date)) return;
                const years = diffInYears(from, to);
                if (years <= 0) return;
                fundStates.forEach((state) => {
                    if (state.canGrow && state.status === 'active') {
                        state.value *= Math.pow(1 + state.rate, years);
                    }
                });
            };

            const sumPortfolioValue = () => {
                let total = 0;
                fundStates.forEach((state) => {
                    total += state.value;
                });
                return total;
            };

            const snapshotStates = () =>
                Array.from(fundStates.values()).map((state) => ({
                    id: state.id,
                    value: state.value,
                    invested: state.invested,
                    rate: state.rate,
                    status: state.status,
                    canGrow: state.canGrow,
                    locked: state.locked,
                }));

            const EPSILON = 0.005;

            let lastDate = sortedEntries[0]?.date;
            let investedSoFar = 0;
            let totalCrashLoss = 0;
            const timeline = [];
            const markers = [];
            const controlPoints = [];

            sortedEntries.forEach((entry, index) => {
                const entryDeposits = [];
                const entryCrashes = [];
                let entryDepositTotal = 0;
                let entryCrashTotalLoss = 0;
                if (index > 0 && lastDate) {
                    applyGrowth(lastDate, entry.date);
                }
                lastDate = entry.date;

                // Same-day events follow the mandated order: growth → deposits → crashes.
                const valueBeforeEvents = sumPortfolioValue();
                const snapshotBeforeEvents = snapshotStates();

                const pushPoint = (value, invested, snapshotOverride) => {
                    const finalSnapshot = snapshotOverride || snapshotStates();
                    const lastPoint = timeline[timeline.length - 1];
                    if (
                        lastPoint &&
                        lastPoint.date.getTime() === entry.date.getTime() &&
                        Math.abs(lastPoint.totalValue - value) < EPSILON
                    ) {
                        lastPoint.investedToDate = invested;
                        lastPoint.snapshot = finalSnapshot;
                        return;
                    }
                    timeline.push({
                        date: entry.date,
                        totalValue: value,
                        investedToDate: invested,
                        snapshot: finalSnapshot,
                    });
                };

                pushPoint(valueBeforeEvents, investedSoFar, snapshotBeforeEvents);
                let portfolioValueAfterDeposits = valueBeforeEvents;

                if (entry.deposits.length > 0) {
                    entry.deposits.forEach((deposit) => {
                        const state = fundStates.get(deposit.fundId);
                        if (!state) return;
                        if (!state.locked) {
                            state.status = 'active';
                            state.canGrow = true;
                        } else {
                            state.status = state.value <= EPSILON ? 'zeroed' : 'frozen';
                            state.canGrow = false;
                        }
                        state.hadDeposit = true;
                        state.invested += deposit.amount;
                        state.value += deposit.amount;
                        investedSoFar += deposit.amount;
                        entryDepositTotal += deposit.amount;
                        entryDeposits.push({
                            fundId: state.id,
                            fundName: state.name,
                            amount: deposit.amount,
                            label: deposit.label,
                            investedToDate: investedSoFar,
                        });
                    });

                    portfolioValueAfterDeposits = sumPortfolioValue();
                    const snapshotAfterDeposits = snapshotStates();
                    pushPoint(portfolioValueAfterDeposits, investedSoFar, snapshotAfterDeposits);
                }

                let portfolioValueBeforeCrashes = portfolioValueAfterDeposits;
                if (entry.crashes.length > 0) {
                    portfolioValueBeforeCrashes = sumPortfolioValue();
                    entry.crashes.forEach((crash) => {
                        const state = fundStates.get(crash.fundId);
                        if (!state || !state.hadDeposit) return;
                        const before = state.value;
                        if (before <= 0) return;
                        const haircut = clamp(crash.haircut, 0, 1);
                        if (haircut <= MIN_HAIRCUT) {
                            return;
                        }
                        state.value = state.value * (1 - haircut);
                        state.status = state.value <= EPSILON ? 'zeroed' : 'frozen';
                        state.canGrow = false;
                        state.locked = true;
                        const after = state.value;
                        const loss = Math.max(0, before - after);
                        if (loss > 0) {
                            totalCrashLoss += loss;
                            entryCrashTotalLoss += loss;
                        }
                        entryCrashes.push({
                            fundId: state.id,
                            fundName: state.name,
                            mode: crash.mode,
                            haircut: crash.haircut,
                            loss,
                        });
                    });
                }

                const totalValue = sumPortfolioValue();
                if (entry.crashes.length > 0) {
                    const aggregateLoss = Math.max(0, portfolioValueBeforeCrashes - totalValue);
                    if (aggregateLoss > entryCrashTotalLoss + EPSILON) {
                        const adjustment = aggregateLoss - entryCrashTotalLoss;
                        totalCrashLoss += adjustment;
                        entryCrashTotalLoss += adjustment;
                    }
                }
                const snapshot = snapshotStates();
                if (entry.crashes.length > 0 || entry.deposits.length === 0) {
                    pushPoint(totalValue, investedSoFar, snapshot);
                }

                if (entryDeposits.length > 0 || entryCrashes.length > 0) {
                    const kind = entryCrashes.length > 0 ? (entryDeposits.length > 0 ? 'mixed' : 'default') : 'deposit';
                    markers.push({
                        date: entry.date,
                        totalValue,
                        investedToDate: investedSoFar,
                        deposits: entryDeposits,
                        crashes: entryCrashes,
                        kind,
                        valueBeforeEvents,
                        valueAfterDeposits: portfolioValueAfterDeposits,
                        valueBeforeCrashes: entry.crashes.length > 0 ? portfolioValueBeforeCrashes : null,
                        valueAfterCrashes: entry.crashes.length > 0 ? totalValue : null,
                        depositTotal: entryDepositTotal,
                        crashTotalLoss: entryCrashTotalLoss,
                    });
                }

                if (entry.control || index === sortedEntries.length - 1) {
                    const pl = totalValue - investedSoFar;
                    controlPoints.push({
                        date: entry.date,
                        totalValue,
                        invested: investedSoFar,
                        pl,
                    });
                }
            });

            const getPointForTarget = (targetDate) => {
                if (!timeline.length) return null;
                if (!(targetDate instanceof Date)) {
                    return timeline[timeline.length - 1];
                }
                const targetTime = targetDate.getTime();
                let candidate = timeline[0];
                for (let i = 0; i < timeline.length; i += 1) {
                    const point = timeline[i];
                    if (point.date.getTime() <= targetTime + 1) {
                        candidate = point;
                    } else {
                        break;
                    }
                }
                return candidate;
            };

            const allocationStages = stageDefinitions.map((stage) => {
                const point = getPointForTarget(stage.targetDate);
                if (!point) {
                    return {
                        ...stage,
                        available: false,
                        date: null,
                        totalValue: 0,
                        allocations: [],
                    };
                }
                const totalValueAtStage = point.totalValue;
                const allocations = (point.snapshot || [])
                    .map((state) => {
                        const fund = fundMap.get(state.id);
                        return {
                            id: state.id,
                            name: fund ? fund.name : 'Fond',
                            value: state.value,
                        };
                    })
                    .filter((item) => item.value > 0.01)
                    .map((item) => ({
                        ...item,
                        share: totalValueAtStage > 0 ? item.value / totalValueAtStage : 0,
                    }))
                    .sort((a, b) => b.value - a.value);
                return {
                    ...stage,
                    available: true,
                    date: point.date,
                    totalValue: totalValueAtStage,
                    allocations,
                };
            });

            const totalInvested = investedSoFar;
            const finalEntry = timeline[timeline.length - 1];
            const finalValue = finalEntry ? finalEntry.totalValue : 0;
            const scenarioEnd = finalEntry ? finalEntry.date : finalDate;
            const timelineStart = timeline[0]?.date;

            if (finalValue !== 0 && scenarioEnd) {
                cashFlows.push({ amount: finalValue, date: scenarioEnd });
            }

            const normalizedCashFlows = normalizeCashFlows(cashFlows);
            const xirr = calculateXIRR(normalizedCashFlows);
            const pl = finalValue - totalInvested;
            const plPercent = totalInvested > 0 ? pl / totalInvested : 0;
            const durationYears = timelineStart ? diffInYears(timelineStart, scenarioEnd) : 0;
            const crashSummary = crashCount === 0
                ? 'Bez propadů'
                : `${crashBreakdown.propad || crashCount}× propad`;

            const finalAllocations = [];
            fundStates.forEach((state) => {
                if (state.value > 0.01) {
                    finalAllocations.push({
                        id: state.id,
                        name: state.name,
                        value: state.value,
                        share: finalValue > 0 ? state.value / finalValue : 0,
                    });
                }
            });
            finalAllocations.sort((a, b) => b.value - a.value);

            const exportSnapshot = {
                totals: {
                    totalInvested,
                    currentValue: finalValue,
                    pl,
                    plPercent,
                    xirr,
                },
                timeline: timeline.map((point) => ({
                    date: point.date.toISOString(),
                    totalValue: point.totalValue,
                    investedToDate: point.investedToDate,
                })),
                markers: markers.map((marker) => ({
                    ...marker,
                    date: marker.date.toISOString(),
                })),
                controlPoints: controlPoints.map((point) => ({
                    date: point.date.toISOString(),
                    totalValue: point.totalValue,
                    invested: point.invested,
                    pl: point.pl,
                })),
                finalAllocations: finalAllocations.map((item) => ({
                    name: item.name,
                    value: item.value,
                    share: item.share,
                })),
                allocationStages: allocationStages.map((stage) => ({
                    key: stage.key,
                    label: stage.label,
                    buttonLabel: stage.buttonLabel,
                    date: stage.date instanceof Date ? stage.date.toISOString() : null,
                    totalValue: stage.totalValue,
                    allocations: (stage.allocations || []).map((item) => ({
                        name: item.name,
                        value: item.value,
                        share: item.share,
                    })),
                })),
                startDate: timelineStart ? timelineStart.toISOString() : null,
                endDate: scenarioEnd ? scenarioEnd.toISOString() : null,
            };

            return {
                hasData: true,
                timeline,
                markers,
                controlPoints,
                totalInvested,
                currentValue: finalValue,
                pl,
                plPercent,
                xirr,
                depositCount: topUpCount,
                crashCount,
                crashSummary,
                totalCrashLoss,
                startDate: timelineStart,
                endDate: scenarioEnd,
                durationYears,
                finalAllocations,
                exportSnapshot,
                allocationStages,
                cashFlows: normalizedCashFlows,
            };
        }

        function normalizeCashFlows(cashFlows) {
            if (!Array.isArray(cashFlows)) return [];
            return cashFlows
                .filter((cf) => cf && cf.date instanceof Date && Number.isFinite(cf.amount) && cf.amount !== 0)
                .sort((a, b) => a.date - b.date);
        }

        function calculateXIRR(cashFlows) {
            if (!Array.isArray(cashFlows)) return null;
            const flows = cashFlows
                .filter((cf) => cf && cf.date instanceof Date && Number.isFinite(cf.amount) && cf.amount !== 0)
                .sort((a, b) => a.date - b.date);
            if (flows.length < 2) return null;
            const uniqueTimes = new Set(flows.map((cf) => cf.date.getTime()));
            if (uniqueTimes.size < 2) return null;
            const hasPositive = flows.some((cf) => cf.amount > 0);
            const hasNegative = flows.some((cf) => cf.amount < 0);
            if (!hasPositive || !hasNegative) return null;

            const baseDate = flows[0].date;
            const npv = (rate) => flows.reduce((acc, cf) => {
                const t = diffInYears(baseDate, cf.date);
                return acc + cf.amount / Math.pow(1 + rate, t);
            }, 0);
            const derivative = (rate) => flows.reduce((acc, cf) => {
                const t = diffInYears(baseDate, cf.date);
                return acc - (t * cf.amount) / Math.pow(1 + rate, t + 1);
            }, 0);

            let rate = 0.1;
            const epsilon = 1e-7;
            for (let i = 0; i < 100; i += 1) {
                const value = npv(rate);
                if (Math.abs(value) < epsilon) return rate;
                const deriv = derivative(rate);
                if (Math.abs(deriv) < epsilon) break;
                const nextRate = rate - value / deriv;
                if (!Number.isFinite(nextRate) || nextRate <= -0.9999) break;
                rate = nextRate;
            }

            let low = -0.9999;
            let high = 5;
            let mid = rate;
            for (let i = 0; i < 200; i += 1) {
                mid = (low + high) / 2;
                const value = npv(mid);
                if (Math.abs(value) < epsilon) return mid;
                if (value > 0) {
                    low = mid;
                } else {
                    high = mid;
                }
            }
            const finalValue = npv(mid);
            return Math.abs(finalValue) < 1e-4 ? mid : null;
        }
        const DEFAULT_FUND_CONFIG = [
            { key: 'CODYA::PFFL', segment: 'CODYA', name: 'PFFL', rate: 7.5 },
            { key: 'CODYA::Fond reverzních hypoték', segment: 'CODYA', name: 'Fond reverzních hypoték', rate: 6.65 },
            { key: 'CODYA::Silverline R.E.', segment: 'CODYA', name: 'Silverline R.E.', rate: 10 },
            { key: 'CODYA::Vigo Direct', segment: 'CODYA', name: 'Vigo Direct', rate: 8 },
            { key: 'CODYA::Adax', segment: 'CODYA', name: 'Adax', rate: 12 },
            { key: 'CODYA::Julius Meinl fond', segment: 'CODYA', name: 'Julius Meinl fond', rate: 14.5 },
            { key: 'CODYA::Penta R.E.', segment: 'CODYA', name: 'Penta R.E.', rate: 14 },
            { key: 'CODYA::Penta Equity', segment: 'CODYA', name: 'Penta Equity', rate: 14 },
            { key: 'CODYA::Artefin - Henry IF', segment: 'CODYA', name: 'Artefin - Henry IF', rate: 8.5 },
            { key: 'CODYA::FČKD', segment: 'CODYA', name: 'FČKD', rate: 7.5 },
            { key: 'AVANT::r2p invest', segment: 'AVANT', name: 'r2p invest', rate: 8.5 },
            { key: 'AVANT::Gartal', segment: 'AVANT', name: 'Gartal', rate: 7 },
            { key: 'AVANT::Realia', segment: 'AVANT', name: 'Realia', rate: 6 },
            { key: 'AVANT::EBM', segment: 'AVANT', name: 'EBM', rate: 8 },
            { key: 'AVANT::Wero', segment: 'AVANT', name: 'Wero', rate: 8 },
            { key: 'AVANT::Vihorev', segment: 'AVANT', name: 'Vihorev', rate: 8.5 },
            { key: 'AVANT::Real Luxembourg', segment: 'AVANT', name: 'Real Luxembourg', rate: 8 },
            { key: 'AVANT::Aguila', segment: 'AVANT', name: 'Aguila', rate: 7.5 },
            { key: 'AVANT::Spilberk', segment: 'AVANT', name: 'Spilberk', rate: 7 },
            { key: 'AVANT::Semper', segment: 'AVANT', name: 'Semper', rate: 11 },
        ];

        const getDefaultFunds = () => {
            const startDateStr = toInputDate(startOfToday());
            return DEFAULT_FUND_CONFIG.map((config) =>
                createFund(config.name, config.rate, config.segment, startDateStr, { defaultKey: config.key }),
            );
        };

        const ensureDefaultFunds = (fundList) => {
            const scenarioStartDate = deriveScenarioStartDate(fundList);
            const startDateStr = toInputDate(scenarioStartDate);
            const sanitized = (fundList || []).map((fund) => sanitizeFund(fund, scenarioStartDate));
            const keyFor = (fund) => fund.defaultKey || `${fund.segment}::${fund.name}`;
            const usedIds = new Set();
            const result = [];

            DEFAULT_FUND_CONFIG.forEach((config) => {
                const match = sanitized.find((fund) => keyFor(fund) === config.key);
                if (match) {
                    result.push({ ...match, segment: config.segment, defaultKey: config.key });
                    usedIds.add(match.id);
                } else {
                    result.push(createFund(config.name, config.rate, config.segment, startDateStr, { defaultKey: config.key }));
                }
            });

            sanitized.forEach((fund) => {
                if (!usedIds.has(fund.id)) {
                    result.push(fund);
                }
            });

            return result;
        };

        const loadScenarioFromStorage = () => {
            if (typeof window === 'undefined' || !window.localStorage) {
                return null;
            }
            const stored = window.localStorage.getItem(STORAGE_KEY);
            if (!stored) {
                return null;
            }
            const parsed = JSON.parse(stored);
            return {
                clientName: typeof parsed.clientName === 'string' ? parsed.clientName : '',
                funds:
                    Array.isArray(parsed.funds) && parsed.funds.length > 0
                        ? ensureDefaultFunds(parsed.funds)
                        : getDefaultFunds(),
            };
        };

        const useScenarioState = (pushToast) => {
            const [clientName, setClientName] = useState('');
            const [funds, setFunds] = useState(getDefaultFunds);
            const [lastSaved, setLastSaved] = useState(null);
            const hydratedRef = useRef(false);

            useEffect(() => {
                if (hydratedRef.current) {
                    return;
                }
                hydratedRef.current = true;
                try {
                    const snapshot = loadScenarioFromStorage();
                    if (snapshot) {
                        setClientName(snapshot.clientName);
                        setFunds(snapshot.funds);
                        pushToast?.('Data byla úspěšně načtena.');
                    }
                } catch (error) {
                    console.error(error);
                    pushToast?.('Nepodařilo se načíst uložená data.', 'error');
                } finally {
                    setLastSaved(getTimeString());
                }
            }, [pushToast]);

            useEffect(() => {
                try {
                    const storage = typeof window !== 'undefined' ? window.localStorage : null;
                    if (!storage) {
                        return;
                    }
                    const snapshot = { clientName, funds };
                    storage.setItem(STORAGE_KEY, JSON.stringify(snapshot));
                    setLastSaved(getTimeString());
                } catch (error) {
                    console.error(error);
                }
            }, [clientName, funds]);

            return { clientName, setClientName, funds, setFunds, lastSaved };
        };

        const SEGMENT_CONFIG = [
            {
                key: 'CODYA',
                label: 'CODYA',
                demo: DEFAULT_FUND_CONFIG.filter((config) => config.segment === 'CODYA').map((config) => config.name),
            },
            {
                key: 'AVANT',
                label: 'AVANT',
                demo: DEFAULT_FUND_CONFIG.filter((config) => config.segment === 'AVANT').map((config) => config.name),
            },
        ];

        const useResizeObserver = (ref) => {
            const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
            useEffect(() => {
                const target = ref.current;
                if (!target) return undefined;

                const readDimensions = () => {
                    const element = ref.current;
                    if (!element) return;
                    const rect = element.getBoundingClientRect();
                    const width = rect.width || element.offsetWidth || element.clientWidth || 0;
                    const height = rect.height || element.offsetHeight || element.clientHeight || 0;
                    setDimensions({ width, height });
                };

                readDimensions();

                let rafId = null;
                if (typeof window !== 'undefined') {
                    rafId = window.requestAnimationFrame(readDimensions);
                }

                let observer = null;
                let resizeListenerAttached = false;

                if (typeof ResizeObserver === 'function') {
                    observer = new ResizeObserver(() => readDimensions());
                    observer.observe(target);
                } else if (typeof window !== 'undefined') {
                    window.addEventListener('resize', readDimensions);
                    resizeListenerAttached = true;
                }

                return () => {
                    if (observer) {
                        observer.disconnect();
                    }
                    if (typeof window !== 'undefined') {
                        if (rafId !== null) {
                            window.cancelAnimationFrame(rafId);
                        }
                        if (resizeListenerAttached) {
                            window.removeEventListener('resize', readDimensions);
                        }
                    }
                };
            }, [ref]);
            return dimensions;
        };

        const createPath = (points) => {
            if (!points || points.length < 2) return '';
            return `M ${points.map((point) => `${point.x},${point.y}`).join(' L ')}`;
        };
        const InfoCard = ({ title, value, subValue }) => (
            <div className="info-card">
                <div className="info-card-title">{title}</div>
                <div className="info-card-value tabular-nums">{value}</div>
                {subValue && <div className="info-card-sub">{subValue}</div>}
            </div>
        );

        const ReportHero = ({ lastSaved, clientName, onClientNameChange }) => {
            return (
                <header className="brand-header">
                    <div className="brand-backdrop"></div>
                    <div className="app-shell brand-header-inner">
                        <div className="hero-intro">
                            <div className="brand-identity">
                                <div className="brand-logo">Fair<span>Life</span></div>
                                <div className="hero-kicker">NÁVRH PORTFOLIA &amp; SCÉNÁŘE</div>
                            </div>
                            <h1 className="hero-title hero-title-upper">Sestavte investiční portfolio a vizualizujte jeho budoucnost</h1>
                            <p className="hero-description">
                                Přidávejte fondy, nastavujte dnešní vklad, dokup po 1. roce a případný jednorázový pokles. Vše propočítáme do jedné křivky a přehledných karet, abyste mohli scénáře srozumitelně vysvětlit.
                            </p>
                            <div className="hero-disclaimer">
                                <span><strong>© 2025 Ondřej Lacina</strong></span>
                                <span>Toto dílo je chráněno autorským právem dle zákona č. 121/2000 Sb.</span>
                                <span>Šíření mimo strukturu Fair-life je zakázáno.</span>
                            </div>
                            <div className="meta-deck" style={{ marginTop: '2rem' }}>
                                <label className="meta-card">
                                    <span className="meta-label">Jméno klienta</span>
                                    <input className="input input-ghost" value={clientName} onChange={(event) => onClientNameChange(event.target.value)} placeholder="Např. Jana Nováková" />
                                </label>
                            </div>
                        </div>
                        <div className="hero-card-stack">
                            <div className="surface-card">
                                <small>Sestavení a scénáře</small>
                                <h3>Sestavte a simulujte</h3>
                                <p>
                                    Zadejte výnosy, počáteční vklad a dokup po 1. roce. Jednorázový pokles přidejte v libovolném roce a hned uvidíte dopad na vývoj.
                                </p>
                            </div>
                            <div className="surface-card">
                                <small>Vizualizace pro klienta</small>
                                <h3>Přehledně na grafech</h3>
                                <p>
                                    Koláč ukáže rozložení dnes, časová osa průběžný vývoj. Snadno tak předvedete vliv dokupu i poklesu v delším horizontu.
                                </p>
                            </div>
                        </div>
                    </div>
                </header>
            );
        };

        const DataManagement = ({ onExport, onImport, onReset }) => {
            const fileInputRef = useRef(null);
            return (
                <section className="card-section">
                    <input type="file" ref={fileInputRef} onChange={onImport} accept=".json" style={{ display: 'none' }} />
                    <div className="card-header">
                        <div>
                            <span className="badge-pill">Správa dat</span>
                            <h2 className="card-header-title">Export a import scénáře</h2>
                            <p className="card-header-sub">Soubor .json uchová veškeré vstupy včetně výsledné křivky, markerů i kontrolních bodů.</p>
                        </div>
                        <div className="control-bar">
                            <button className="btn btn-secondary" onClick={onExport}>Exportovat do .json</button>
                            <button className="btn btn-secondary" onClick={() => fileInputRef.current?.click()}>Importovat z .json</button>
                            <button className="btn btn-danger" onClick={onReset}>Resetovat scénář</button>
                        </div>
                    </div>
                </section>
            );
        };
        const SegmentSummary = ({ segment, total, weightedReturn }) => (
            <div className="meta-deck" style={{ marginTop: '1.25rem' }}>
                <div className="meta-card">
                    <span className="meta-label">Investováno v {segment.label}</span>
                    <span className="meta-value tabular-nums">{formatCurrency(total)}</span>
                </div>
                <div className="meta-card">
                    <span className="meta-label">Vážené zhodnocení</span>
                    <span className="meta-value tabular-nums">{formatPercent(weightedReturn)}</span>
                </div>
            </div>
        );

        const SegmentTable = ({ segment, funds, onAddFund, onUpdateFund, onRemoveFund, onResetSegment, onDemoSegment, portfolioTotal }) => {
            const segmentTotal = funds.reduce((sum, fund) => sum + parseMoney(fund.amountStr), 0);
            const weightedReturn = segmentTotal > 0
                ? funds.reduce((sum, fund) => sum + parseMoney(fund.amountStr) * parseRate(fund.returnStr), 0) / segmentTotal
                : 0;

            return (
                <section className="card-section">
                    <div className="card-header">
                        <div>
                            <span className="badge-pill">{segment.label}</span>
                            <h2 className="card-header-title">Segment {segment.label}</h2>
                            <p className="card-header-sub">Upravte předdefinované fondy, dokup po 1. roce a potenciální propad.</p>
                        </div>
                        <div className="control-bar">
                            <button className="btn btn-secondary" onClick={onDemoSegment}>Ukázka</button>
                            <button className="btn btn-secondary" onClick={onResetSegment}>Vynulovat</button>
                            <button className="btn btn-secondary" onClick={onAddFund}>Přidat fond</button>
                        </div>
                    </div>
                    <div className="overflow-x-auto">
                        <table>
                            <thead>
                                <tr>
                                    <th className="table-col-name">Fond</th>
                                    <th className="table-col-return">Výnos p.a.</th>
                                    <th className="table-col-amount">Počáteční vklad</th>
                                    <th className="table-col-amount">Dokup po 1. roce</th>
                                    <th className="table-col-default">Propad (rok)</th>
                                    <th className="table-col-drop">Propad</th>
                                    <th className="table-col-portfolio">Podíl v portfoliu</th>
                                    <th style={{ width: '56px' }}></th>
                                </tr>
                            </thead>
                            <tbody>
                                {funds.length === 0 && (
                                    <tr>
                                        <td colSpan="8" style={{ textAlign: 'center', padding: '1.5rem', color: 'var(--muted)' }}>
                                            Přidejte fond pro tento segment.
                                        </td>
                                    </tr>
                                )}
                                {funds.map((fund) => {
                                    const amount = parseMoney(fund.amountStr);
                                    const portfolioShare = portfolioTotal > 0 ? amount / portfolioTotal : 0;
                                    return (
                                        <tr key={fund.id}>
                                            <td className="table-col-name">
                                                <input className="table-input" value={fund.name} onChange={(event) => onUpdateFund(fund.id, { name: event.target.value })} />
                                            </td>
                                            <td className="table-col-return">
                                                <PercentInput value={fund.returnStr} onChange={(value) => onUpdateFund(fund.id, { returnStr: value })} />
                                            </td>
                                            <td className="table-col-amount">
                                                <MoneyInput value={fund.amountStr} onChange={(value) => onUpdateFund(fund.id, { amountStr: value })} />
                                            </td>
                                            <td className="table-col-amount">
                                                <MoneyInput value={fund.topUpStr} onChange={(value) => onUpdateFund(fund.id, { topUpStr: value })} />
                                            </td>
                                            <td className="table-col-default">
                                                <select className="table-select" value={fund.crashYear} onChange={(event) => onUpdateFund(fund.id, { crashYear: event.target.value })}>
                                                    <option value="0">Nikdy</option>
                                                    {Array.from({ length: Y }, (_, index) => index + 1).map((year) => (
                                                        <option key={year} value={String(year)}>Po {year}. roce</option>
                                                    ))}
                                                </select>
                                            </td>
                                            <td className="table-col-drop">
                                                {fund.crashYear === '0' ? (
                                                    <span className="meta-label" style={{ color: 'var(--muted)', display: 'inline-block', minWidth: '3ch', textAlign: 'right' }}>—</span>
                                                ) : (
                                                    <div className="propad-control">
                                                        <PercentInput
                                                            value={fund.haircutStr}
                                                            onChange={(value) => onUpdateFund(fund.id, { haircutStr: value, crashMode: 'haircut' })}
                                                            placeholder="50"
                                                        />
                                                        <span className="propad-note">100 % = propad na nulu.</span>
                                                    </div>
                                                )}
                                            </td>
                                            <td className="tabular-nums table-col-portfolio">{formatPercent(portfolioShare)}</td>
                                            <td className="table-actions">
                                                <button className="icon-button" onClick={() => onRemoveFund(fund.id)} title="Odebrat fond">×</button>
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                    {segmentTotal > 0 && <SegmentSummary segment={segment} total={segmentTotal} weightedReturn={weightedReturn} />}
                </section>
            );
        };

        const projectSnapshotToHorizon = (snapshot, yearsForward) => {
            if (!Array.isArray(snapshot) || snapshot.length === 0) {
                return {
                    total: 0,
                    weightedRate: null,
                    investedWeightedRate: null,
                    activeWeightedRate: null,
                    activeValue: 0,
                    activeInvested: 0,
                    lockedValue: 0,
                    lockedInvested: 0,
                    lockedShortfall: 0,
                };
            }
            const years = Number.isFinite(yearsForward) && yearsForward > 0 ? yearsForward : 0;
            let total = 0;
            let investedNumerator = 0;
            let investedDenominator = 0;
            let valueNumerator = 0;
            let valueDenominator = 0;
            let activeValueTotal = 0;
            let activeInvestedTotal = 0;
            let activeValueNumerator = 0;
            let lockedValueTotal = 0;
            let lockedInvestedTotal = 0;
            snapshot.forEach((state) => {
                if (!state) return;
                const baseValue = Number.isFinite(state.value) ? state.value : 0;
                const invested = Number.isFinite(state.invested) ? state.invested : 0;
                if (baseValue <= 0 && invested <= 0) return;
                const rate = Number.isFinite(state.rate) ? state.rate : 0;
                const isUnlocked = state.locked !== true;
                const canAccrue = state.status === 'active' && state.canGrow === true && isUnlocked;
                const effectiveRate = canAccrue ? rate : 0;
                let projectedValue = 0;
                if (baseValue > 0) {
                    projectedValue = canAccrue ? baseValue * Math.pow(1 + rate, years) : baseValue;
                    total += projectedValue;
                }
                if (invested > 0) {
                    investedDenominator += invested;
                    investedNumerator += invested * effectiveRate;
                    if (canAccrue) {
                        activeInvestedTotal += invested;
                    } else {
                        lockedInvestedTotal += invested;
                    }
                }
                if (projectedValue > 0) {
                    valueDenominator += projectedValue;
                    valueNumerator += projectedValue * effectiveRate;
                    if (canAccrue) {
                        activeValueTotal += projectedValue;
                        activeValueNumerator += projectedValue * rate;
                    } else {
                        lockedValueTotal += projectedValue;
                    }
                }
            });
            const investedWeightedRate = investedDenominator > 0 ? investedNumerator / investedDenominator : null;
            const valueWeightedRate = valueDenominator > 0 ? valueNumerator / valueDenominator : investedWeightedRate;
            const activeWeightedRate = activeValueTotal > 0 ? activeValueNumerator / activeValueTotal : null;
            const lockedShortfall = Math.max(0, lockedInvestedTotal - lockedValueTotal);
            return {
                total,
                weightedRate: valueWeightedRate,
                investedWeightedRate,
                activeWeightedRate,
                activeValue: activeValueTotal,
                activeInvested: activeInvestedTotal,
                lockedValue: lockedValueTotal,
                lockedInvested: lockedInvestedTotal,
                lockedShortfall,
            };
        };

        const projectPointToDate = (point, targetDate, overrideYearsForward) => {
            if (!point || !(point.date instanceof Date)) {
                const fallbackValue = Number(point?.totalValue) || 0;
                return {
                    total: Math.max(fallbackValue, 0),
                    weightedRate: null,
                    investedWeightedRate: null,
                    activeWeightedRate: null,
                    activeValue: 0,
                    activeInvested: 0,
                    lockedValue: 0,
                    lockedInvested: 0,
                    lockedShortfall: 0,
                    yearsForward: 0,
                };
            }
            const safeTarget = targetDate instanceof Date ? targetDate : point.date;
            const baseValue = Number(point.totalValue) || 0;
            const snapshot = Array.isArray(point.snapshot) ? point.snapshot : [];
            let yearsForward = Number.isFinite(overrideYearsForward)
                ? overrideYearsForward
                : diffInYears(point.date, safeTarget);
            if (!Number.isFinite(yearsForward) || yearsForward <= 0) {
                yearsForward = 0;
            }
            if (snapshot.length === 0) {
                return {
                    total: Math.max(baseValue, 0),
                    weightedRate: null,
                    investedWeightedRate: null,
                    activeWeightedRate: null,
                    activeValue: 0,
                    activeInvested: 0,
                    lockedValue: 0,
                    lockedInvested: 0,
                    lockedShortfall: 0,
                    yearsForward,
                };
            }
            const projection = projectSnapshotToHorizon(snapshot, yearsForward);
            const total = Number.isFinite(projection.total) ? projection.total : baseValue;
            return {
                total: Math.max(total, 0),
                weightedRate: projection.weightedRate,
                investedWeightedRate: projection.investedWeightedRate,
                activeWeightedRate: projection.activeWeightedRate,
                activeValue: projection.activeValue,
                activeInvested: projection.activeInvested,
                lockedValue: projection.lockedValue,
                lockedInvested: projection.lockedInvested,
                lockedShortfall: projection.lockedShortfall,
                yearsForward,
            };
        };

        const createProjectionEngine = (analysis) => {
            const rawTimeline = Array.isArray(analysis?.timeline) ? analysis.timeline : [];
            const timeline = rawTimeline
                .filter((point) => point && point.date instanceof Date)
                .map((point) => ({ ...point }))
                .sort((a, b) => a.date - b.date);

            if (timeline.length === 0) {
                return {
                    timeline: [],
                    originDate: null,
                    finalDate: null,
                    totalYears: 0,
                    projectTo: () => null,
                };
            }

            const originDate = analysis?.startDate instanceof Date ? analysis.startDate : timeline[0].date;
            const finalDate = analysis?.endDate instanceof Date ? analysis.endDate : timeline[timeline.length - 1].date;
            const sanitizedFlows = normalizeCashFlows(analysis?.cashFlows);

            const locatePoint = (targetDate) => {
                let candidate = timeline[0];
                for (let i = 0; i < timeline.length; i += 1) {
                    const point = timeline[i];
                    if (!(point.date instanceof Date)) continue;
                    if (point.date.getTime() <= targetDate.getTime()) {
                        candidate = point;
                    } else {
                        break;
                    }
                }
                return candidate;
            };

            const projectTo = (targetDate, options = {}) => {
                if (!(targetDate instanceof Date)) {
                    return null;
                }
                const safeTarget = targetDate > finalDate ? finalDate : targetDate;
                const basePoint = locatePoint(safeTarget) || timeline[0];
                if (!basePoint) {
                    return null;
                }

                const invested = Number.isFinite(basePoint.investedToDate) ? basePoint.investedToDate : 0;
                const elapsedHint = Number.isFinite(options.elapsedHint) && options.elapsedHint >= 0
                    ? options.elapsedHint
                    : diffInYears(originDate, safeTarget);
                const rawElapsedYears = diffInYears(originDate, safeTarget);
                const elapsedYears = Math.abs(rawElapsedYears - elapsedHint) < 0.05 ? elapsedHint : rawElapsedYears;
                const basePointDate = basePoint.date instanceof Date ? basePoint.date : originDate;
                const baseElapsedYears = diffInYears(originDate, basePointDate);
                const baseSliderYears = Number.isFinite(baseElapsedYears) ? Math.round(baseElapsedYears) : 0;
                const candidateYearsFromBase = Math.max(0, elapsedHint - baseSliderYears);
                const rawYearsFromBase = Math.max(0, diffInYears(basePointDate, safeTarget));
                const yearsFromBase = Math.abs(rawYearsFromBase - candidateYearsFromBase) < 0.05
                    ? candidateYearsFromBase
                    : rawYearsFromBase;

                const projection = projectPointToDate(basePoint, safeTarget, yearsFromBase);
                const totalValue = Number.isFinite(projection.total) ? projection.total : 0;
                const gain = totalValue - invested;
                const gainPercent = invested > 0 ? gain / invested : null;

                const negativeFlows = sanitizedFlows.filter(
                    (flow) => flow.date instanceof Date && flow.date.getTime() <= safeTarget.getTime() && flow.amount < 0,
                );
                const flowsForPoint = [...negativeFlows];
                if (totalValue > 0) {
                    flowsForPoint.push({ amount: totalValue, date: safeTarget });
                }

                const earliestNegativeDate = negativeFlows[0]?.date instanceof Date ? negativeFlows[0].date : null;
                const rawHorizonYears = earliestNegativeDate ? diffInYears(earliestNegativeDate, safeTarget) : 0;
                const horizonYears = Math.abs(rawHorizonYears - elapsedHint) < 0.05 ? elapsedHint : rawHorizonYears;
                const totalInvestedFromFlows = negativeFlows.reduce((acc, flow) => acc - flow.amount, 0);
                const lockedValue = Number.isFinite(projection.lockedValue) ? projection.lockedValue : 0;
                const lockedInvested = Number.isFinite(projection.lockedInvested) ? projection.lockedInvested : 0;
                const lockedShortfall = Number.isFinite(projection.lockedShortfall)
                    ? projection.lockedShortfall
                    : Math.max(0, lockedInvested - lockedValue);
                const activeValue = Number.isFinite(projection.activeValue)
                    ? projection.activeValue
                    : Math.max(0, totalValue - lockedValue);
                const activeInvested = Number.isFinite(projection.activeInvested)
                    ? projection.activeInvested
                    : Math.max(0, invested - lockedInvested);

                let portfolioXirr = flowsForPoint.length >= 2 ? calculateXIRR(flowsForPoint) : null;

                if (
                    (portfolioXirr === null || !Number.isFinite(portfolioXirr)) &&
                    horizonYears > 1e-6 &&
                    totalInvestedFromFlows > 0 &&
                    totalValue > 0
                ) {
                    const impliedRate = Math.pow(totalValue / totalInvestedFromFlows, 1 / Math.max(horizonYears, 1e-6)) - 1;
                    if (Number.isFinite(impliedRate)) {
                        portfolioXirr = impliedRate;
                    }
                }

                if (
                    (portfolioXirr === null || !Number.isFinite(portfolioXirr)) &&
                    (Number.isFinite(projection.weightedRate) || Number.isFinite(projection.investedWeightedRate))
                ) {
                    portfolioXirr = Number.isFinite(projection.weightedRate)
                        ? projection.weightedRate
                        : projection.investedWeightedRate;
                }

                let activeXirr = null;
                if (activeInvested > 0 && activeValue > 0 && horizonYears > 1e-6) {
                    const ratio = activeValue / activeInvested;
                    if (ratio > 0) {
                        const solved = Math.pow(ratio, 1 / Math.max(horizonYears, 1e-6)) - 1;
                        if (Number.isFinite(solved)) {
                            activeXirr = solved;
                        }
                    }
                }

                if (activeXirr === null || !Number.isFinite(activeXirr)) {
                    if (Number.isFinite(projection.activeWeightedRate)) {
                        activeXirr = projection.activeWeightedRate;
                    } else if (Number.isFinite(projection.weightedRate)) {
                        activeXirr = projection.weightedRate;
                    }
                }

                const preferActive = lockedShortfall > 1 && Number.isFinite(activeXirr);
                let pointXirr = preferActive && Number.isFinite(activeXirr) ? activeXirr : portfolioXirr;
                if (pointXirr === null || !Number.isFinite(pointXirr)) {
                    pointXirr = Number.isFinite(portfolioXirr) ? portfolioXirr : activeXirr;
                }
                const usingActiveXirr = preferActive && Number.isFinite(pointXirr) && pointXirr === activeXirr;

                return {
                    date: safeTarget,
                    invested,
                    totalValue,
                    gain,
                    gainPercent,
                    elapsedYears,
                    weightedRate: projection.weightedRate,
                    investedWeightedRate: projection.investedWeightedRate,
                    activeWeightedRate: projection.activeWeightedRate,
                    activeValue,
                    activeInvested,
                    lockedValue,
                    lockedInvested,
                    lockedShortfall,
                    xirr: pointXirr,
                    portfolioXirr: Number.isFinite(portfolioXirr) ? portfolioXirr : null,
                    activeXirr: Number.isFinite(activeXirr) ? activeXirr : null,
                    usingActiveXirr,
                };
            };

            return {
                timeline,
                originDate,
                finalDate,
                totalYears: Math.max(0, Math.ceil(diffInYears(originDate, finalDate))),
                projectTo,
            };
        };

        const ScenarioSummary = ({ analysis }) => {
            const formatSignedCurrency = (value) => {
                if (!Number.isFinite(value)) {
                    return '—';
                }
                const absolute = Math.abs(value);
                if (absolute < 0.5) {
                    return formatCurrency(0);
                }
                const formatted = formatCurrency(absolute);
                if (value > 0) return `+${formatted}`;
                if (value < 0) return `−${formatted}`;
                return formatted;
            };

            const projection = useMemo(() => createProjectionEngine(analysis), [analysis]);
            const { originDate, finalDate, totalYears, projectTo, timeline } = projection;

            const sliderPoints = useMemo(() => {
                if (!(originDate instanceof Date) || !(finalDate instanceof Date) || typeof projectTo !== 'function') {
                    return [];
                }

                const maxYear = Math.max(totalYears, 0);

                return Array.from({ length: maxYear + 1 }, (_, year) => {
                    const rawTarget = year === 0 ? originDate : addYears(originDate, year);
                    const targetDate = rawTarget instanceof Date && rawTarget < finalDate ? rawTarget : finalDate;
                    const projected = projectTo(targetDate, { elapsedHint: year });
                    if (!projected) {
                        return null;
                    }
                    return {
                        index: year,
                        year,
                        date: projected.date,
                        invested: projected.invested,
                        totalValue: projected.totalValue,
                        gain: projected.gain,
                        gainPercent: projected.gainPercent,
                        elapsedYears: projected.elapsedYears,
                        xirr: projected.xirr,
                        portfolioXirr: projected.portfolioXirr,
                        activeXirr: projected.activeXirr,
                        lockedShortfall: projected.lockedShortfall,
                        lockedValue: projected.lockedValue,
                        lockedInvested: projected.lockedInvested,
                        activeValue: projected.activeValue,
                        activeInvested: projected.activeInvested,
                        usingActiveXirr: projected.usingActiveXirr,
                        weightedRate: projected.weightedRate,
                        investedWeightedRate: projected.investedWeightedRate,
                    };
                }).filter(Boolean);
            }, [originDate, finalDate, totalYears, projectTo]);


            const firstActiveIndex = sliderPoints.findIndex((point) => point.invested > 0 || point.totalValue > 0);
            const defaultIndex = firstActiveIndex >= 0 ? firstActiveIndex : 0;
            const [selectedIndex, setSelectedIndex] = useState(() => defaultIndex);
            const hasHydratedRef = useRef(false);

            useEffect(() => {
                if (!sliderPoints.length) {
                    hasHydratedRef.current = false;
                    setSelectedIndex(0);
                    return;
                }
                setSelectedIndex((prev) => {
                    let next = prev;
                    if (!hasHydratedRef.current) {
                        hasHydratedRef.current = true;
                        next = defaultIndex;
                    }
                    if (!Number.isFinite(next)) {
                        next = defaultIndex;
                    }
                    const clamped = Math.min(Math.max(next, 0), sliderPoints.length - 1);
                    return clamped === prev ? prev : clamped;
                });
            }, [sliderPoints.length, defaultIndex]);

            const hasData = Boolean(analysis?.hasData);
            const sliderAvailable = sliderPoints.length > 0;
            const sliderMaxIndex = sliderAvailable ? sliderPoints.length - 1 : 0;
            const activeIndex = sliderAvailable ? Math.min(Math.max(selectedIndex, 0), sliderMaxIndex) : 0;
            const selectedPoint = sliderAvailable ? sliderPoints[activeIndex] : null;
            const sliderDisabled = sliderPoints.length <= 1;
            const sliderMax = Math.max(sliderPoints.length - 1, 0);
            const sliderProgress = sliderMax > 0 ? `${((activeIndex / sliderMax) * 100).toFixed(2)}%` : '0%';

            const dateLabel = selectedPoint ? formatDate(selectedPoint.date) : '—';
            const elapsedLabel = selectedPoint
                ? selectedPoint.year === 0
                    ? 'Začátek'
                    : formatDuration(selectedPoint.elapsedYears)
                : '—';
            const investedLabel = selectedPoint ? formatCurrency(selectedPoint.invested) : '—';
            const totalValueLabel = selectedPoint ? formatCurrency(selectedPoint.totalValue) : '—';
            const gainPercentLabel =
                selectedPoint && selectedPoint.gainPercent !== null ? formatPercent(selectedPoint.gainPercent) : '—';
            const gainCurrencyLabel = selectedPoint ? formatSignedCurrency(selectedPoint.gain) : '—';
            const startLabel = sliderAvailable ? 'Rok 0' : '—';
            const endLabel = sliderAvailable ? `Rok ${sliderPoints[sliderPoints.length - 1].year}` : '—';
            const usingActiveXirr = selectedPoint?.usingActiveXirr === true;
            const xirrValue = Number.isFinite(selectedPoint?.xirr) ? selectedPoint.xirr : null;
            const portfolioXirrValue = Number.isFinite(selectedPoint?.portfolioXirr) ? selectedPoint.portfolioXirr : null;
            const xirrDurationLabel = selectedPoint
                ? selectedPoint.year === 0
                    ? 'Začátek scénáře'
                    : `K ${formatDuration(selectedPoint.elapsedYears)}`
                : 'Čekáme na data';
            const xirrTitle = usingActiveXirr ? 'XIRR (aktivní část)' : 'XIRR';
            const xirrDisplayValue = xirrValue !== null ? formatPercent(xirrValue) : '—';
            const xirrSubLines = [xirrDurationLabel];
            if (usingActiveXirr && portfolioXirrValue !== null) {
                xirrSubLines.push(`Celé portfolio: ${formatPercent(portfolioXirrValue)}`);
            }
            const xirrSubValue = xirrSubLines.length
                ? (
                      <Fragment>
                          {xirrSubLines.map((line, index) => (
                              <div key={index}>{line}</div>
                          ))}
                      </Fragment>
                  )
                : null;

            return (
                <section className="card-section">
                    <div className="card-header">
                        <div>
                            <span className="badge-pill">Souhrn scénáře</span>
                            <h2 className="card-header-title">Klíčové metriky</h2>
                            <p className="card-header-sub">Průběžný přehled aktuální hodnoty a zhodnocení portfolia.</p>
                        </div>
                    </div>
                    {hasData ? (
                        <Fragment>
                            <div className="info-grid">
                                <InfoCard title="Hodnota portfolia" value={totalValueLabel} subValue={`K datu ${dateLabel}`} />
                                <InfoCard title="Zhodnocení" value={gainPercentLabel} subValue={`Zisk/ztráta ${gainCurrencyLabel}`} />
                                <InfoCard title={xirrTitle} value={xirrDisplayValue} subValue={xirrSubValue} />
                            </div>
                            {sliderAvailable && (
                                <div className="timeline-slider">
                                    <div className="timeline-slider-header">
                                        <div className="timeline-slider-meta">
                                            <span className="timeline-slider-label">Rok horizontu</span>
                                            <span className="timeline-slider-value">{selectedPoint ? selectedPoint.year : '—'}</span>
                                        </div>
                                        <div className="timeline-slider-meta">
                                            <span className="timeline-slider-label">Datum</span>
                                            <span className="timeline-slider-value tabular-nums">{dateLabel}</span>
                                        </div>
                                        <div className="timeline-slider-meta">
                                            <span className="timeline-slider-label">Uplynulý čas</span>
                                            <span className="timeline-slider-value">{elapsedLabel}</span>
                                        </div>
                                        <div className="timeline-slider-meta">
                                            <span className="timeline-slider-label">Investováno k datu</span>
                                            <span className="timeline-slider-value tabular-nums">{investedLabel}</span>
                                        </div>
                                    </div>
                                    <input
                                        className="timeline-slider-track"
                                        type="range"
                                        min={0}
                                        max={sliderMax}
                                        step={1}
                                        value={activeIndex}
                                        onChange={(event) => setSelectedIndex(Number(event.target.value))}
                                        disabled={sliderDisabled}
                                        style={{ '--slider-progress': sliderProgress }}
                                    />
                                    <div className="timeline-slider-scale">
                                        <span>{startLabel}</span>
                                        <span>{endLabel}</span>
                                    </div>
                                    <div className="timeline-slider-invested">Posuňte pro zobrazení vývoje portfolia rok po roce.</div>
                                </div>
                            )}
                        </Fragment>
                    ) : (
                        <div className="note-block" style={{ marginTop: '1rem' }}>
                            Zadejte alespoň jeden počáteční vklad nebo dokup, aby bylo možné spočítat scénář.
                        </div>
                    )}
                </section>
            );
        };
        const ScenarioChart = ({ analysis }) => {
            const containerRef = useRef(null);
            const svgRef = useRef(null);
            const dimensions = useResizeObserver(containerRef);
            const [tooltip, setTooltip] = useState(null);

            if (!analysis?.hasData) {
                return (
                    <section className="card-section">
                        <div className="card-header">
                            <div>
                                <span className="badge-pill">Časová osa</span>
                                <h2 className="card-header-title">Vývoj scénáře</h2>
                                <p className="card-header-sub">Po zadání investic a událostí se zde zobrazí jediná křivka se všemi dopady.</p>
                            </div>
                        </div>
                        <div className="note-block">Zadejte fondy, dokupy nebo krize, aby bylo možné vykreslit scénář.</div>
                    </section>
                );
            }

            const { timeline, markers } = analysis;
            const height = 340;
            const margin = { top: 32, right: 24, bottom: 56, left: 80 };
            const fallbackWindowWidth = typeof window !== 'undefined' ? Math.min(window.innerWidth || 0, 960) : 0;
            const rawWidth =
                dimensions.width ||
                (containerRef.current ? containerRef.current.getBoundingClientRect().width : 0) ||
                (svgRef.current ? svgRef.current.getBoundingClientRect().width : 0) ||
                fallbackWindowWidth;
            const width = Math.max(rawWidth, margin.left + margin.right + 120);
            const plotWidth = Math.max(1, width - margin.left - margin.right);
            const plotHeight = Math.max(1, height - margin.top - margin.bottom);

            const startDate = timeline[0].date;
            const endDate = timeline[timeline.length - 1].date;
            const startTime = startDate.getTime();
            const endTime = endDate.getTime();
            const xRange = Math.max(1, endTime - startTime);
            const xScale = (date) => margin.left + ((date.getTime() - startTime) / xRange) * plotWidth;

            const values = timeline.map((point) => point.totalValue);
            const maxValue = Math.max(...values, analysis.totalInvested) * 1.1 || 1;
            const yScale = (value) => margin.top + plotHeight - (value / maxValue) * plotHeight;

            const pathPoints = timeline.map((point) => ({ x: xScale(point.date), y: yScale(point.totalValue) }));
            const markerPoints = markers.map((marker, index) => ({
                ...marker,
                key: `marker-${index}`,
                x: xScale(marker.date),
                y: yScale(marker.totalValue),
                kind:
                    marker.kind ||
                    (marker.crashes && marker.crashes.length > 0
                        ? marker.deposits && marker.deposits.length > 0
                            ? 'mixed'
                            : 'default'
                        : 'deposit'),
            }));

            const showMarkerTooltip = (marker) => {
                if (!marker) return;
                const hasCrash = marker.crashes && marker.crashes.length > 0;
                const hasDeposit = marker.deposits && marker.deposits.length > 0;
                const preValue = hasCrash
                    ? marker.valueBeforeCrashes ?? marker.valueAfterDeposits ?? marker.valueBeforeEvents ?? marker.totalValue
                    : marker.valueBeforeEvents ?? marker.totalValue;
                const postValue = hasCrash
                    ? marker.valueAfterCrashes ?? marker.totalValue
                    : marker.valueAfterDeposits ?? marker.totalValue;
                setTooltip({
                    type: 'marker',
                    kind: marker.kind,
                    x: marker.x,
                    y: marker.y,
                    date: marker.date,
                    value: marker.totalValue,
                    invested: marker.investedToDate,
                    deposits: marker.deposits || [],
                    crashes: marker.crashes || [],
                    valueBefore: preValue,
                    valueAfter: postValue,
                    depositTotal: hasDeposit ? marker.depositTotal || 0 : 0,
                    crashTotalLoss: hasCrash ? marker.crashTotalLoss || 0 : 0,
                });
            };

            const yTicks = Array.from({ length: 5 }, (_, index) => (maxValue / 4) * index);
            const xTicks = timeline.length <= 1
                ? [startDate]
                : timeline.filter((_, index) => index === 0 || index === timeline.length - 1 || index % Math.ceil(timeline.length / 4) === 0).map((point) => point.date);

            const handleMouseMove = (event) => {
                if (!svgRef.current) return;
                const rect = svgRef.current.getBoundingClientRect();
                const relativeX = event.clientX - rect.left;
                const pointerX = Math.min(Math.max(relativeX, margin.left), width - margin.right);

                let snappedMarker = null;
                let smallestDistance = Infinity;
                markerPoints.forEach((marker) => {
                    const distance = Math.abs(marker.x - pointerX);
                    if (distance < smallestDistance) {
                        smallestDistance = distance;
                        snappedMarker = marker;
                    }
                });
                const markerSnapThreshold = Math.max(4, Math.min(10, plotWidth * 0.02));
                if (snappedMarker && smallestDistance <= markerSnapThreshold) {
                    showMarkerTooltip(snappedMarker);
                    return;
                }

                const ratio = Math.min(Math.max((pointerX - margin.left) / plotWidth, 0), 1);
                const targetTime = Math.min(Math.max(startTime + ratio * xRange, startTime), endTime);
                let baseIndex = 0;
                for (let i = 0; i < timeline.length; i += 1) {
                    if (timeline[i].date.getTime() <= targetTime) {
                        baseIndex = i;
                    } else {
                        break;
                    }
                }
                const basePoint = timeline[baseIndex];
                const nextPoint = timeline[Math.min(baseIndex + 1, timeline.length - 1)];
                const targetDate = new Date(targetTime);

                let value = basePoint.totalValue;
                if (nextPoint && nextPoint !== basePoint && basePoint.snapshot) {
                    const spanMs = nextPoint.date.getTime() - basePoint.date.getTime();
                    if (spanMs > 0) {
                        const clampedTime = Math.min(Math.max(targetTime, basePoint.date.getTime()), nextPoint.date.getTime());
                        const years = diffInYears(basePoint.date, new Date(clampedTime));
                        value = basePoint.snapshot.reduce((sum, state) => {
                            if (!state) return sum;
                            const canGrow = state.status === 'active' && state.canGrow !== false;
                            if (canGrow) {
                                return sum + state.value * Math.pow(1 + state.rate, years);
                            }
                            return sum + state.value;
                        }, 0);
                    }
                } else if (nextPoint && nextPoint !== basePoint) {
                    const span = nextPoint.date.getTime() - basePoint.date.getTime();
                    const clampedTime = Math.min(Math.max(targetTime, basePoint.date.getTime()), nextPoint.date.getTime());
                    const interp = span > 0 ? (clampedTime - basePoint.date.getTime()) / span : 0;
                    value = basePoint.totalValue + (nextPoint.totalValue - basePoint.totalValue) * interp;
                }

                setTooltip({
                    type: 'line',
                    x: xScale(targetDate),
                    y: yScale(value),
                    date: targetDate,
                    value,
                    invested: basePoint.investedToDate,
                });
            };

            const handleMouseLeave = () => setTooltip(null);

            const handleMarkerEnter = (marker) => {
                showMarkerTooltip(marker);
            };

            const tooltipStyle = tooltip ? {
                left: `${Math.min(width - 220, Math.max(margin.left, tooltip.x + 16))}px`,
                top: `${Math.max(margin.top, tooltip.y + 16)}px`,
            } : {};

            return (
                <section className="card-section">
                    <div className="card-header">
                        <div>
                            <span className="badge-pill">Časová osa</span>
                            <h2 className="card-header-title">Vývoj portfolia v čase</h2>
                            <p className="card-header-sub">Zohledňuje všechny vklady, dokupy i propady v chronologickém pořadí s denním složeným úročením.</p>
                        </div>
                        <div className="meta-deck">
                            <div className="meta-card">
                                <span className="meta-label">Počet dokupů</span>
                                <span className="meta-value">{analysis.depositCount}</span>
                            </div>
                            <div className="meta-card">
                                <span className="meta-label">Propady</span>
                                <span className="meta-value">{analysis.crashSummary}</span>
                            </div>
                        </div>
                    </div>
                    <div className="chart-container" ref={containerRef}>
                        <svg ref={svgRef} width="100%" height={height} onMouseMove={handleMouseMove} onMouseLeave={handleMouseLeave}>
                            {yTicks.map((value) => (
                                <g key={`y-${value}`}>
                                    <line className="chart-grid-line" x1={margin.left} x2={width - margin.right} y1={yScale(value)} y2={yScale(value)} />
                                    <text className="chart-axis-text" x={margin.left - 10} y={yScale(value) + 4} textAnchor="end">{formatCurrency(value)}</text>
                                </g>
                            ))}
                            {xTicks.map((date) => (
                                <text key={`x-${date.getTime()}`} className="chart-axis-text" x={xScale(date)} y={height - margin.bottom + 24} textAnchor="middle">{formatMonthYear(date)}</text>
                            ))}
                            <path d={createPath(pathPoints)} className="chart-line-accent" />
                            {pathPoints.length > 0 && (
                                <circle className="chart-dot" r="5" cx={pathPoints[0].x} cy={pathPoints[0].y} />
                            )}
                            {markerPoints.map((marker) => (
                                <g key={marker.key} transform={`translate(${marker.x}, ${marker.y})`} onMouseEnter={() => handleMarkerEnter(marker)} onMouseLeave={handleMouseLeave} style={{ cursor: 'pointer' }}>
                                    {marker.kind === 'deposit' && (
                                        <>
                                            <circle r="9" fill="rgba(77, 177, 200, 0.2)" stroke="var(--accent)" strokeWidth="2" />
                                            <text textAnchor="middle" y="4" fontSize="11" fontWeight="600" fill="var(--primary-strong)">+</text>
                                        </>
                                    )}
                                    {marker.kind === 'default' && (
                                        <>
                                            <rect x="-9" y="-9" width="18" height="18" transform="rotate(45)" fill="var(--danger-bg)" stroke="var(--danger)" strokeWidth="2" />
                                            <text textAnchor="middle" y="4" fontSize="11" fontWeight="600" fill="var(--danger)">⚠︎</text>
                                        </>
                                    )}
                                    {marker.kind === 'mixed' && (
                                        <>
                                            <rect x="-9" y="-9" width="18" height="18" transform="rotate(45)" fill="var(--danger-bg)" stroke="var(--danger)" strokeWidth="2" />
                                            <circle r="9" fill="rgba(77, 177, 200, 0.22)" stroke="var(--accent)" strokeWidth="2" />
                                            <text textAnchor="middle" y="4" fontSize="11" fontWeight="600" fill="var(--danger)">⚠︎</text>
                                            <text textAnchor="middle" y="-8" fontSize="10" fontWeight="600" fill="var(--primary-strong)">+</text>
                                        </>
                                    )}
                                </g>
                            ))}
                            {tooltip && (
                                <>
                                    <line x1={tooltip.x} x2={tooltip.x} y1={margin.top} y2={height - margin.bottom} stroke="rgba(77, 177, 200, 0.4)" strokeDasharray="4 4" />
                                    <circle className="chart-dot" r="6" cx={tooltip.x} cy={tooltip.y} />
                                </>
                            )}
                        </svg>
                        {tooltip && (
                            <div className="tooltip show" style={tooltipStyle}>
                                <div className="meta-label" style={{ textTransform: 'none', fontWeight: 600 }}>{formatDate(tooltip.date)}</div>
                                <div className="meta-value" style={{ fontSize: '0.95rem' }}>{formatCurrency(tooltip.value)}</div>
                                {tooltip.type === 'line' && (
                                    <div className="info-card-sub" style={{ marginTop: '0.4rem' }}>Investováno k datu {formatCurrency(tooltip.invested ?? analysis.totalInvested)}</div>
                                )}
                                {tooltip.type === 'marker' && (
                                    <div className="info-card-sub" style={{ marginTop: '0.4rem' }}>
                                        Investováno k datu {formatCurrency(tooltip.invested ?? analysis.totalInvested)}
                                    </div>
                                )}
                                {tooltip.type === 'marker' && tooltip.valueBefore !== undefined && (
                                    <div className="info-card-sub" style={{ marginTop: '0.45rem' }}>
                                        Hodnota před událostí: {formatCurrency(tooltip.valueBefore)}
                                    </div>
                                )}
                                {tooltip.type === 'marker' && tooltip.valueAfter !== undefined && tooltip.valueAfter !== tooltip.valueBefore && (
                                    <div className="info-card-sub" style={{ marginTop: '0.45rem' }}>
                                        Hodnota po události: {formatCurrency(tooltip.valueAfter)}
                                    </div>
                                )}
                                {tooltip.type === 'marker' && tooltip.depositTotal > 0 && (
                                    <div className="info-card-sub" style={{ marginTop: '0.6rem', color: 'var(--accent)' }}>
                                        Součet dokupů: +{formatCurrency(tooltip.depositTotal)}
                                    </div>
                                )}
                                {tooltip.type === 'marker' && tooltip.crashTotalLoss > 0 && (
                                    <div className="info-card-sub" style={{ marginTop: '0.45rem', color: 'var(--danger)' }}>
                                        Ztráta v události: −{formatCurrency(tooltip.crashTotalLoss)}
                                    </div>
                                )}
                                {tooltip.type === 'marker' && tooltip.deposits && tooltip.deposits.length > 0 && (
                                    <div className="info-card-sub" style={{ marginTop: '0.6rem' }}>
                                        <strong>Dokupy</strong>
                                        <ul style={{ paddingLeft: '1rem', margin: '0.35rem 0 0', listStyle: 'disc' }}>
                                            {tooltip.deposits.map((deposit, index) => (
                                                <li key={`deposit-${index}`} style={{ marginBottom: '0.25rem' }}>
                                                    {deposit.fundName}: {formatCurrency(deposit.amount)}{deposit.label ? ` · ${deposit.label}` : ''}
                                                </li>
                                            ))}
                                        </ul>
                                    </div>
                                )}
                                {tooltip.type === 'marker' && tooltip.crashes && tooltip.crashes.length > 0 && (
                                    <div className="info-card-sub" style={{ marginTop: tooltip.deposits && tooltip.deposits.length > 0 ? '0.75rem' : '0.6rem', color: 'var(--danger)' }}>
                                        <strong style={{ color: 'var(--danger)' }}>Propady</strong>
                                        <ul style={{ paddingLeft: '1rem', margin: '0.35rem 0 0', listStyle: 'disc' }}>
                                            {tooltip.crashes.map((crash, index) => (
                                                <li key={`crash-${index}`} style={{ marginBottom: '0.25rem' }}>
                                                    {crash.fundName}: −{formatCurrency(crash.loss || 0)}{typeof crash.haircut === 'number' ? ` · Propad ${formatPercent(crash.haircut)}` : ''}
                                                </li>
                                            ))}
                                        </ul>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                    <div className="chart-marker-hints" role="note">
                        <span className="chart-marker-hints-label">Legenda událostí</span>
                        <div className="chart-marker-hints-items">
                            <span className="chart-marker-hint">
                                <span className="chart-marker-icon chart-marker-icon--deposit"><span>+</span></span>
                                <span>Počáteční vklad / dokup</span>
                            </span>
                            <span className="chart-marker-hint">
                                <span className="chart-marker-icon chart-marker-icon--default"><span>⚠︎</span></span>
                                <span>Propad portfolia</span>
                            </span>
                            <span className="chart-marker-hint">
                                <span className="chart-marker-icon chart-marker-icon--mixed">
                                    <span className="chart-marker-icon-symbol">⚠︎</span>
                                    <span className="chart-marker-icon-plus">+</span>
                                </span>
                                <span>Současně dokup i propad</span>
                            </span>
                        </div>
                    </div>
                </section>
            );
        };
        const AllocationPie = ({ analysis }) => {
            const stages = Array.isArray(analysis?.allocationStages) ? analysis.allocationStages : [];
            const availableStages = useMemo(
                () => stages.filter((stage) => stage && stage.available),
                [stages],
            );
            const fallbackKey = availableStages.length > 0 ? availableStages[availableStages.length - 1].key : null;
            const [view, setView] = useState(fallbackKey);
            const containerRef = useRef(null);
            const [tooltip, setTooltip] = useState(null);
            const projection = useMemo(() => createProjectionEngine(analysis), [analysis]);
            const { originDate: projectionOrigin, finalDate: projectionFinal, projectTo: projectionProjectTo } = projection;
            const yearlyRows = useMemo(() => {
                if (!analysis?.hasData) {
                    return [];
                }
                const rawTimeline = Array.isArray(analysis.timeline) ? analysis.timeline : [];
                const timeline = rawTimeline
                    .filter((point) => point && point.date instanceof Date)
                    .sort((a, b) => a.date - b.date);
                if (timeline.length === 0) {
                    return [];
                }

                const scenarioStart = projectionOrigin instanceof Date ? projectionOrigin : timeline[0].date;
                const scenarioEnd = projectionFinal instanceof Date ? projectionFinal : timeline[timeline.length - 1].date;
                if (!(scenarioStart instanceof Date) || !(scenarioEnd instanceof Date) || typeof projectionProjectTo !== 'function') {
                    return [];
                }

                const crashYears = new Set();
                const crashDetailsByYear = new Map();
                if (Array.isArray(analysis.markers)) {
                    analysis.markers.forEach((marker) => {
                        if (!marker || !(marker.date instanceof Date)) {
                            return;
                        }
                        const hasCrash = Array.isArray(marker.crashes)
                            ? marker.crashes.some((crash) => {
                                  if (!crash) return false;
                                  const loss = Number(crash.loss);
                                  const haircut = Number(crash.haircut);
                                  return (Number.isFinite(loss) && loss > 0) || (Number.isFinite(haircut) && haircut > 0);
                              })
                            : false;
                        if (hasCrash) {
                            const crashYear = marker.date.getFullYear();
                            crashYears.add(crashYear);
                            const bucket = crashDetailsByYear.get(crashYear) || {
                                entries: [],
                                totalLoss: 0,
                            };
                            (Array.isArray(marker.crashes) ? marker.crashes : [])
                                .filter(Boolean)
                                .forEach((crash) => {
                                    const loss = Number(crash.loss);
                                    const haircut = Number(crash.haircut);
                                    const entry = {
                                        fundName: crash.fundName || 'Fond',
                                        loss: Number.isFinite(loss) ? loss : 0,
                                        haircut: Number.isFinite(haircut) ? haircut : null,
                                        date: marker.date,
                                    };
                                    bucket.entries.push(entry);
                                    bucket.totalLoss += entry.loss;
                                });
                            bucket.count = bucket.entries.length;
                            crashDetailsByYear.set(crashYear, bucket);
                        }
                    });
                }

                const firstYear = scenarioStart.getFullYear();
                const finalYear = Math.max(scenarioEnd.getFullYear(), firstYear + Y - 1);
                const rows = [];
                for (let year = firstYear; year <= finalYear; year += 1) {
                    const yearStart = year === firstYear ? scenarioStart : new Date(year, 0, 1);
                    if (yearStart.getTime() > scenarioEnd.getTime()) {
                        break;
                    }
                    const nextYearStart = new Date(year + 1, 0, 1);
                    const yearEnd =
                        year === finalYear || nextYearStart.getTime() > scenarioEnd.getTime()
                            ? scenarioEnd
                            : nextYearStart;
                    if (yearEnd.getTime() <= yearStart.getTime()) {
                        continue;
                    }
                    const startProjection = projectionProjectTo(
                        yearStart,
                        { elapsedHint: diffInYears(scenarioStart, yearStart) },
                    );
                    const endProjection = projectionProjectTo(
                        yearEnd,
                        { elapsedHint: diffInYears(scenarioStart, yearEnd) },
                    );
                    if (!startProjection || !endProjection) {
                        continue;
                    }
                    const startValue = Number.isFinite(startProjection.totalValue) ? startProjection.totalValue : 0;
                    const endValue = Number.isFinite(endProjection.totalValue) ? endProjection.totalValue : 0;
                    const gain = endValue - startValue;
                    let gainStatus = 'neutral';
                    if (gain > 1) {
                        gainStatus = 'positive';
                    } else if (gain < -1) {
                        gainStatus = 'negative';
                    }
                    rows.push({
                        year,
                        startValue,
                        endValue,
                        gain,
                        hadCrash: crashYears.has(year),
                        crashDetails: crashDetailsByYear.get(year) || null,
                        gainStatus,
                    });
                }
                return rows;
            }, [analysis, projectionOrigin, projectionFinal, projectionProjectTo]);

            useEffect(() => {
                if (!availableStages.length) {
                    if (view !== null) {
                        setView(null);
                    }
                    return;
                }
                if (!view || !availableStages.some((stage) => stage.key === view)) {
                    setView(availableStages[availableStages.length - 1].key);
                }
            }, [availableStages, view]);

            useEffect(() => {
                setTooltip(null);
            }, [view, availableStages.length]);

            if (!analysis?.hasData || availableStages.length === 0) {
                return null;
            }

            const activeStage = availableStages.find((stage) => stage.key === view) || availableStages[availableStages.length - 1];
            const data = Array.isArray(activeStage?.allocations) ? activeStage.allocations : [];
            const total = Number(activeStage?.totalValue) || 0;
            const stageDateLabel = activeStage?.date ? formatDate(activeStage.date) : '—';
            const CHART_COLORS = ['#0d2c54', '#4DB1C8', '#6E7DA2', '#A4C4BC', '#F2D7B6', '#8FA6BF', '#C8D8E4', '#E0A899'];
            const outerRadius = 46;
            const innerRadius = 28;
            const degToRad = (value) => (value * Math.PI) / 180;

            let angle = -90;
            const segments = data.map((item, index) => {
                const share = total > 0 ? item.value / total : 0;
                const startAngle = angle;
                const endAngle = angle + share * 360;
                const largeArc = share > 0.5 ? 1 : 0;
                const outerStartX = 50 + outerRadius * Math.cos(degToRad(startAngle));
                const outerStartY = 50 + outerRadius * Math.sin(degToRad(startAngle));
                const outerEndX = 50 + outerRadius * Math.cos(degToRad(endAngle));
                const outerEndY = 50 + outerRadius * Math.sin(degToRad(endAngle));
                const innerEndX = 50 + innerRadius * Math.cos(degToRad(endAngle));
                const innerEndY = 50 + innerRadius * Math.sin(degToRad(endAngle));
                const innerStartX = 50 + innerRadius * Math.cos(degToRad(startAngle));
                const innerStartY = 50 + innerRadius * Math.sin(degToRad(startAngle));
                angle = endAngle;
                return {
                    ...item,
                    share,
                    color: CHART_COLORS[index % CHART_COLORS.length],
                    path: [
                        `M ${outerStartX},${outerStartY}`,
                        `A ${outerRadius},${outerRadius} 0 ${largeArc},1 ${outerEndX},${outerEndY}`,
                        `L ${innerEndX},${innerEndY}`,
                        `A ${innerRadius},${innerRadius} 0 ${largeArc},0 ${innerStartX},${innerStartY}`,
                        'Z',
                    ].join(' '),
                };
            });

            const handleSegmentMove = (event, segment) => {
                if (!containerRef.current) return;
                const rect = containerRef.current.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                setTooltip({
                    name: segment.name,
                    value: segment.value,
                    share: segment.share,
                    x,
                    y,
                    width: rect.width,
                    height: rect.height,
                });
            };

            const handleSegmentLeave = () => setTooltip(null);

            const tooltipStyle = tooltip
                ? {
                      left: Math.min(Math.max(tooltip.x + 16, 0), Math.max((tooltip.width || 0) - 180, 0)),
                      top: Math.min(Math.max(tooltip.y + 16, 0), Math.max((tooltip.height || 0) - 120, 0)),
                  }
                : {};

            const hasAllocations = total > 0 && segments.length > 0;

            return (
                <Fragment>
                    <section className="card-section">
                        <div className="card-header">
                            <div>
                                <span className="badge-pill">Alokace</span>
                                <h2 className="card-header-title">Rozložení portfolia</h2>
                                <p className="card-header-sub">
                                Aktuální pohled: {activeStage?.label || '—'} · {stageDateLabel}
                            </p>
                        </div>
                        <div className="pie-stage-controls">
                            {availableStages.map((stage) => (
                                <button
                                    key={stage.key}
                                    className={`btn btn-secondary ${stage.key === activeStage?.key ? 'active' : ''}`}
                                    onClick={() => setView(stage.key)}
                                    type="button"
                                >
                                    {stage.buttonLabel}
                                </button>
                            ))}
                        </div>
                    </div>
                    <div className="responsive-grid-two">
                        <div className="pie-chart-wrapper" ref={containerRef}>
                            <svg viewBox="0 0 100 100" style={{ width: '100%', height: '100%' }}>
                                <circle
                                    cx="50"
                                    cy="50"
                                    r="43"
                                    fill="rgba(77, 177, 200, 0.12)"
                                    stroke="rgba(77, 177, 200, 0.28)"
                                    strokeWidth="1.6"
                                />
                                {hasAllocations &&
                                    segments.map((segment) => (
                                        <path
                                            key={segment.id}
                                            d={segment.path}
                                            fill={segment.color}
                                            stroke="rgba(13, 44, 84, 0.18)"
                                            strokeWidth="0.8"
                                            className="pie-segment"
                                            onMouseMove={(event) => handleSegmentMove(event, segment)}
                                            onMouseLeave={handleSegmentLeave}
                                        />
                                    ))}
                                <circle cx="50" cy="50" r="23" fill="#ffffff" stroke="#EAECEE" strokeWidth="1.4" />
                            </svg>
                            {tooltip && (
                                <div className="tooltip show" style={tooltipStyle}>
                                    <div className="meta-value" style={{ fontWeight: 600 }}>{tooltip.name}</div>
                                    <div className="info-card-sub" style={{ marginTop: '0.35rem', color: 'var(--text)' }}>
                                        {formatCurrency(tooltip.value)} · {formatPercent(tooltip.share)}
                                    </div>
                                </div>
                            )}
                            {!hasAllocations && (
                                <div className="info-card-sub" style={{ textAlign: 'center', marginTop: '1rem' }}>
                                    Žádné aktivní fondy pro zvolený okamžik.
                                </div>
                            )}
                            <div className="pie-total">
                                <span className="pie-total-label">Celkem</span>
                                <span className="pie-total-value tabular-nums">{formatCurrency(total)}</span>
                            </div>
                        </div>
                        <div className="pie-legend">
                            {segments.map((segment) => (
                                <div className="pie-legend-item" key={segment.id}>
                                    <div className="pie-legend-name">
                                        <span className="pie-legend-dot" style={{ background: segment.color }}></span>
                                        {segment.name}
                                    </div>
                                    <div className="pie-legend-value tabular-nums">
                                        {formatPercent(segment.share)}
                                    </div>
                                </div>
                            ))}
                            </div>
                        </div>
                    </section>
                    {yearlyRows.length > 0 && (
                        <section className="card-section">
                            <div className="card-header">
                                <div>
                                    <span className="badge-pill">Roční vývoj</span>
                                    <h2 className="card-header-title">Roční vývoj portfolia</h2>
                                    <p className="card-header-sub">Přehled zůstatků na začátku a na konci každého roku.</p>
                                </div>
                            </div>
                            <div className="summary-table-container">
                                <table className="summary-table">
                                    <thead>
                                        <tr>
                                            <th scope="col">Rok</th>
                                            <th scope="col" className="text-right">Začátek roku</th>
                                            <th scope="col" className="text-right">Konec roku</th>
                                            <th scope="col" className="text-right">Výnos v roce</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {yearlyRows.map((row) => {
                                            const crashTooltip = row.crashDetails
                                                ? row.crashDetails.entries
                                                      .map((entry) => {
                                                          const parts = [];
                                                          if (entry.date instanceof Date) {
                                                              parts.push(formatDate(entry.date));
                                                          }
                                                          parts.push(entry.fundName);
                                                          if (entry.loss > 0) {
                                                              parts.push(`−${formatCurrency(entry.loss)}`);
                                                          }
                                                          if (typeof entry.haircut === 'number' && entry.haircut > 0) {
                                                              parts.push(`Propad ${formatPercent(entry.haircut)}`);
                                                          }
                                                          return parts.join(' · ');
                                                      })
                                                      .join('\n')
                                                : null;
                                            const rowClassNames = ['summary-table-row'];
                                            if (row.hadCrash) rowClassNames.push('has-crash');
                                            if (row.gainStatus) rowClassNames.push(`is-${row.gainStatus}`);
                                            return (
                                                <tr key={row.year} className={rowClassNames.join(' ')}>
                                                    <td>{row.year}</td>
                                                    <td className="tabular-nums text-right">{formatCurrency(row.startValue)}</td>
                                                    <td className="tabular-nums text-right">{formatCurrency(row.endValue)}</td>
                                                    <td className="tabular-nums text-right">
                                                        <div className="gain-cell">
                                                            <span className={`gain-value ${row.gainStatus ? `is-${row.gainStatus}` : ''}`}>
                                                                <span className="gain-value-icon">
                                                                    {row.gainStatus === 'positive'
                                                                        ? '▲'
                                                                        : row.gainStatus === 'negative'
                                                                        ? '▼'
                                                                        : '•'}
                                                                </span>
                                                                {formatCurrency(row.gain)}
                                                            </span>
                                                            {row.hadCrash && (
                                                                <span
                                                                    className="crash-indicator"
                                                                    data-tooltip={crashTooltip || 'Propad portfolia'}
                                                                    tabIndex={0}
                                                                >
                                                                    Propad
                                                                </span>
                                                            )}
                                                        </div>
                                                    </td>
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                            </div>
                        </section>
                    )}
                </Fragment>
            );
        };

        const Notes = () => (
            <section className="card-section">
                <div className="card-header">
                    <div>
                        <span className="badge-pill">Poznámky</span>
                        <h2 className="card-header-title">Vysvětlivky a doporučení</h2>
                    </div>
                </div>
                <div className="note-block">
                    <strong>Pořadí událostí:</strong> Vždy se nejprve dopočítá růst mezi uzly, poté se aplikují dokupy a nakonec případné propady. Události ve stejný den respektují pořadí: dokup → propad.
                </div>
                <div className="note-block" style={{ marginTop: '1rem' }}>
                    <strong>XIRR:</strong> Výkonnost vychází z peněžních toků všech vkladů a aktuální hodnoty na konci scénáře. Propad se projeví až zůstatkem, nikoli okamžitým cash-flow.
                </div>
                <div className="note-block alert" style={{ marginTop: '1rem' }}>
                    <strong>Upozornění:</strong> Scénář je ilustrativní a nezohledňuje poplatky, daně ani kurzové riziko. Výpočty předpokládají konstantní roční zhodnocení mezi událostmi.
                </div>
            </section>
        );

        function App() {
            const { push: pushToast } = useToasts();
            const { clientName, setClientName, funds, setFunds, lastSaved } = useScenarioState(pushToast);

            const analysis = useMemo(() => {
                const prepared = prepareScenarioInput(funds);
                return analyzeScenario(prepared.funds, prepared.topUps, prepared.crashes);
            }, [funds]);

            const totalInitial = useMemo(() => funds.reduce((sum, fund) => sum + parseMoney(fund.amountStr), 0), [funds]);

            const addFund = useCallback((segment) => {
                setFunds((prev) => {
                    const scenarioStart = deriveScenarioStartDate(prev);
                    const startDateStr = toInputDate(scenarioStart);
                    return [...prev, createFund('Nový fond', 5, segment, startDateStr)];
                });
            }, [setFunds]);

            const updateFund = useCallback((id, patch) => {
                setFunds((prev) => prev.map((fund) => (fund.id === id ? { ...fund, ...patch } : fund)));
            }, [setFunds]);

            const removeFund = useCallback((id) => {
                setFunds((prev) => prev.filter((fund) => fund.id !== id));
            }, [setFunds]);

            const resetSegment = useCallback((segment) => {
                setFunds((prev) =>
                    prev.map((fund) =>
                        fund.segment === segment
                            ? { ...fund, amountStr: '0', topUpStr: '0', crashYear: '0', crashMode: 'haircut', haircutStr: '50' }
                            : fund,
                    ),
                );
            }, [setFunds]);

            const demoSegment = useCallback((segment) => {
                const config = SEGMENT_CONFIG.find((item) => item.key === segment);
                if (!config) return;
                setFunds((prev) =>
                    prev.map((fund) => {
                        if (fund.segment !== segment) return fund;
                        if (config.demo.includes(fund.name)) {
                            return { ...fund, amountStr: '250000', topUpStr: '0', crashYear: '0', crashMode: 'haircut', haircutStr: '50' };
                        }
                        return { ...fund, amountStr: '0', topUpStr: '0', crashYear: '0', crashMode: 'haircut', haircutStr: '50' };
                    }),
                );
                pushToast('Segment byl naplněn ukázkovými hodnotami.');
            }, [pushToast, setFunds]);

            const exportState = useCallback(() => {
                try {
                    const prepared = prepareScenarioInput(funds);
                    const exportPayload = {
                        clientName,
                        generatedAt: new Date().toISOString(),
                        funds,
                        scenarioInputs: prepared,
                        scenario: analysis?.hasData ? analysis.exportSnapshot : null,
                    };
                    const blob = new Blob([JSON.stringify(exportPayload, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const element = document.createElement('a');
                    const sanitizedName = clientName.trim().replace(/\s+/g, '-').replace(/[^\w-]/g, '').toLowerCase();
                    element.href = url;
                    element.download = `${sanitizedName || 'scenario'}-${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(element);
                    element.click();
                    document.body.removeChild(element);
                    URL.revokeObjectURL(url);
                    pushToast('Scénář byl exportován.');
                } catch (error) {
                    console.error(error);
                    pushToast('Chyba při exportu souboru.', 'error');
                }
            }, [analysis, clientName, funds, pushToast]);

            const importState = useCallback((event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (loadEvent) => {
                    try {
                        const parsed = JSON.parse(loadEvent.target.result);
                        if (Array.isArray(parsed.funds) && parsed.funds.length > 0) {
                            setFunds(ensureDefaultFunds(parsed.funds));
                        } else {
                            setFunds(getDefaultFunds());
                        }
                        setClientName(typeof parsed.clientName === 'string' ? parsed.clientName : '');
                        pushToast('Scénář byl importován.');
                    } catch (error) {
                        console.error(error);
                        pushToast('Chyba při importu souboru.', 'error');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }, [pushToast, setClientName, setFunds]);

            const resetAll = useCallback(() => {
                setFunds(getDefaultFunds());
                setClientName('');
                pushToast('Scénář byl resetován.');
            }, [pushToast, setClientName, setFunds]);

            return (
                <Fragment>
                    <ReportHero lastSaved={lastSaved} clientName={clientName} onClientNameChange={setClientName} analysis={analysis} />
                    <main>
                        <div className="app-shell content-stack">
                            <DataManagement onExport={exportState} onImport={importState} onReset={resetAll} analysis={analysis} />
                            {SEGMENT_CONFIG.map((segment) => (
                                <SegmentTable
                                    key={segment.key}
                                    segment={segment}
                                    funds={funds.filter((fund) => fund.segment === segment.key)}
                                    onAddFund={() => addFund(segment.key)}
                                    onUpdateFund={updateFund}
                                    onRemoveFund={removeFund}
                                    onResetSegment={() => resetSegment(segment.key)}
                                    onDemoSegment={() => demoSegment(segment.key)}
                                    portfolioTotal={totalInitial}
                                />
                            ))}
                            <ScenarioSummary analysis={analysis} />
                            <ScenarioChart analysis={analysis} />
                            <AllocationPie analysis={analysis} />
                            <Notes />
                        </div>
                    </main>
                    <footer>© {new Date().getFullYear()} FairLife · Scénář slouží pro interní účely a ilustrativní prezentace.</footer>
                </Fragment>
            );
        }

        const rootElement = document.getElementById('root');
        if (!rootElement) {
            throw new Error('Chybí kořenový prvek pro React aplikaci.');
        }

        try {
            ReactDOM.createRoot(rootElement).render(
                <React.StrictMode>
                    <ToastProvider>
                        <App />
                    </ToastProvider>
                </React.StrictMode>,
            );
        } catch (error) {
            console.error('Nepodařilo se inicializovat aplikaci.', error);
            rootElement.innerHTML = '<div class="app-error">Nepodařilo se načíst kalkulačku. Zkuste obnovit stránku nebo kontaktujte podporu.</div>';
        }
    </script>
</body>
</html>