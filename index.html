<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Report investičního portfolia</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    :root {
        color-scheme: light;
        --surface: #ffffff;
        --surface-muted: #f1f5f9;
        --border: rgba(15, 118, 110, 0.12);
        --border-strong: rgba(15, 118, 110, 0.24);
        --accent: #14b8a6;
        --accent-strong: #0f766e;
        --accent-soft: rgba(20, 184, 166, 0.16);
    }

    html,body{
        font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, Arial, 'Helvetica Neue', sans-serif;
        scroll-behavior: smooth;
        min-height: 100%;
        background: linear-gradient(180deg, #ecfeff 0%, #f8fafc 55%, #f1f5f9 100%);
    }
    .tabular{ font-variant-numeric: tabular-nums; }
    button:disabled{ opacity: .5; cursor: not-allowed; }
    .editable[contenteditable="true"]:empty:before{
        content: attr(data-ph);
        color: #9ca3af;
        pointer-events: none;
        display: block; /* For placeholder to work */
    }
    .editable{ outline: none; }
    /* Prevent number input arrows */
    input[type=number]::-webkit-inner-spin-button, 
    input[type=number]::-webkit-outer-spin-button { 
      -webkit-appearance: none; 
      margin: 0; 
    }
    input[type=number] { -moz-appearance: textfield; }

    /* Animations */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    .fade-in { animation: fadeIn 0.3s ease-out forwards; }
    
    @keyframes fadeOut {
        from { opacity: 1; transform: scale(0.95); }
        to { opacity: 0; transform: scale(1); }
    }
    .fade-out { animation: fadeOut 0.3s ease-in forwards; }

    /* Details/Summary animation */
    details > summary { list-style: none; }
    details > summary::-webkit-details-marker { display: none; }
    details > summary .summary-arrow { transition: transform 0.2s; }
    details[open] > summary .summary-arrow { transform: rotate(90deg); }

    /* Toast Notifications */
    #toast-container {
        position: fixed;
        top: 1.5rem;
        right: 1.5rem;
        z-index: 50;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }
    .toast {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        padding: 0.875rem 1.2rem;
        border-radius: 0.875rem;
        box-shadow: 0 20px 45px -20px rgba(15, 23, 42, 0.35);
        border: 1px solid var(--border);
        background-color: #ffffff;
        color: #0f172a;
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.4s cubic-bezier(0.21, 1.02, 0.73, 1);
    }
    .toast.show {
        opacity: 1;
        transform: translateX(0);
    }
    .toast-success { background-color: rgba(20, 184, 166, 0.12); border-color: rgba(20, 184, 166, 0.3); color: #047857; }
    .toast-error { background-color: rgba(248, 113, 113, 0.14); border-color: rgba(239, 68, 68, 0.35); color: #b91c1c; }

    /* Interactive Chart Styles */
    #chart-tooltip {
        transition: opacity 0.2s;
        pointer-events: none;
    }
    .pie-segment {
        cursor: pointer;
        transition: transform 0.2s cubic-bezier(0.21, 1.02, 0.73, 1);
        transform-origin: center center;
    }
    .pie-segment:hover { transform: scale(1.04); }
    .line-chart-grid-line { stroke: #e5e7eb; stroke-dasharray: 2 3; }
    .line-chart-axis-text { font-size: 11px; fill: #6b7280; }
    .line-chart-dot { cursor: pointer; transition: r 0.2s; }
    .line-chart-dot:hover { r: 6; }

    /* Smart Input Highlighting */
    .input-highlight {
        border-color: #60a5fa !important; /* blue-400 */
        box-shadow: 0 0 0 1px #60a5fa;
    }
    .card {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 1.25rem;
        box-shadow: 0 15px 40px -25px rgba(15, 23, 42, 0.5);
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        color: #0f172a;
    }

    .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 20px 45px -25px rgba(15, 23, 42, 0.5);
        border-color: var(--border-strong);
    }

    .section-title {
        letter-spacing: -0.015em;
    }

    .pill {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.45rem 0.9rem;
        border-radius: 999px;
        font-size: 0.8rem;
        background: var(--accent-soft);
        color: var(--accent-strong);
        border: 1px solid rgba(20, 184, 166, 0.3);
    }

    .glass-input {
        background: rgba(255, 255, 255, 0.92);
        border-color: rgba(148, 163, 184, 0.35);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .glass-input:focus {
        border-color: var(--accent);
        box-shadow: 0 0 0 4px rgba(45, 212, 191, 0.18);
    }

    .primary-btn {
        background: linear-gradient(135deg, #2dd4bf 0%, #0f766e 100%);
        color: #f8fafc;
        border: none;
        box-shadow: 0 18px 35px -20px rgba(15, 118, 110, 0.6);
    }

    .secondary-btn {
        background: rgba(45, 212, 191, 0.12);
        color: #0f172a;
        border: 1px solid rgba(45, 212, 191, 0.25);
    }

    .secondary-btn:hover {
        border-color: rgba(45, 212, 191, 0.35);
        background: rgba(45, 212, 191, 0.18);
    }

    .primary-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 22px 45px -20px rgba(15, 118, 110, 0.55);
    }

    .danger-btn {
        background: rgba(248, 113, 113, 0.12);
        color: #b91c1c;
        border: 1px solid rgba(248, 113, 113, 0.3);
        transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }

    .danger-btn:hover {
        background: rgba(248, 113, 113, 0.22);
        border-color: rgba(239, 68, 68, 0.45);
        color: #991b1b;
    }

    .tag-muted {
        color: #94a3b8;
    }

    .gradient-divider {
        height: 1px;
        background: linear-gradient(90deg, rgba(45, 212, 191, 0), rgba(45, 212, 191, 0.45), rgba(45, 212, 191, 0));
    }

  </style>
</head>
<body class="antialiased text-slate-800">
  <header class="bg-gradient-to-b from-teal-50 via-white to-white border-b border-teal-100/60">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
      <div class="flex flex-col lg:flex-row lg:items-center justify-between gap-12">
        <div class="flex items-start gap-6">
          <div class="p-4 rounded-3xl bg-white border border-teal-100 shadow-md shadow-teal-100/70">
            <svg class="h-14 w-14 text-teal-500" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M9 23.25C9 15.6487 15.1487 9.5 22.75 9.5C30.3513 9.5 36.5 15.6487 36.5 23.25C36.5 30.8513 30.3513 37 22.75 37H12.5C10.8431 37 9.5 35.6569 9.5 34V23.25Z" stroke="currentColor" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M16 24.5L21.125 29L31 19" stroke="currentColor" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <div class="space-y-5">
            <span class="pill">Report investičního portfolia</span>
            <h1 class="text-3xl md:text-4xl font-semibold tracking-tight text-slate-900 section-title">Přehled vašeho finančního světa</h1>
            <p class="text-slate-600 max-w-2xl text-base leading-relaxed">Sledujte výkonnost fondů, analyzujte cashflow a prezentujte výsledky klientům v jednom elegantním a interaktivním rozhraní.</p>
            <div class="flex flex-wrap gap-3 text-xs sm:text-sm text-slate-500">
              <span>© <span id="current-year"></span> Ondřej Lacina.</span>
              <span>Toto dílo je chráněno autorským právem dle zákona č. 121/2000 Sb.</span>
              <span>Šíření mimo strukturu Fair-life je zakázáno.</span>
            </div>
          </div>
        </div>
        <div class="grid gap-4 w-full sm:grid-cols-2 lg:w-[360px]">
          <div class="rounded-2xl border border-teal-100 bg-white p-5 shadow-sm shadow-teal-100/60">
            <div class="flex items-center gap-3">
              <span class="inline-flex h-10 w-10 items-center justify-center rounded-2xl bg-teal-50 text-teal-500 shadow-inner">
                <svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M4.75 5.75h14.5M4.75 12h6.5m-6.5 6.25h10.5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M15.5 16.75l2.25 2.25L20 16.75m-4.5-9.5l2.25-2.25L20 7.25" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </span>
              <div>
                <p class="text-sm font-semibold text-teal-700">Interaktivní řízení</p>
                <p class="text-sm text-slate-600">Import, export a validace dat v reálném čase.</p>
              </div>
            </div>
          </div>
          <div class="rounded-2xl border border-teal-100 bg-white p-5 shadow-sm shadow-teal-100/60">
            <div class="flex items-center gap-3">
              <span class="inline-flex h-10 w-10 items-center justify-center rounded-2xl bg-teal-50 text-teal-500 shadow-inner">
                <svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M4.75 18.25l4-4 3 3 7.5-7.5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M4.75 6.75h14.5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </span>
              <div>
                <p class="text-sm font-semibold text-teal-700">Pokročilé analýzy</p>
                <p class="text-sm text-slate-600">XIRR, projekce výnosů a vizualizace portfolia.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>

  <!-- Tooltip for charts -->
  <div id="chart-tooltip" class="absolute hidden z-20 px-3 py-2 text-sm font-medium text-slate-700 bg-white border border-teal-100 rounded-xl shadow-lg"></div>

  <!-- Toast container for notifications -->
  <div id="toast-container"></div>

  <main class="relative px-4 sm:px-6 lg:px-8 py-12">
    <div class="max-w-7xl mx-auto space-y-12">

      <!-- === SELF-TESTS & STATUS NOTIFICATIONS === -->
      <div id="status-container" class="space-y-4"></div>

      <!-- === FX & OUTPUT CONTROLS === -->
      <div class="grid gap-6 xl:grid-cols-3">
        <section class="card p-6 sm:p-7 xl:col-span-2">
          <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-6">
            <div class="space-y-2">
              <h2 class="text-xl font-semibold text-slate-900">Nastavení měny</h2>
              <p class="text-sm text-slate-500">Zadejte kurz EUR/CZK a zvolte výstupní měnu reportu.</p>
            </div>
            <div class="flex items-center gap-4 flex-wrap">
              <label class="flex flex-col sm:flex-row sm:items-center gap-2 text-sm text-slate-600">
                <span class="font-medium text-slate-700 whitespace-nowrap">Kurz (CZK za 1 EUR)</span>
                <input id="fx-rate" type="number" step="0.0001" placeholder="např. 25.30" class="glass-input px-3 py-2 rounded-xl border w-[170px] tabular text-right text-slate-900 placeholder:text-slate-400" />
              </label>
              <div class="hidden sm:block w-px h-9 bg-slate-200/70"></div>
              <label class="flex flex-col sm:flex-row sm:items-center gap-2 text-sm text-slate-600">
                <span class="font-medium text-slate-700">Výstup v měně</span>
                <select id="out-curr" class="glass-input px-3 py-2 rounded-xl border bg-white text-slate-900">
                  <option value="CZK" selected>CZK</option>
                  <option value="EUR">EUR</option>
                </select>
              </label>
            </div>
          </div>
        </section>

        <!-- === DATA MANAGEMENT === -->
        <section class="card p-6 sm:p-7">
          <div class="flex flex-col gap-5">
            <div class="space-y-2">
              <h3 class="text-xl font-semibold text-slate-900">Správa dat</h3>
              <p class="text-sm text-slate-500">Synchronizujte portfolio jedním kliknutím.</p>
            </div>
            <div class="flex flex-col md:flex-row md:items-center gap-3 md:gap-4 text-sm flex-wrap">
              <label class="flex items-center gap-2 text-sm text-slate-600">
                <span class="font-medium text-slate-700 whitespace-nowrap">Jméno klienta</span>
                <input id="client-name" type="text" placeholder="např. Jana Nováková" class="glass-input px-3 py-2 rounded-xl border text-slate-900 placeholder:text-slate-400 w-[220px]" />
              </label>
              <div class="flex items-center gap-2 flex-wrap">
                <button data-action="export-json" type="button" class="secondary-btn px-4 py-2 rounded-xl text-sm font-medium">Exportovat do .json</button>
                <button data-action="import-json" type="button" class="secondary-btn px-4 py-2 rounded-xl text-sm font-medium">Importovat z .json</button>
              </div>
              <button data-action="export-presentation" type="button" class="primary-btn px-4 py-2 rounded-xl text-sm font-medium flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M11 3a1 1 0 10-2 0v6.586L7.707 8.293a1 1 0 10-1.414 1.414l3.293 3.293a1 1 0 001.414 0l3.293-3.293a1 1 0 10-1.414-1.414L11 9.586V3z" /><path d="M3 13a2 2 0 012-2h2a1 1 0 010 2H5v2h10v-2h-2a1 1 0 110-2h2a2 2 0 012 2v3a2 2 0 01-2 2H5a2 2 0 01-2-2v-3z" /></svg>
                <span>Export prezentace pro klienta</span>
              </button>
              <input type="file" id="import-file-input" class="hidden" accept=".json">
              <div id="last-saved-indicator" class="ml-auto text-xs text-slate-500/80"></div>
            </div>
          </div>
        </section>
      </div>

      <div class="gradient-divider"></div>

      <!-- === INPUT SECTIONS (PROVIDERS) === -->
      <section class="space-y-6">
        <div class="space-y-3">
          <span class="pill">Vstupní data</span>
          <div class="space-y-2">
            <h2 class="text-2xl font-semibold tracking-tight text-slate-900">Správa poskytovatelů a transakcí</h2>
            <p class="text-sm text-slate-600 max-w-3xl">Importujte nebo přepisujte data jednotlivých platforem, kontrolujte jejich konzistenci a sledujte výsledky okamžitě po zadání.</p>
          </div>
        </div>
        <div id="provider-sections" class="flex flex-col gap-6"></div>
      </section>

      <div class="gradient-divider"></div>
      
      <!-- === RESULTS BY FUND (REDESIGNED) === -->
      <section class="card p-7 sm:p-8">
        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div>
            <h2 class="text-2xl font-semibold text-slate-900">Výsledky po fondech</h2>
            <p class="text-sm text-slate-500">Detailní rozpad portfolia včetně XIRR pro jednotlivé fondy.</p>
          </div>
          <div id="amount-note-funds" class="text-xs font-medium uppercase tracking-[0.2em] text-slate-400">Částky v CZK</div>
        </div>
        <div id="funds-by-card-container" class="space-y-4">
        </div>
      </section>

      <!-- === PORTFOLIO SUMMARY === -->
      <section class="card p-7 sm:p-8">
        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div>
            <h2 class="text-2xl font-semibold text-slate-900">Souhrn portfolia</h2>
            <p class="text-sm text-slate-500">Celkový výkon, vývoj hodnoty a časově vážené výnosy.</p>
          </div>
          <div id="amount-note-portfolio" class="text-xs font-medium uppercase tracking-[0.2em] text-slate-400">Částky v CZK</div>
        </div>
        <div id="portfolio-summary-content" class="text-sm">
        </div>
      </section>

      <!-- === CHARTS & VISUALIZATIONS === -->
      <section id="charts-section" class="space-y-8">
        <div id="line-chart-card" class="card p-7 sm:p-8" style="display: none;">
          <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
            <h2 id="line-chart-title" class="text-2xl font-semibold text-slate-900">Vývoj hodnoty portfolia s predikcí do roku 2035</h2>
            <p class="text-sm text-slate-500 max-w-md">Simulace navazuje na aktuální XIRR a ukazuje odhad dalšího růstu při zachování tempa.</p>
          </div>
          <div id="line-chart-container" class="relative mt-6"></div>
        </div>
        <div id="pie-chart-card" class="card p-7 sm:p-8" style="display: none;">
          <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
            <h2 class="text-2xl font-semibold text-slate-900">Alokace portfolia v čase</h2>
            <p class="text-sm text-slate-500 max-w-md">Prozkoumejte rozložení kapitálu v jednotlivých fondech k libovolnému datu.</p>
          </div>
          <div id="pie-chart-container" class="max-w-xl w-full mx-auto mt-6"></div>
           <div class="mt-6">
               <input type="range" id="pie-time-slider" class="w-full accent-teal-500">
               <div class="flex justify-between text-xs text-slate-500 mt-2">
                   <span id="slider-start-date-label"></span>
                   <span id="slider-current-date-label" class="font-semibold text-teal-600"></span>
                   <span id="slider-end-date-label"></span>
               </div>
          </div>
        </div>
      </section>

      <!-- === ANNUITY CALCULATOR === -->
      <section id="annuity-calculator-section" class="card p-7 sm:p-8">
        <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <div>
            <h2 class="text-2xl font-semibold text-slate-900">Kalkulačka nekonečné renty</h2>
            <p class="text-sm text-slate-500">Zjistěte, jak velký kapitál je potřeba pro pasivní příjem z portfolia.</p>
          </div>
        </div>
        <div class="mt-5 flex items-center gap-4 flex-wrap">
            <label class="flex flex-col sm:flex-row sm:items-center gap-2">
                <span class="text-sm font-medium text-slate-700 whitespace-nowrap">Požadovaná měsíční renta</span>
                <input id="annuity-input" type="text" placeholder="např. 10 000" class="glass-input px-3 py-2 rounded-xl border w-[200px] tabular text-right text-slate-900 placeholder:text-slate-400" />
            </label>
            <div id="annuity-annual-equivalent" class="text-sm text-slate-500"></div>
        </div>
        <div id="annuity-result" class="mt-5 text-sm text-slate-900 bg-teal-50 border border-teal-100 rounded-xl p-5" style="display: none;"></div>
        <p id="annuity-disclaimer" class="mt-3 text-xs text-slate-500/90 italic" style="display: none;">
          *Tento výpočet předpokládá, že si z portfolia každý rok vyberete pouze vygenerovaný výnos (zhodnocení) a jistina zůstane nedotčena, aby mohla generovat další výnos v následujícím roce.
        </p>
      </section>

      <!-- === EXPLANATIONS === -->
      <section id="explanations-section" class="card p-7 sm:p-8">
        <details class="group">
          <summary class="text-lg font-semibold cursor-pointer flex items-center justify-between text-slate-900">
            <span>Vysvětlivky a použité metriky</span>
            <svg class="summary-arrow w-5 h-5 transition-transform group-open:rotate-90 text-slate-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clip-rule="evenodd" />
            </svg>
          </summary>
          <div class="mt-4 pt-4 border-t border-slate-200 text-sm text-slate-600 space-y-5">
            <div>
              <h4 class="font-semibold text-slate-900">Co je to XIRR a jak funguje?</h4>
               <p class="mt-2 leading-relaxed">
                XIRR (z anglického <em>eXtended Internal Rate of Return</em>) je nejpřesnější metoda pro výpočet <strong>průměrného ročního zhodnocení</strong> vaší investice.
              </p>
              <p class="mt-2 leading-relaxed">
                <strong>Proč je lepší než jednoduché procento?</strong> Protože bere v potaz čas. Koruna, kterou jste investoval před třemi lety, měla mnohem více času pracovat než koruna, kterou jste vložil minulý měsíc. XIRR toto spravedlivě zohledňuje, a proto je tento ukazatel klíčový pro správné vyhodnocení investic s více vklady (nebo výběry) v čase.
              </p>
              <p class="mt-2 leading-relaxed">
                <strong>Je to dopočet na 12 měsíců, i když data mám jen za kratší dobu?</strong> Ano. Pokud známe zhodnocení například za 8 měsíců, XIRR dopočítá, jakému <strong>průměrnému ročnímu zhodnocení</strong> by to odpovídalo, kdyby investice pokračovala stejným tempem.
              </p>
            </div>
             <div class="pt-4 border-t border-slate-200">
              <h4 class="font-semibold text-slate-900">Co je kumulativní zhodnocení?</h4>
               <p class="mt-2 leading-relaxed">
                Tento údaj ukazuje celkový čistý zisk nebo ztrátu jako procento z celkově zainvestované částky. Je to přímočarý indikátor celkové výkonnosti.
              </p>
              <p class="mt-2 leading-relaxed">
                <strong>Příklad:</strong> Pokud jste do portfolia celkem vložil 100&nbsp;000&nbsp;Kč a jeho aktuální hodnota je 120&nbsp;000&nbsp;Kč, kumulativní zhodnocení činí +20&nbsp;%. Na rozdíl od XIRR ale nezohledňuje čas, po který byly jednotlivé vklady investovány.
              </p>
            </div>
          </div>
        </details>
      </section>

    </div>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {

  const state = {
      rows: { avant: [], codya: [], atris: [], jt: [] },
      meta: { clientName: '' },
      lastProcessedData: { funds: [], hasMixedCurrencies: false, portfolioSummary: {} },
      fundColorMap: {}
  };
  const elements = {};
  const STORAGE_KEY = 'fairlife-investment-calculator-state-v2';
  const LEGACY_STORAGE_KEY = 'investmentCalculatorState';
  const SAVE_DEBOUNCE = 220;
  const MS_PER_DAY = 86400000;
  const CHART_END_YEAR = 2035;
  let saveTimer = null;
  let rowSeq = 0;
  let rafId = 0;

  const PROVIDERS = { avant: 'AVANT', codya: 'CODYA', atris: 'ATRIS', jt: 'J&T' };
  const CHART_COLORS = [
      '#0f766e', '#14b8a6', '#0ea5e9', '#6366f1', '#f97316', '#fb7185', '#facc15',
      '#34d399', '#22d3ee', '#a855f7', '#4ade80', '#7c3aed', '#ef4444', '#f59e0b'
  ];
  const getColor = (fundName) => {
      if (!state.fundColorMap[fundName]) {
          const colorIndex = Object.keys(state.fundColorMap).length % CHART_COLORS.length;
          state.fundColorMap[fundName] = CHART_COLORS[colorIndex];
      }
      return state.fundColorMap[fundName];
  };
  
  const utils = {
    nf: (d = 2, opts = {}) => new Intl.NumberFormat('cs-CZ', { minimumFractionDigits: d, maximumFractionDigits: d, ...opts }),
    toDate: (s) => { if (!s) return null; const t = String(s).trim(); if (/^\d{4}-\d{2}-\d{2}$/.test(t)) { const d = new Date(t); return isNaN(d.getTime()) ? null : d; } const m = t.match(/^([0-3]?\d)\.?\s*([01]?\d)\.?\s*(\d{4})$/); if (m) { const d = new Date(`${m[3]}-${m[2]}-${m[1]}`); return isNaN(d.getTime()) ? null : d; } const genericDate = new Date(t); return isNaN(genericDate.getTime()) ? null : genericDate; },
    monthsDiff: (d1, d2) => { if (!(d1 instanceof Date && d2 instanceof Date && !isNaN(d1) && !isNaN(d2))) return NaN; const days = (d2.getTime() - d1.getTime()) / MS_PER_DAY; return Math.max(0, days / (365.2425 / 12)); },
    numCZ: (v) => { if (v === null || v === undefined) return NaN; let t = String(v).replace(/ /g, ' ').trim(); if (t === '') return NaN; t = t.replace(/\s*(Kč|CZK|€|EUR)\s*/gi, ''); t = t.replace(/[−–—]/g, '-'); let isNegative = false; if (t.startsWith('(') && t.endsWith(')')) { isNegative = true; t = t.substring(1, t.length - 1); } t = t.replace(/\s/g, ''); const lastComma = t.lastIndexOf(','); const lastDot = t.lastIndexOf('.'); if (lastComma > lastDot) { t = t.replace(/\./g, '').replace(',', '.'); } else if (lastDot > -1 && t.length - lastDot - 1 > 2) { t = t.replace(/,/g, ''); } else { t = t.replace(/,/g, ''); } const num = parseFloat(t); if (isNaN(num)) return NaN; return isNegative ? -Math.abs(num) : num; },
    normName: s => String(s || '').replace(/[ \s]+/g, ' ').trim(),
    convertAmount: (amt, from, to, fxRate) => { if (!isFinite(amt)) return NaN; if (from === to) return amt; const k = fxRate; if (!isFinite(k) || k <= 0) return NaN; if (from === 'EUR' && to === 'CZK') return amt * k; if (from === 'CZK' && to === 'EUR') return amt / k; return NaN; }
  };

  const cloneDeep = (value) => {
      if (typeof structuredClone === 'function') {
          try {
              return structuredClone(value);
          } catch (error) {
              console.warn('structuredClone fallback used', error);
          }
      }
      return JSON.parse(JSON.stringify(value));
  };

  const fmt2 = utils.nf(2); const fmt4 = utils.nf(4); const fmt1 = utils.nf(1); const fmt0 = utils.nf(0);
  const cellNum = (v, d = 2) => { if(!isFinite(v)) return '—'; if(d === 4) return fmt4.format(v); if(d === 1) return fmt1.format(v); if(d === 0) return fmt0.format(v); return fmt2.format(v); };
  const cellPct = v => isFinite(v) ? fmt2.format(v * 100) + ' %' : '—';
  
  const finance = (() => {
    function xnpv(rate, cfs) { if (!isFinite(rate)) return NaN; const sortedCfs = cfs.slice().sort((a, b) => a.date - b.date); const t0 = sortedCfs[0]?.date; if (!t0) return NaN; return sortedCfs.reduce((sum, cf) => { const days = (cf.date - t0) / MS_PER_DAY; return sum + cf.amount / Math.pow(1 + rate, days / 365.25); }, 0); }
    function xirr(cfs, iterations = 100) { if (!Array.isArray(cfs) || cfs.length < 2) return NaN; let hasPos = false, hasNeg = false; for (const cf of cfs) { if (cf.amount > 0) hasPos = true; if (cf.amount < 0) hasNeg = true; } if (!hasPos || !hasNeg) return NaN; let low = -0.9999, high = 10.0; let mid; for (let i = 0; i < iterations; i++) { mid = (low + high) / 2; const npv = xnpv(mid, cfs); if (Math.abs(npv) < 1e-6) break; if (npv > 0) { low = mid; } else { high = mid; } } return isFinite(mid) ? mid : NaN; }
    return { xnpv, xirr };
  })();
  
  const scheduleRecalc = () => { cancelAnimationFrame(rafId); rafId = requestAnimationFrame(recalculateAndRender); };
  const showToast = (message, type = 'success') => {
      const container = elements.toastContainer || document.getElementById('toast-container');
      if (!container) return;
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.innerHTML = `<svg class="w-6 h-6 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">${type === 'success' ? `<path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />` : `<path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" />`}</svg><span>${message}</span>`;
      container.appendChild(toast);
      requestAnimationFrame(() => {
          toast.classList.add('show');
      });
      setTimeout(() => {
          toast.classList.remove('show');
          toast.addEventListener('transitionend', () => toast.remove());
      }, 3000);
  };

  const commitStateToStorage = () => {
      try {
          localStorage.removeItem(LEGACY_STORAGE_KEY);
          localStorage.setItem(STORAGE_KEY, JSON.stringify({ rows: state.rows, meta: state.meta }));
          if (elements.lastSavedIndicator) {
              elements.lastSavedIndicator.textContent = `Uloženo v ${new Date().toLocaleTimeString('cs-CZ')}`;
          }
      } catch (error) {
          console.error('Failed to save state:', error);
          showToast('Chyba při ukládání dat.', 'error');
      }
  };

  const saveState = (immediate = false) => {
      if (immediate) {
          if (saveTimer) {
              clearTimeout(saveTimer);
              saveTimer = null;
          }
          commitStateToStorage();
          return;
      }
      if (saveTimer) {
          clearTimeout(saveTimer);
      }
      saveTimer = setTimeout(() => {
          commitStateToStorage();
          saveTimer = null;
      }, SAVE_DEBOUNCE);
  };
  const loadState = () => {
      let restored = false;
      try {
          let savedStateJSON = localStorage.getItem(STORAGE_KEY);
          let migrated = false;
          if (!savedStateJSON) {
              savedStateJSON = localStorage.getItem(LEGACY_STORAGE_KEY);
              migrated = Boolean(savedStateJSON);
          }
          if (savedStateJSON) {
              const savedState = JSON.parse(savedStateJSON);
              if (savedState && typeof savedState.rows === 'object') {
                  Object.keys(PROVIDERS).forEach(key => { state.rows[key] = savedState.rows[key] || []; });
                  const allIds = Object.values(state.rows).flat().map(r => r.id);
                  rowSeq = allIds.length > 0 ? Math.max(...allIds) : 0;
                  restored = true;
              }
              if (savedState && typeof savedState.meta === 'object') {
                  const savedName = typeof savedState.meta.clientName === 'string' ? savedState.meta.clientName.trim() : '';
                  state.meta = { ...state.meta, ...savedState.meta, clientName: savedName };
                  if (elements.clientNameInput) {
                      elements.clientNameInput.value = state.meta.clientName || '';
                  }
                  restored = true;
              }
              if (migrated) {
                  localStorage.removeItem(LEGACY_STORAGE_KEY);
                  saveState(true);
              }
          }
      } catch (error) {
          console.error('Failed to load state:', error);
          showToast('Nepodařilo se načíst uložená data.', 'error');
      }
      if (restored) {
          showToast('Data byla úspěšně načtena z prohlížeče.');
      }
      renderAllInputs();
      scheduleRecalc();
  };
  const exportState = () => {
      const payload = { rows: cloneDeep(state.rows), meta: { ...state.meta } };
      const stateString = JSON.stringify(payload, null, 2);
      const blob = new Blob([stateString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `portfolio-export-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast("Data byla úspěšně exportována.");
  };
  const importState = (file) => {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
          try {
              const importedState = JSON.parse(e.target.result);
              if (importedState && typeof importedState.rows === 'object') {
                  Object.keys(PROVIDERS).forEach(key => { state.rows[key] = importedState.rows[key] || []; });
                  const allIds = Object.values(state.rows).flat().map(r => r.id);
                  rowSeq = allIds.length > 0 ? Math.max(...allIds) : 0;
                  if (importedState.meta && typeof importedState.meta === 'object') {
                      const importedName = typeof importedState.meta.clientName === 'string' ? importedState.meta.clientName.trim() : '';
                      state.meta = { ...state.meta, ...importedState.meta, clientName: importedName };
                      if (elements.clientNameInput) {
                          elements.clientNameInput.value = state.meta.clientName || '';
                      }
                  }
                  saveState(true);
                  renderAllInputs();
                  scheduleRecalc();
                  showToast("Data byla úspěšně importována.");
              } else {
                  throw new Error("Invalid file structure.");
              }
          } catch (err) {
              console.error("Failed to import state:", err);
              showToast("Chyba při importu: neplatný formát souboru.", 'error');
          }
      };
      reader.readAsText(file);
  };
  const exportClientPresentation = () => {
      if (document.activeElement && typeof document.activeElement.blur === 'function') {
          document.activeElement.blur();
      }
      cancelAnimationFrame(rafId);
      const { funds, portfolioSummary, hasMixedCurrencies, outCurr, fxRate } = performFullRecalc();
      if (!funds.length || !portfolioSummary?.hasData) {
          showToast('Pro export je potřeba mít vyplněné a přepočítané portfolio.', 'error');
          return;
      }
      if (hasMixedCurrencies && !isFinite(fxRate)) {
          showToast('Doplňte směnný kurz EUR/CZK, aby bylo možné vytvořit prezentaci.', 'error');
          return;
      }
      const clientNameInput = elements.clientNameInput || document.getElementById('client-name');
      if (clientNameInput) {
          state.meta.clientName = clientNameInput.value || '';
      }
      const clientName = (state.meta.clientName || '').trim();
      state.meta.clientName = clientName;
      saveState(true);
      const rowsSnapshot = cloneDeep(state.rows);
      const exportPayload = {
          generatedAt: new Date().toISOString(),
          outCurr,
          fxRate: isFinite(fxRate) ? fxRate : null,
          hasMixedCurrencies,
          clientName,
          funds: funds.map(f => ({
              fund: f.fund,
              invest: f.invest,
              current: f.current,
              curr: f.curr,
              qty: f.qty,
              issueNav: f.issueNav,
              currNav: f.currNav,
              investConverted: utils.convertAmount(f.invest, f.curr, outCurr, fxRate),
              currentConverted: utils.convertAmount(f.current, f.curr, outCurr, fxRate),
              pnlConverted: utils.convertAmount(f.pnl, f.curr, outCurr, fxRate),
              pnl: f.pnl,
              ret: f.ret,
              irr: f.irr,
              months: f.months,
              dateIn: f.dateIn ? f.dateIn.toISOString() : null,
              originalDateIn: f.originalDateIn ? f.originalDateIn.toISOString() : null,
              currDate: f.currDate ? f.currDate.toISOString() : null
          })),
          summary: {
              totalInvestConverted: portfolioSummary.totalInvestConverted,
              totalCurrentConverted: portfolioSummary.totalCurrentConverted,
              totalPnl: portfolioSummary.totalPnl,
              totalRet: portfolioSummary.totalRet,
              portfolioIrr: portfolioSummary.portfolioIrr,
              weightedAvgMonths: portfolioSummary.weightedAvgMonths,
              minValuationDate: portfolioSummary.minValuationDate ? portfolioSummary.minValuationDate.toISOString() : null,
              maxValuationDate: portfolioSummary.maxValuationDate ? portfolioSummary.maxValuationDate.toISOString() : null,
              hasData: portfolioSummary.hasData
          },
          rows: rowsSnapshot,
          meta: { clientName }
      };

      const htmlContent = buildClientPresentationHTML(exportPayload);
      const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `fairlife-prezentace-${new Date().toISOString().split('T')[0]}.html`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast('Prezentace byla připravena ke stažení.');
  };

  const buildClientPresentationHTML = (payload) => {
      const outCurr = payload?.outCurr || 'CZK';
      const fxRate = Number.isFinite(payload?.fxRate) ? Number(payload.fxRate) : NaN;
      const summary = payload?.summary && typeof payload.summary === 'object' ? payload.summary : {};
      const fundsRaw = Array.isArray(payload?.funds) ? payload.funds : [];
      const clientName = typeof payload?.clientName === 'string' && payload.clientName.trim() ? payload.clientName.trim() : (payload?.meta && typeof payload.meta.clientName === 'string' ? payload.meta.clientName.trim() : '');
      const generatedAt = payload?.generatedAt ? new Date(payload.generatedAt) : null;

      const nf = (d) => new Intl.NumberFormat('cs-CZ', { minimumFractionDigits: d, maximumFractionDigits: d });
      const fmt0 = nf(0);
      const fmt1 = nf(1);
      const fmt2 = nf(2);
      const fmt4 = nf(4);
      const cellNum = (value, digits = 2) => {
        if (!Number.isFinite(value)) return '—';
        if (digits === 0) return fmt0.format(value);
        if (digits === 1) return fmt1.format(value);
        if (digits === 4) return fmt4.format(value);
        return fmt2.format(value);
      };
      const cellPct = (value) => Number.isFinite(value) ? fmt2.format(value * 100) + ' %' : '—';
      const escapeHtml = (value) => String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
      const toDate = (value) => {
        if (!value) return null;
        if (value instanceof Date && !Number.isNaN(value.valueOf())) return value;
        const parsed = new Date(value);
        return Number.isNaN(parsed.valueOf()) ? null : parsed;
      };
      const formatDate = (value) => {
        const d = toDate(value);
        return d ? d.toLocaleDateString('cs-CZ') : 'N/A';
      };
      const convertAmount = (amount, from, to, rate) => {
        if (!Number.isFinite(amount)) return NaN;
        if (!from) return NaN;
        if (from === to) return amount;
        if (!Number.isFinite(rate) || rate <= 0) return NaN;
        if (from === 'EUR' && to === 'CZK') return amount * rate;
        if (from === 'CZK' && to === 'EUR') return amount / rate;
        return NaN;
      };
      const convert = (amount, from) => convertAmount(amount, from, outCurr, fxRate);

      const normalisedFunds = [];
      fundsRaw.forEach((item) => {
        const rawName = typeof item?.fund === 'string' ? item.fund.trim() : '';
        if (!rawName) return;
        const curr = item?.curr || 'CZK';
        const invest = Number.isFinite(item?.invest) ? Number(item.invest) : NaN;
        const current = Number.isFinite(item?.current) ? Number(item.current) : NaN;
        const investConverted = Number.isFinite(item?.investConverted) ? Number(item.investConverted) : convert(invest, curr);
        const currentConverted = Number.isFinite(item?.currentConverted) ? Number(item.currentConverted) : convert(current, curr);
        const pnlConverted = Number.isFinite(item?.pnlConverted)
          ? Number(item.pnlConverted)
          : (Number.isFinite(investConverted) && Number.isFinite(currentConverted) ? currentConverted - investConverted : NaN);
        normalisedFunds.push({
          name: rawName,
          curr,
          invest,
          current,
          investConverted,
          currentConverted,
          pnlConverted,
          pnl: Number.isFinite(item?.pnl) ? Number(item.pnl) : NaN,
          ret: Number.isFinite(item?.ret) ? Number(item.ret) : NaN,
          irr: Number.isFinite(item?.irr) ? Number(item.irr) : NaN,
          months: Number.isFinite(item?.months) ? Number(item.months) : NaN,
          qty: Number.isFinite(item?.qty) ? Number(item.qty) : NaN,
          issueNav: Number.isFinite(item?.issueNav) ? Number(item.issueNav) : NaN,
          currNav: Number.isFinite(item?.currNav) ? Number(item.currNav) : NaN,
          dateIn: toDate(item?.dateIn),
          originalDateIn: toDate(item?.originalDateIn),
          currDate: toDate(item?.currDate)
        });
      });

      const COLOR_PALETTE = CHART_COLORS.slice();
      const colorMap = new Map();
      const colorFor = (name) => {
        if (!colorMap.has(name)) {
          const idx = colorMap.size % COLOR_PALETTE.length;
          colorMap.set(name, COLOR_PALETTE[idx]);
        }
        return colorMap.get(name);
      };

      const chartFunds = normalisedFunds.map((item) => ({
        fund: item.name,
        curr: item.curr,
        invest: Number.isFinite(item.invest) ? item.invest : null,
        current: Number.isFinite(item.current) ? item.current : null,
        investConverted: Number.isFinite(item.investConverted) ? item.investConverted : null,
        currentConverted: Number.isFinite(item.currentConverted) ? item.currentConverted : null,
        pnlConverted: Number.isFinite(item.pnlConverted) ? item.pnlConverted : null,
        pnl: Number.isFinite(item.pnl) ? item.pnl : null,
        ret: Number.isFinite(item.ret) ? item.ret : null,
        irr: Number.isFinite(item.irr) ? item.irr : null,
        months: Number.isFinite(item.months) ? item.months : null,
        qty: Number.isFinite(item.qty) ? item.qty : null,
        issueNav: Number.isFinite(item.issueNav) ? item.issueNav : null,
        currNav: Number.isFinite(item.currNav) ? item.currNav : null,
        dateIn: item.dateIn instanceof Date && !Number.isNaN(item.dateIn.valueOf()) ? item.dateIn.toISOString() : (item.dateIn ? String(item.dateIn) : null),
        originalDateIn: item.originalDateIn instanceof Date && !Number.isNaN(item.originalDateIn.valueOf()) ? item.originalDateIn.toISOString() : (item.originalDateIn ? String(item.originalDateIn) : null),
        currDate: item.currDate instanceof Date && !Number.isNaN(item.currDate.valueOf()) ? item.currDate.toISOString() : (item.currDate ? String(item.currDate) : null)
      }));

      const generateLineChartMarkup = (items, summaryData, currency) => {
        const deposits = (items || []).map((entry) => {
          const date = entry?.dateIn ? new Date(entry.dateIn) : null;
          const rawAmount = Number.isFinite(entry?.investConverted)
            ? entry.investConverted
            : (Number.isFinite(entry?.invest) ? convert(entry.invest, entry.curr || 'CZK') : NaN);
          if (!(date instanceof Date) || Number.isNaN(date.valueOf()) || !Number.isFinite(rawAmount)) {
            return null;
          }
          return { date, amount: rawAmount, fund: entry?.fund || '' };
        }).filter(Boolean).sort((a, b) => a.date - b.date);

        if (!deposits.length) return '';

        const portfolioIrr = Number.isFinite(summaryData?.portfolioIrr) ? summaryData.portfolioIrr : 0;
        const dailyRate = Math.pow(1 + portfolioIrr, 1 / 365.25) - 1;
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const firstDate = deposits[0].date;
        const futureEndDate = new Date(`${CHART_END_YEAR}-12-31T00:00:00.000Z`);
        const totalTimeSpan = futureEndDate - firstDate;
        if (!Number.isFinite(totalTimeSpan) || totalTimeSpan <= 0) return '';

        const width = 860;
        const height = 360;
        const margin = { top: 24, right: 24, bottom: 56, left: 70 };
        const boundedWidth = width - margin.left - margin.right;
        const boundedHeight = height - margin.top - margin.bottom;

        const allPoints = [];
        let runningValue = 0;
        let lastDate = firstDate;
        let cumulativeContributions = 0;
        allPoints.push({ date: firstDate, value: 0, contributions: 0 });

        deposits.forEach((deposit) => {
          const daysSinceLast = (deposit.date - lastDate) / MS_PER_DAY;
          if (daysSinceLast > 0) {
            runningValue *= Math.pow(1 + dailyRate, daysSinceLast);
            allPoints.push({ date: deposit.date, value: runningValue, contributions: cumulativeContributions });
          }
          runningValue += deposit.amount;
          cumulativeContributions += deposit.amount;
          allPoints.push({ date: deposit.date, value: runningValue, contributions: cumulativeContributions });
          lastDate = deposit.date;
        });

        const valueAtToday = runningValue * Math.pow(1 + dailyRate, (today - lastDate) / MS_PER_DAY);
        allPoints.push({ date: today, value: valueAtToday, contributions: cumulativeContributions });

        const projectionPoints = [{ date: today, value: valueAtToday }];
        for (let year = today.getFullYear() + 1; year <= CHART_END_YEAR; year++) {
          const date = new Date(year + '-12-31T00:00:00.000Z');
          const projectedValue = valueAtToday * Math.pow(1 + dailyRate, (date - today) / MS_PER_DAY);
          projectionPoints.push({ date, value: projectedValue });
        }

        const maxValue = Math.max(...allPoints.map((p) => p.value), ...projectionPoints.map((p) => p.value));
        const yMax = Math.ceil((maxValue || 100000) / 100000) * 100000;
        const xScale = (date) => margin.left + ((date - firstDate) / totalTimeSpan) * boundedWidth;
        const yScale = (value) => margin.top + boundedHeight - (value / yMax) * boundedHeight;

        const yTicks = 5;
        const parts = [];
        for (let i = 0; i <= yTicks; i++) {
          const value = (yMax / yTicks) * i;
          const y = yScale(value);
          parts.push(`<line x1="${margin.left}" y1="${y}" x2="${width - margin.right}" y2="${y}" stroke="rgba(148,163,184,0.25)" stroke-dasharray="2 3"></line>`);
          parts.push(`<text x="${margin.left - 10}" y="${y + 4}" fill="rgba(148,163,184,0.75)" font-size="11" text-anchor="end">${cellNum(value / 1000000, 1)} M</text>`);
        }
        for (let year = firstDate.getFullYear(); year <= CHART_END_YEAR; year += 2) {
          const date = new Date(year + '-01-01T00:00:00.000Z');
          const x = xScale(date);
          parts.push(`<text x="${x}" y="${height - 22}" fill="rgba(148,163,184,0.75)" font-size="11" text-anchor="middle">${year}</text>`);
        }

        const historicalPoints = allPoints.filter((p) => p.date <= today);
        const contributionPath = 'M' + historicalPoints.map((p) => `${xScale(p.date)},${yScale(p.contributions)}`).join(' L');
        const valuePath = 'M' + historicalPoints.map((p) => `${xScale(p.date)},${yScale(p.value)}`).join(' L');
        const projectionPath = 'M' + projectionPoints.map((p) => `${xScale(p.date)},${yScale(p.value)}`).join(' L');
        parts.push(`<path d="${contributionPath}" fill="none" stroke="rgba(148,163,184,0.35)" stroke-width="2"></path>`);
        parts.push(`<path d="${valuePath}" fill="none" stroke="#34d399" stroke-width="2.5"></path>`);
        parts.push(`<path d="${projectionPath}" fill="none" stroke="#34d399" stroke-width="2.5" stroke-dasharray="5 5"></path>`);

        const xToday = xScale(today);
        const yToday = yScale(valueAtToday);
        parts.push(`<line x1="${xToday}" y1="${margin.top}" x2="${xToday}" y2="${height - margin.bottom}" stroke="#38bdf8" stroke-width="1.5" stroke-dasharray="4 4"></line>`);
        parts.push(`<circle cx="${xToday}" cy="${yToday}" r="5" fill="#38bdf8" stroke="#ffffff" stroke-width="2"></circle>`);

        return `<svg width="100%" height="360" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">${parts.join('')}</svg>`;
      };

      const generatePieChartMarkup = (items, currency) => {
        const slices = (items || []).reduce((acc, entry) => {
          const name = entry?.fund || '';
          if (!name) return acc;
          const value = Number.isFinite(entry?.currentConverted)
            ? entry.currentConverted
            : (Number.isFinite(entry?.current) ? convert(entry.current, entry.curr || 'CZK') : NaN);
          if (!Number.isFinite(value) || value <= 0) return acc;
          acc.push({ name, value });
          return acc;
        }, []);

        if (!slices.length) return '';

        const total = slices.reduce((sum, slice) => sum + slice.value, 0);
        let angle = -90;
        const outerR = 46;
        const innerR = 24;
        const segments = slices.map((slice) => {
          const percent = slice.value / total;
          const start = (angle * Math.PI) / 180;
          angle += percent * 360;
          const end = (angle * Math.PI) / 180;
          const x1 = 50 + outerR * Math.cos(start);
          const y1 = 50 + outerR * Math.sin(start);
          const x2 = 50 + outerR * Math.cos(end);
          const y2 = 50 + outerR * Math.sin(end);
          const x3 = 50 + innerR * Math.cos(end);
          const y3 = 50 + innerR * Math.sin(end);
          const x4 = 50 + innerR * Math.cos(start);
          const y4 = 50 + innerR * Math.sin(start);
          const largeArc = percent > 0.5 ? 1 : 0;
          const color = colorFor(slice.name);
          return `<g class="pie-segment" data-name="${escapeHtml(slice.name)}" data-value="${cellNum(slice.value, 0)} ${currency}" data-percent="${cellPct(slice.value / total)}"><path d="M ${x1},${y1} A ${outerR},${outerR} 0 ${largeArc},1 ${x2},${y2} L ${x3},${y3} A ${innerR},${innerR} 0 ${largeArc},0 ${x4},${y4} Z" fill="${color}" stroke="#0f172a" stroke-width="1.5"></path></g>`;
        }).join('');

        const legend = slices.map((slice) => `<div style="display:flex;align-items:center;gap:10px;"><span style="width:12px;height:12px;border-radius:999px;background:${colorFor(slice.name)};"></span><span style="flex:1;">${escapeHtml(slice.name)}</span><span style="font-weight:600;">${cellPct(slice.value / total)}</span></div>`).join('');

        return `<div class="chart-fallback"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">${segments}</svg><div class="chart-legend">${legend}</div></div>`;
      };

      const fundGroups = [];
      const groupMap = new Map();
      normalisedFunds.forEach((fund) => {
        if (!groupMap.has(fund.name)) {
          const bucket = [];
          groupMap.set(fund.name, bucket);
          fundGroups.push({ name: fund.name, items: bucket });
        }
        groupMap.get(fund.name).push(fund);
      });

      const buildFundCard = (group) => {
        const items = group.items.slice().sort((a, b) => {
          const aTime = a.dateIn ? a.dateIn.getTime() : 0;
          const bTime = b.dateIn ? b.dateIn.getTime() : 0;
          return aTime - bTime;
        });
        let totalInvest = 0;
        let totalCurrent = 0;
        let weightedDuration = 0;
        let latestDate = null;
        const cashflows = [];
        items.forEach((item) => {
          if (Number.isFinite(item.investConverted)) {
            totalInvest += item.investConverted;
            const cfDate = item.dateIn || item.originalDateIn;
            if (cfDate) cashflows.push({ date: cfDate, amount: -item.investConverted });
            if (Number.isFinite(item.months)) {
              weightedDuration += item.investConverted * item.months;
            }
          }
          if (Number.isFinite(item.currentConverted)) {
            totalCurrent += item.currentConverted;
          }
          if (item.currDate && (!latestDate || item.currDate > latestDate)) {
            latestDate = item.currDate;
          }
        });
        if (Number.isFinite(totalCurrent) && latestDate) {
          cashflows.push({ date: latestDate, amount: totalCurrent });
        }
        const pnl = totalCurrent - totalInvest;
        const irr = finance.xirr(cashflows);
        const weightedAvg = totalInvest > 0 ? weightedDuration / totalInvest : NaN;
        const detailRows = items.map((item, index) => {
          const investVal = Number.isFinite(item.investConverted) ? item.investConverted : convert(item.invest, item.curr);
          const currentVal = Number.isFinite(item.currentConverted) ? item.currentConverted : convert(item.current, item.curr);
          const pnlVal = Number.isFinite(item.pnlConverted)
            ? item.pnlConverted
            : (Number.isFinite(investVal) && Number.isFinite(currentVal) ? currentVal - investVal : NaN);
          const pnlColor = Number.isFinite(pnlVal) ? (pnlVal >= 0 ? '#34d399' : '#f87171') : 'inherit';
          const label = index === 0 ? 'První vklad' : `Dokup #${index}`;
          const dateLabel = formatDate(item.originalDateIn || item.dateIn);
          return `<tr><td>${label} <span style="color: var(--text-muted);">(${dateLabel})</span></td>` +
            `<td>${cellNum(investVal, 0)}</td>` +
            `<td style="color:${pnlColor};">${cellNum(pnlVal, 0)}</td>` +
            `<td>${cellPct(item.ret)}</td>` +
            `<td>${Number.isFinite(item.months) ? `${cellNum(item.months, 1)} měs.` : '—'}</td>` +
            `<td>${Number.isFinite(item.irr) ? `${cellPct(item.irr)} p.a.` : '—'}</td></tr>`;
        }).join('');
        const pnlColor = Number.isFinite(pnl) ? (pnl >= 0 ? '#34d399' : '#f87171') : 'inherit';
        const irrColor = Number.isFinite(irr) ? (irr >= 0 ? '#34d399' : '#f87171') : 'inherit';
        const latestLabel = latestDate ? formatDate(latestDate) : 'N/A';
        return `<article class="fund-card">` +
          `<div class="fund-header">` +
          `<div class="fund-name"><span style="width:12px;height:12px;border-radius:999px;background:${colorFor(group.name)};"></span>${escapeHtml(group.name)}</div>` +
          `<div class="disclosure">Aktualizováno k ${latestLabel}</div>` +
          `</div>` +
          `<div class="fund-metrics">` +
          `<div><span class="fund-metric-label">Aktuální hodnota</span><div class="fund-metric-value">${cellNum(totalCurrent, 0)}</div></div>` +
          `<div><span class="fund-metric-label">Celkový zisk / ztráta</span><div class="fund-metric-value" style="color:${pnlColor};">${cellNum(pnl, 0)}</div></div>` +
          `<div><span class="fund-metric-label">Výkonnost (XIRR)</span><div class="fund-metric-value" style="color:${irrColor};">${Number.isFinite(irr) ? `${cellPct(irr)} p.a.` : '—'}</div></div>` +
          `<div><span class="fund-metric-label">Váž. prům. doba</span><div class="fund-metric-value">${Number.isFinite(weightedAvg) ? `${cellNum(weightedAvg, 1)} měs.` : '—'}</div></div>` +
          `</div>` +
          `<div style="overflow-x: auto; margin-top: 12px;">` +
          `<table class="fund-details"><thead><tr><th>Transakce</th><th>Investice</th><th>Výnos</th><th>Kumulativně</th><th>Doba</th><th>XIRR</th></tr></thead><tbody>${detailRows}</tbody></table>` +
          `</div>` +
          `</article>`;
      };

      const fundsMarkup = fundGroups.length ? fundGroups.map(buildFundCard).join('') : '<div class="disclosure">Nejsou k dispozici žádná data pro výpočet.</div>';

      const pnlStyle = Number.isFinite(summary.totalPnl) ? ` style="color:${summary.totalPnl >= 0 ? '#34d399' : '#f87171'};"` : '';
      const retStyle = Number.isFinite(summary.totalRet) ? ` style="color:${summary.totalRet >= 0 ? '#34d399' : '#f87171'};"` : '';
      const irrStyle = Number.isFinite(summary.portfolioIrr) ? ` style="color:${summary.portfolioIrr >= 0 ? '#34d399' : '#f87171'};"` : '';

      const minDate = summary?.minValuationDate ? toDate(summary.minValuationDate) : null;
      const maxDate = summary?.maxValuationDate ? toDate(summary.maxValuationDate) : null;
      let dateNote = '';
      if (minDate && maxDate) {
        const minLabel = minDate.toLocaleDateString('cs-CZ');
        const maxLabel = maxDate.toLocaleDateString('cs-CZ');
        dateNote = minLabel === maxLabel
          ? `Hodnoty jsou platné k ${maxLabel}.`
          : `Hodnoty jsou platné k posledním známým datům v rozmezí ${minLabel} – ${maxLabel}.`;
      }

      const investDates = normalisedFunds.map((item) => item.dateIn).filter((d) => d instanceof Date && !Number.isNaN(d.valueOf()));
      const sliderStart = investDates.length ? investDates.reduce((earliest, date) => (date < earliest ? date : earliest)) : null;
      const sliderStartLabel = sliderStart ? sliderStart.toLocaleDateString('cs-CZ') : '—';
      const sliderEndLabel = new Date(`${CHART_END_YEAR}-12-31`).toLocaleDateString('cs-CZ');

      const generatedAtLabel = (generatedAt instanceof Date && !Number.isNaN(generatedAt.valueOf())) ? generatedAt.toLocaleString('cs-CZ') : '—';
      const clientLabel = clientName || '—';
      const currencyNote = `Částky v ${outCurr}`;
      const lineChartMarkup = generateLineChartMarkup(chartFunds, summary, outCurr);
      const pieChartMarkup = generatePieChartMarkup(chartFunds, outCurr);
      const lineChartSafe = lineChartMarkup || '<div class="disclosure">Pro vykreslení grafu nejsou dostupná data.</div>';
      const pieChartSafe = pieChartMarkup || '<div class="disclosure">Pro zobrazení alokace nejsou dostupná data.</div>';

      const investDisplay = cellNum(summary.totalInvestConverted, 0);
      const currentDisplay = cellNum(summary.totalCurrentConverted, 0);
      const pnlDisplay = cellNum(summary.totalPnl, 0);
      const retDisplay = cellPct(summary.totalRet);
      const irrDisplay = Number.isFinite(summary.portfolioIrr) ? `${cellPct(summary.portfolioIrr)} p.a.` : '—';
      const durationDisplay = Number.isFinite(summary.weightedAvgMonths) ? `${cellNum(summary.weightedAvgMonths, 1)} měs.` : '—';

      const exportData = { ...payload, chartFunds };
      const serialized = JSON.stringify(exportData)
          .replace(/</g, '\u003c')
          .replace(/>/g, '\u003e')
          .replace(/<\/script/gi, '<\/script');
      let html = String.raw`<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Report portfolia – FairLife</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      color-scheme: light;
      --surface: #ffffff;
      --surface-muted: #f1f5f9;
      --border: rgba(15, 118, 110, 0.12);
      --border-strong: rgba(15, 118, 110, 0.24);
      --accent: #14b8a6;
      --accent-strong: #0f766e;
      --accent-soft: rgba(20, 184, 166, 0.16);
      --text-primary: #0f172a;
      --text-secondary: #334155;
      --text-muted: #64748b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(180deg, #ecfeff 0%, #f8fafc 55%, #f1f5f9 100%);
      color: var(--text-primary);
      min-height: 100vh;
    }
    a { color: inherit; }
    .page-shell {
      position: relative;
      padding-bottom: 4rem;
    }
    .page-shell::before,
    .page-shell::after {
      content: '';
      position: absolute;
      border-radius: 9999px;
      filter: blur(80px);
      opacity: 0.55;
      pointer-events: none;
    }
    .page-shell::before {
      top: -160px;
      left: -120px;
      width: 360px;
      height: 360px;
      background: rgba(20, 184, 166, 0.3);
    }
    .page-shell::after {
      top: -200px;
      right: -160px;
      width: 420px;
      height: 420px;
      background: rgba(56, 189, 248, 0.25);
    }
    .content-wrap {
      position: relative;
      z-index: 1;
      max-width: 1100px;
      margin: 0 auto;
      padding: 56px 28px 0;
      display: flex;
      flex-direction: column;
      gap: 56px;
    }
    .hero {
      display: grid;
      gap: 18px;
      background: var(--surface);
      border-radius: 28px;
      padding: 32px 36px;
      border: 1px solid var(--border);
      box-shadow: 0 20px 60px -32px rgba(15, 23, 42, 0.35);
    }
    .hero h1 {
      font-size: clamp(2.4rem, 4vw, 3rem);
      font-weight: 700;
      letter-spacing: -0.02em;
      margin: 0;
      color: var(--text-primary);
    }
    .hero p {
      margin: 0;
      color: var(--text-muted);
      font-size: 1rem;
      max-width: 640px;
      line-height: 1.6;
    }
    .hero-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 20px;
      font-size: 0.95rem;
      color: var(--text-secondary);
      align-items: center;
    }
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 26px;
      padding: 32px;
      box-shadow: 0 18px 50px -28px rgba(15, 23, 42, 0.35);
    }
    .card h2 {
      margin: 0 0 18px;
      font-size: 1.45rem;
      font-weight: 600;
      color: var(--text-primary);
    }
    .summary-grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .metric {
      padding: 20px 22px;
      border-radius: 20px;
      background: linear-gradient(135deg, rgba(20, 184, 166, 0.12), rgba(45, 212, 191, 0.08));
      border: 1px solid rgba(15, 118, 110, 0.15);
      transition: transform 0.3s ease, border-color 0.3s ease;
    }
    .metric:hover {
      transform: translateY(-2px);
      border-color: rgba(15, 118, 110, 0.32);
    }
    .metric-label {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-muted);
      margin-bottom: 8px;
      display: block;
    }
    .metric-value {
      font-size: 1.6rem;
      font-weight: 600;
      color: var(--text-primary);
    }
    .metric-subtext {
      margin-top: 6px;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    .fund-card {
      border-radius: 22px;
      padding: 28px;
      display: grid;
      gap: 20px;
      background: var(--surface-muted);
      border: 1px solid rgba(148, 163, 184, 0.24);
      transition: transform 0.3s ease, border-color 0.3s ease;
    }
    .fund-card:hover {
      transform: translateY(-4px);
      border-color: rgba(15, 118, 110, 0.35);
    }
    .fund-header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 18px;
      justify-content: space-between;
      align-items: center;
    }
    .fund-name {
      font-size: 1.35rem;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .fund-metrics {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    .fund-metric-label {
      font-size: 0.8rem;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 6px;
      display: block;
    }
    .fund-metric-value {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text-primary);
    }
    .fund-details {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.92rem;
      background: var(--surface);
      border-radius: 16px;
      overflow: hidden;
    }
    .fund-details thead {
      color: var(--text-muted);
      text-transform: uppercase;
      font-size: 0.72rem;
      letter-spacing: 0.18em;
      background: rgba(148, 163, 184, 0.1);
    }
    .fund-details th,
    .fund-details td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
    }
    .fund-details tbody tr:last-child td {
      border-bottom: none;
    }
    .fund-details td:last-child,
    .fund-details th:last-child {
      text-align: right;
    }
    .fund-details td:nth-child(2),
    .fund-details td:nth-child(3),
    .fund-details td:nth-child(4),
    .fund-details td:nth-child(5),
    .fund-details td:nth-child(6) {
      text-align: right;
    }
    .disclosure {
      font-size: 0.9rem;
      color: var(--text-secondary);
      line-height: 1.6;
    }
    .chart-card {
      display: grid;
      gap: 32px;
    }
    .chart-fallback {
      display: grid;
      gap: 24px;
      justify-items: center;
    }
    .chart-fallback svg {
      max-width: 360px;
    }
    .chart-legend {
      display: grid;
      gap: 12px;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }
    #chart-tooltip {
      position: fixed;
      top: 0;
      left: 0;
      transform: translate(-50%, -120%);
      background: rgba(255, 255, 255, 0.95);
      color: var(--text-primary);
      padding: 12px 16px;
      border-radius: 14px;
      font-size: 0.85rem;
      box-shadow: 0 12px 40px rgba(15, 23, 42, 0.18);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease;
      border: 1px solid var(--border);
      z-index: 50;
    }
    #chart-tooltip.show { opacity: 1; }
    .line-chart-dot { cursor: pointer; transition: r 0.2s ease; }
    .line-chart-dot:hover { r: 6; }
    .pie-segment { cursor: pointer; transition: transform 0.22s ease; transform-origin: center; }
    .pie-segment:hover { transform: scale(1.04); }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: var(--accent-soft);
      color: var(--accent-strong);
      padding: 8px 14px;
      border-radius: 999px;
      font-size: 0.82rem;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }
    details summary {
      cursor: pointer;
      list-style: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      color: var(--text-secondary);
    }
    details summary::-webkit-details-marker { display: none; }
    details[open] .summary-arrow { transform: rotate(90deg); }
    .summary-arrow { transition: transform 0.2s ease; color: var(--accent-strong); }
    input[type="range"] {
      accent-color: var(--accent-strong);
    }
    @media (max-width: 720px) {
      .card { padding: 24px; }
      .fund-card { padding: 22px; }
      .content-wrap { padding: 48px 20px 0; gap: 40px; }
      .hero { padding: 28px; }
    }
  </style>
</head>
<body>
  <div class="page-shell">
    <main class="content-wrap">
      <header class="hero">
        <span class="pill">Interaktivní prezentace portfolia</span>
        <h1>Report investičního portfolia</h1>
        <p>Souhrn výsledků, historického vývoje a očekávané projekce Vašeho portfolia. Všechny částky jsou uvedeny v cílové měně dle dohody s poradcem.</p>
        <div class="hero-meta">
          <div>Klientská prezentace FairLife</div>
          <div class="meta-separator" id="client-separator">|</div>
          <div class="client-meta" id="client-meta"><strong>Klient:</strong> <span id="report-client-name">—</span></div>
          <div class="meta-separator">|</div>
          <div><strong>Generováno:</strong> <span id="report-generated-at">—</span></div>
          <div class="meta-separator">|</div>
          <div><strong>Měna výstupu:</strong> <span id="report-currency">—</span></div>
        </div>
      </header>

      <section class="card">
        <div class="fund-header" style="margin-bottom: 18px;">
          <div>
            <h2>Souhrn portfolia</h2>
            <p class="disclosure" id="summary-currency-note">Částky v CZK</p>
          </div>
          <div class="disclosure" id="portfolio-date-note"></div>
        </div>
        <div class="summary-grid">
          <div class="metric">
            <span class="metric-label">Celkové vklady</span>
            <div class="metric-value" id="summary-total-invest">—</div>
            <div class="metric-subtext">Součet všech historických vkladů</div>
          </div>
          <div class="metric">
            <span class="metric-label">Aktuální hodnota</span>
            <div class="metric-value" id="summary-total-current">—</div>
            <div class="metric-subtext">K poslednímu ocenění fondu</div>
          </div>
          <div class="metric">
            <span class="metric-label">Čistý zisk / ztráta</span>
            <div class="metric-value" id="summary-total-pnl">—</div>
            <div class="metric-subtext">Rozdíl mezi vklady a současnou hodnotou</div>
          </div>
          <div class="metric">
            <span class="metric-label">Kumulativní zhodnocení</span>
            <div class="metric-value" id="summary-total-ret">—</div>
            <div class="metric-subtext">Výnos od začátku investování</div>
          </div>
          <div class="metric">
            <span class="metric-label">XIRR (časově vážený výnos)</span>
            <div class="metric-value" id="summary-irr">—</div>
            <div class="metric-subtext">Průměrné roční tempo zhodnocení</div>
          </div>
          <div class="metric">
            <span class="metric-label">Vážená průměrná doba investice</span>
            <div class="metric-value" id="summary-duration">—</div>
            <div class="metric-subtext">Zohledňuje načasování jednotlivých vkladů</div>
          </div>
        </div>
      </section>

      <section class="card">
        <div class="fund-header" style="margin-bottom: 18px;">
          <div>
            <h2>Výsledky po fondech</h2>
            <p class="disclosure">Přehled všech sledovaných fondů a jejich aktuální výkonnosti.</p>
          </div>
          <div class="disclosure">Částky v <span id="funds-currency">—</span></div>
        </div>
        <div id="client-funds-container" class="space-y-4"></div>
      </section>

      <section class="card chart-card">
        <div>
          <h2>Vývoj portfolia a projekce</h2>
          <p class="disclosure">Historický vývoj hodnoty portfolia a projekce při zachování stávajícího tempa zhodnocení.</p>
          <div id="client-line-chart" style="margin-top: 24px; min-height: 340px;"></div>
        </div>
        <div>
          <h2>Alokace portfolia v čase</h2>
          <p class="disclosure">Prozkoumejte rozložení portfolia k libovolnému datu pomocí časové osy.</p>
          <div id="client-pie-chart" style="margin-top: 18px;"></div>
          <div style="margin-top: 18px; display: grid; gap: 10px;">
            <input type="range" id="client-pie-slider" min="0" max="100" value="0" />
            <div style="display: flex; justify-content: space-between; font-size: 0.85rem; color: var(--text-muted);">
              <span id="client-pie-start">—</span>
              <span id="client-pie-current" style="font-weight: 600; color: #38bdf8;">—</span>
              <span id="client-pie-end">—</span>
            </div>
          </div>
        </div>
      </section>

      <section class="card">
        <details open>
          <summary>
            <h2>Vysvětlivky</h2>
            <svg class="summary-arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" width="20" height="20"><path fill-rule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clip-rule="evenodd" /></svg>
          </summary>
            <div style="margin-top: 18px; display: grid; gap: 18px; font-size: 0.95rem; color: var(--text-secondary);">
              <div>
                <h3 style="margin: 0 0 6px; font-size: 1.05rem; color: var(--text-primary);">Co je XIRR a jak funguje?</h3>
              <p style="margin: 0 0 10px;">XIRR (z anglického <em>Extended Internal Rate of Return</em>) je nejpřesnější metoda pro výpočet průměrného ročního zhodnocení investice. Zohledňuje načasování jednotlivých vkladů a výběrů.</p>
              <p style="margin: 0;">Díky tomu je vhodný pro portfolia, kde dochází k průběžným změnám investované částky. Výsledek vyjadřuje anualizované tempo výnosu.</p>
            </div>
              <div>
                <h3 style="margin: 0 0 6px; font-size: 1.05rem; color: var(--text-primary);">Co znamená kumulativní zhodnocení?</h3>
              <p style="margin: 0 0 10px;">Ukazuje celkový čistý zisk nebo ztrátu jako procento z celkové investované částky. Na rozdíl od XIRR nezohledňuje časové rozložení investic.</p>
              <p style="margin: 0;">Tento ukazatel je vhodný pro rychlou orientaci, XIRR pak poskytne přesnější obraz při různých datech vkladů.</p>
            </div>
          </div>
        </details>
      </section>
    </main>
  </div>
  <div id="chart-tooltip"></div>
  <script type="application/json" id="export-data">${serialized}<\/script>
  <script>
    (function () {
      const MS_PER_DAY = ${MS_PER_DAY};
      const CHART_END_YEAR = ${CHART_END_YEAR};
      let data = {};
      try {
        const raw = document.getElementById('export-data');
        if (raw) {
          data = JSON.parse(raw.textContent || '{}');
        }
      } catch (err) {
        console.error('Nepodařilo se načíst data prezentace:', err);
        data = {};
      }
      const parseDate = (value) => (value ? new Date(value) : null);
      const fundsSource = Array.isArray(data.chartFunds) && data.chartFunds.length
        ? data.chartFunds
        : (Array.isArray(data.funds) ? data.funds : []);
      let funds = [];
      let summary = data.summary || {};
      const meta = (data && typeof data.meta === 'object') ? data.meta : {};
      const clientName = (data.clientName || meta.clientName || '').trim();
      const outCurr = data.outCurr || 'CZK';
      const fxRate = data.fxRate;
      let hasMixedCurrencies = typeof data.hasMixedCurrencies === 'boolean' ? data.hasMixedCurrencies : null;
      const rawRows = data.rows || null;
      const coerceSummaryNumbers = () => {
        if (!summary || typeof summary !== 'object') return;
        ['totalInvestConverted', 'totalCurrentConverted', 'totalPnl', 'totalRet', 'portfolioIrr', 'weightedAvgMonths'].forEach((key) => {
          if (summary[key] === null || summary[key] === undefined) return;
          if (typeof summary[key] === 'number') return;
          const num = Number(summary[key]);
          if (Number.isFinite(num)) {
            summary[key] = num;
          }
        });
      };
      coerceSummaryNumbers();

      const parseNumber = (value) => {
        if (typeof value === 'number') return Number.isFinite(value) ? value : NaN;
        if (value === null || value === undefined) return NaN;
        let text = String(value).replace(/\u00A0/g, ' ').trim();
        if (!text) return NaN;
        text = text.replace(/\s*\b(Kč|CZK|€|EUR)\b\s*/gi, '');
        text = text.replace(/[\u2212\u2013\u2014]/g, '-');
        let isNegative = false;
        if (text.startsWith('(') && text.endsWith(')')) {
          isNegative = true;
          text = text.slice(1, -1);
        }
        text = text.replace(/\s+/g, '');
        const lastComma = text.lastIndexOf(',');
        const lastDot = text.lastIndexOf('.');
        if (lastComma > lastDot) {
          text = text.replace(/\./g, '').replace(',', '.');
        } else if (lastDot > -1 && text.length - lastDot - 1 > 2) {
          text = text.replace(/,/g, '');
        } else {
          text = text.replace(/,/g, '');
        }
        const num = Number.parseFloat(text);
        if (!Number.isFinite(num)) return NaN;
        return isNegative ? -Math.abs(num) : num;
      };

      const normalizeName = (value) => String(value || '').replace(/[\u00A0\s]+/g, ' ').trim();
      const parseLooseDate = (value) => {
        if (!value) return null;
        const text = String(value).trim();
        if (/^\d{4}-\d{2}-\d{2}$/.test(text)) {
          const date = new Date(text);
          return Number.isNaN(date.valueOf()) ? null : date;
        }
        const match = text.match(/^([0-3]?\d)\.?\s*([01]?\d)\.?\s*(\d{4})$/);
        if (match) {
          const isoLike = [match[3], match[2], match[1]].join('-');
          const date = new Date(isoLike);
          return Number.isNaN(date.valueOf()) ? null : date;
        }
        const fallback = new Date(text);
        return Number.isNaN(fallback.valueOf()) ? null : fallback;
      };
      const monthsDiff = (start, end) => {
        if (!(start instanceof Date) || !(end instanceof Date)) return NaN;
        const diff = end.getTime() - start.getTime();
        if (!Number.isFinite(diff)) return NaN;
        const days = diff / MS_PER_DAY;
        return Math.max(0, days / (365.2425 / 12));
      };

      const nf = (digits) => new Intl.NumberFormat('cs-CZ', { minimumFractionDigits: digits, maximumFractionDigits: digits });
      const fmt0 = nf(0);
      const fmt1 = nf(1);
      const fmt2 = nf(2);
      const fmt4 = nf(4);
      const cellNum = (value, digits = 2) => {
        if (!Number.isFinite(value)) return '—';
        if (digits === 0) return fmt0.format(value);
        if (digits === 1) return fmt1.format(value);
        if (digits === 4) return fmt4.format(value);
        return fmt2.format(value);
      };
      const cellPct = (value) => Number.isFinite(value) ? fmt2.format(value * 100) + ' %' : '—';
      const formatDate = (value) => (value instanceof Date && !Number.isNaN(value.valueOf())) ? value.toLocaleDateString('cs-CZ') : 'N/A';
      const convertAmount = (amount, from, to, rate) => {
        if (!Number.isFinite(amount)) return NaN;
        if (from === to) return amount;
        if (!Number.isFinite(rate) || rate <= 0) return NaN;
        if (from === 'EUR' && to === 'CZK') return amount * rate;
        if (from === 'CZK' && to === 'EUR') return amount / rate;
        return NaN;
      };
      const convert = (amount, from) => convertAmount(amount, from, outCurr, fxRate);

      const finance = (() => {
        const xnpv = (rate, cashflows) => {
          if (!Number.isFinite(rate) || !cashflows.length) return NaN;
          const sorted = cashflows.slice().sort((a, b) => a.date - b.date);
          const t0 = sorted[0]?.date;
          if (!t0) return NaN;
          return sorted.reduce((sum, cf) => {
            const days = (cf.date - t0) / MS_PER_DAY;
            return sum + cf.amount / Math.pow(1 + rate, days / 365.25);
          }, 0);
        };
        const xirr = (cashflows, iterations = 100) => {
          if (!Array.isArray(cashflows) || cashflows.length < 2) return NaN;
          let hasPos = false;
          let hasNeg = false;
          cashflows.forEach((cf) => {
            if (cf.amount > 0) hasPos = true;
            if (cf.amount < 0) hasNeg = true;
          });
          if (!hasPos || !hasNeg) return NaN;
          let low = -0.9999;
          let high = 10;
          let mid = 0;
          for (let i = 0; i < iterations; i++) {
            mid = (low + high) / 2;
            const npv = xnpv(mid, cashflows);
            if (Math.abs(npv) < 1e-6) break;
            if (npv > 0) {
              low = mid;
            } else {
              high = mid;
            }
          }
          return Number.isFinite(mid) ? mid : NaN;
        };
        return { xirr };
      })();

      const toFiniteNumber = (value) => {
        const num = parseNumber(value);
        return Number.isFinite(num) ? num : NaN;
      };

      const hydrateSnapshot = (item) => {
        if (!item) return null;
        const fundName = typeof item.fund === 'string' && item.fund.trim()
          ? item.fund.trim()
          : (typeof item.name === 'string' && item.name.trim() ? item.name.trim() : '');
        if (!fundName) return null;
        const curr = item.curr || 'CZK';
        const dateIn = parseDate(item.dateIn);
        const originalDateIn = parseDate(item.originalDateIn);
        const currDate = parseDate(item.currDate);
        let invest = toFiniteNumber(item.invest);
        let qty = toFiniteNumber(item.qty);
        const issueNav = toFiniteNumber(item.issueNav);
        const currNav = toFiniteNumber(item.currNav);
        if (!Number.isFinite(qty) && Number.isFinite(invest) && Number.isFinite(issueNav) && issueNav > 0) {
          qty = invest / issueNav;
        }
        if (!Number.isFinite(invest) && Number.isFinite(qty) && Number.isFinite(issueNav) && issueNav > 0) {
          invest = qty * issueNav;
        }
        let current = toFiniteNumber(item.current);
        if (!Number.isFinite(current) && Number.isFinite(qty) && Number.isFinite(currNav) && currNav > 0) {
          current = qty * currNav;
        }
        let investConverted = toFiniteNumber(item.investConverted);
        if (!Number.isFinite(investConverted) && Number.isFinite(invest)) {
          investConverted = convert(invest, curr);
        }
        let currentConverted = toFiniteNumber(item.currentConverted);
        if (!Number.isFinite(currentConverted) && Number.isFinite(current)) {
          currentConverted = convert(current, curr);
        }
        let pnlConverted = toFiniteNumber(item.pnlConverted);
        if (!Number.isFinite(pnlConverted) && Number.isFinite(investConverted) && Number.isFinite(currentConverted)) {
          pnlConverted = currentConverted - investConverted;
        }
        const pnlRaw = toFiniteNumber(item.pnl);
        const pnl = Number.isFinite(pnlRaw)
          ? pnlRaw
          : (Number.isFinite(invest) && Number.isFinite(current) ? current - invest : NaN);
        const retRaw = toFiniteNumber(item.ret);
        const ret = Number.isFinite(retRaw)
          ? retRaw
          : (Number.isFinite(invest) && invest !== 0 && Number.isFinite(current) ? current / invest - 1 : NaN);
        let irr = toFiniteNumber(item.irr);
        if (!Number.isFinite(irr) && dateIn instanceof Date && currDate instanceof Date && Number.isFinite(invest) && Number.isFinite(current)) {
          irr = finance.xirr([{ date: dateIn, amount: -invest }, { date: currDate, amount: current }]);
        }
        let months = toFiniteNumber(item.months);
        if (!Number.isFinite(months) && dateIn instanceof Date && currDate instanceof Date) {
          months = monthsDiff(dateIn, currDate);
        }
        return {
          fund: fundName,
          curr,
          invest,
          current,
          qty,
          issueNav,
          currNav,
          investConverted,
          currentConverted,
          pnlConverted,
          pnl,
          ret,
          irr,
          months,
          dateIn,
          originalDateIn,
          currDate
        };
      };

      if (Array.isArray(fundsSource) && fundsSource.length) {
        funds = fundsSource.map(hydrateSnapshot).filter(Boolean);
      }

      const rebuildFromRows = (rows) => {
        const processed = [];
        const currencies = new Set();
        Object.entries(rows || {}).forEach(([providerKey, providerRows]) => {
          (Array.isArray(providerRows) ? providerRows : []).forEach((row) => {
            const fundName = normalizeName(row.fund);
            if (!fundName) return;
            const curr = row.curr || 'CZK';
            currencies.add(curr);
            const dateInRaw = parseLooseDate(row.dateIn);
            const currDateRaw = parseLooseDate(row.currDate);
            if (!(dateInRaw instanceof Date) || Number.isNaN(dateInRaw.valueOf())) return;
            if (!(currDateRaw instanceof Date) || Number.isNaN(currDateRaw.valueOf())) return;
            const issueNav = parseNumber(row.issueNav);
            const currNav = parseNumber(row.currNav);
            let invest = parseNumber(row.invest);
            let qty = parseNumber(row.qty);
            let current = parseNumber(row.totalCurrent);
            if (!Number.isFinite(qty) && Number.isFinite(invest) && Number.isFinite(issueNav) && issueNav > 0) qty = invest / issueNav;
            if (!Number.isFinite(invest) && Number.isFinite(qty) && Number.isFinite(issueNav) && issueNav > 0) invest = qty * issueNav;
            if (!Number.isFinite(current) && Number.isFinite(qty) && Number.isFinite(currNav) && currNav > 0) current = qty * currNav;
            if (!Number.isFinite(invest) || !Number.isFinite(current)) return;
            const effectiveDateIn = providerKey === 'atris' ? new Date(dateInRaw.getFullYear(), dateInRaw.getMonth() + 1, 5) : dateInRaw;
            const months = monthsDiff(effectiveDateIn, currDateRaw);
            const pnl = Number.isFinite(invest) && Number.isFinite(current) ? current - invest : NaN;
            const ret = invest > 0 ? current / invest - 1 : NaN;
            const irr = finance.xirr([{ date: effectiveDateIn, amount: -invest }, { date: currDateRaw, amount: current }]);
            const investConverted = convert(invest, curr);
            const currentConverted = convert(current, curr);
            const pnlConverted = (Number.isFinite(investConverted) && Number.isFinite(currentConverted)) ? currentConverted - investConverted : NaN;
            processed.push({
              fund: fundName,
              invest,
              qty: Number.isFinite(qty) ? qty : NaN,
              current,
              curr,
              issueNav,
              currNav,
              pnl,
              ret,
              months,
              irr,
              investConverted,
              currentConverted,
              pnlConverted,
              dateIn: effectiveDateIn,
              originalDateIn: dateInRaw,
              currDate: currDateRaw
            });
          });
        });
        const summaryCalc = (() => {
          let totalInvest = 0;
          let totalCurrent = 0;
          let weightedDuration = 0;
          const cashflows = [];
          let latestDate = null;
          let minValuationDate = null;
          let maxValuationDate = null;
          processed.forEach((item) => {
            const convertedInvest = Number.isFinite(item.investConverted) ? item.investConverted : convert(item.invest, item.curr);
            const convertedCurrent = Number.isFinite(item.currentConverted) ? item.currentConverted : convert(item.current, item.curr);
            if (Number.isFinite(convertedInvest)) {
              totalInvest += convertedInvest;
              cashflows.push({ date: item.dateIn, amount: -convertedInvest });
              if (Number.isFinite(item.months)) {
                weightedDuration += convertedInvest * item.months;
              }
            }
            if (Number.isFinite(convertedCurrent)) {
              totalCurrent += convertedCurrent;
            }
            if (item.currDate instanceof Date && !Number.isNaN(item.currDate.valueOf())) {
              if (!minValuationDate || item.currDate < minValuationDate) minValuationDate = item.currDate;
              if (!maxValuationDate || item.currDate > maxValuationDate) maxValuationDate = item.currDate;
              if (!latestDate || item.currDate > latestDate) latestDate = item.currDate;
            }
          });
          if (Number.isFinite(totalCurrent) && latestDate) {
            cashflows.push({ date: latestDate, amount: totalCurrent });
          }
          const totalPnl = totalCurrent - totalInvest;
          const totalRet = totalInvest > 0 ? totalPnl / totalInvest : NaN;
          const portfolioIrr = finance.xirr(cashflows);
          const weightedAvgMonths = totalInvest > 0 ? weightedDuration / totalInvest : NaN;
          return {
            totalInvestConverted: totalInvest,
            totalCurrentConverted: totalCurrent,
            totalPnl,
            totalRet,
            portfolioIrr,
            weightedAvgMonths,
            minValuationDate: minValuationDate ? minValuationDate.toISOString() : null,
            maxValuationDate: maxValuationDate ? maxValuationDate.toISOString() : null,
            hasData: totalInvest > 0 || totalCurrent > 0
          };
        })();
        return { funds: processed, summary: summaryCalc, hasMixedCurrencies: currencies.size > 1 };
      };

      let rebuilt = null;
      if (rawRows) {
        rebuilt = rebuildFromRows(rawRows);
        if (rebuilt && rebuilt.funds.length) {
          funds = rebuilt.funds;
          summary = rebuilt.summary || summary || {};
          coerceSummaryNumbers();
          if (typeof data.hasMixedCurrencies === 'boolean') {
            hasMixedCurrencies = data.hasMixedCurrencies;
          } else if (typeof rebuilt.hasMixedCurrencies === 'boolean') {
            hasMixedCurrencies = rebuilt.hasMixedCurrencies;
          }
        }
      }

      if ((!funds.length || !summary || !summary.hasData) && rebuilt && rebuilt.funds.length) {
        funds = rebuilt.funds;
        summary = rebuilt.summary || summary;
        coerceSummaryNumbers();
        if (typeof rebuilt.hasMixedCurrencies === 'boolean' && typeof hasMixedCurrencies !== 'boolean') {
          hasMixedCurrencies = rebuilt.hasMixedCurrencies;
        }
      }

      if (!summary) {
        summary = {
          totalInvestConverted: NaN,
          totalCurrentConverted: NaN,
          totalPnl: NaN,
          totalRet: NaN,
          portfolioIrr: NaN,
          weightedAvgMonths: NaN,
          minValuationDate: null,
          maxValuationDate: null,
          hasData: false
        };
      }

      if (typeof hasMixedCurrencies !== 'boolean' && funds.length) {
        hasMixedCurrencies = new Set(funds.map((item) => item.curr)).size > 1;
      }

      const CHART_COLORS = ['#38bdf8', '#34d399', '#f97316', '#a855f7', '#22d3ee', '#f43f5e', '#4ade80', '#facc15', '#fb7185', '#6366f1'];
      const colorMap = {};
      const getColor = (name) => {
        if (!colorMap[name]) {
          const index = Object.keys(colorMap).length % CHART_COLORS.length;
          colorMap[name] = CHART_COLORS[index];
        }
        return colorMap[name];
      };

      const generatedAt = data.generatedAt ? new Date(data.generatedAt) : null;
      const generatedLabel = document.getElementById('report-generated-at');
      if (generatedLabel && generatedAt instanceof Date && !Number.isNaN(generatedAt.valueOf())) {
        generatedLabel.textContent = generatedAt.toLocaleString('cs-CZ');
      }
      const clientNameEl = document.getElementById('report-client-name');
      const clientMetaEl = document.getElementById('client-meta');
      const clientSeparatorEl = document.getElementById('client-separator');
      if (clientNameEl) {
        clientNameEl.textContent = clientName || '—';
      }
      if (clientMetaEl) {
        if (clientName) {
          clientMetaEl.style.display = '';
          if (clientSeparatorEl) clientSeparatorEl.style.display = '';
        } else {
          clientMetaEl.style.display = 'none';
          if (clientSeparatorEl) clientSeparatorEl.style.display = 'none';
        }
      }
      const currencyLabel = document.getElementById('report-currency');
      if (currencyLabel) {
        currencyLabel.textContent = outCurr;
      }
      const summaryCurrency = document.getElementById('summary-currency-note');
      if (summaryCurrency) {
        summaryCurrency.textContent = 'Částky v ' + outCurr;
      }
      const fundsCurrency = document.getElementById('funds-currency');
      if (fundsCurrency) {
        fundsCurrency.textContent = outCurr;
      }

      const totalInvestEl = document.getElementById('summary-total-invest');
      const totalCurrentEl = document.getElementById('summary-total-current');
      const pnlEl = document.getElementById('summary-total-pnl');
      const retEl = document.getElementById('summary-total-ret');
      const irrEl = document.getElementById('summary-irr');
      const durationEl = document.getElementById('summary-duration');
      const dateNoteEl = document.getElementById('portfolio-date-note');

      if (totalInvestEl) totalInvestEl.textContent = cellNum(summary.totalInvestConverted, 0);
      if (totalCurrentEl) totalCurrentEl.textContent = cellNum(summary.totalCurrentConverted, 0);
      if (pnlEl) {
        pnlEl.textContent = cellNum(summary.totalPnl, 0);
        if (Number.isFinite(summary.totalPnl)) {
          pnlEl.style.color = summary.totalPnl >= 0 ? '#34d399' : '#f87171';
        }
      }
      if (retEl) {
        retEl.textContent = cellPct(summary.totalRet);
        if (Number.isFinite(summary.totalRet)) {
          retEl.style.color = summary.totalRet >= 0 ? '#34d399' : '#f87171';
        }
      }
      if (irrEl) {
        irrEl.textContent = Number.isFinite(summary.portfolioIrr) ? cellPct(summary.portfolioIrr) + ' p.a.' : '—';
        if (Number.isFinite(summary.portfolioIrr)) {
          irrEl.style.color = summary.portfolioIrr >= 0 ? '#34d399' : '#f87171';
        }
      }
      if (durationEl) durationEl.textContent = Number.isFinite(summary.weightedAvgMonths) ? cellNum(summary.weightedAvgMonths, 1) + ' měs.' : '—';
      if (dateNoteEl) {
        const minDate = summary.minValuationDate ? new Date(summary.minValuationDate) : null;
        const maxDate = summary.maxValuationDate ? new Date(summary.maxValuationDate) : null;
        if (minDate && maxDate) {
          const minText = formatDate(minDate);
          const maxText = formatDate(maxDate);
          dateNoteEl.textContent = minText === maxText ? 'Hodnoty platné k ' + maxText + '.' : 'Hodnoty platné k posledním známým datům v rozmezí ' + minText + ' – ' + maxText + '.';
        } else {
          dateNoteEl.textContent = '';
        }
      }

      const groupedFunds = funds.reduce((acc, fund) => {
        if (!fund.fund) return acc;
        if (!acc[fund.fund]) acc[fund.fund] = [];
        acc[fund.fund].push(fund);
        return acc;
      }, {});

      const fundsContainer = document.getElementById('client-funds-container');
      if (fundsContainer) {
        const entries = Object.entries(groupedFunds);
        if (!entries.length) {
          fundsContainer.innerHTML = '<div class="disclosure">Pro klientskou prezentaci nejsou k dispozici žádná data.</div>';
        } else {
          const fragments = [];
          entries.forEach(([name, list]) => {
            const sorted = list.slice().sort((a, b) => a.dateIn - b.dateIn);
            let totalInvest = 0;
            let totalCurrent = 0;
            let weightedDuration = 0;
            const cashflows = [];
            let latestDate = null;
            sorted.forEach((item) => {
              const investConverted = Number.isFinite(item.investConverted) ? item.investConverted : convert(item.invest, item.curr);
              const currentConverted = Number.isFinite(item.currentConverted) ? item.currentConverted : convert(item.current, item.curr);
              if (Number.isFinite(investConverted)) {
                totalInvest += investConverted;
                cashflows.push({ date: item.dateIn, amount: -investConverted });
                if (Number.isFinite(item.months)) {
                  weightedDuration += investConverted * item.months;
                }
              }
              if (Number.isFinite(currentConverted)) {
                totalCurrent += currentConverted;
              }
              if (item.currDate && (!latestDate || item.currDate > latestDate)) {
                latestDate = item.currDate;
              }
            });
            if (Number.isFinite(totalCurrent) && latestDate) {
              cashflows.push({ date: latestDate, amount: totalCurrent });
            }
            const fundIrr = finance.xirr(cashflows);
            const pnl = totalCurrent - totalInvest;
            const weightedAvg = totalInvest > 0 ? weightedDuration / totalInvest : NaN;
            const color = getColor(name);

            const detailRows = sorted.map((item, index) => {
              const investConverted = Number.isFinite(item.investConverted) ? item.investConverted : convert(item.invest, item.curr);
              const currentConverted = Number.isFinite(item.currentConverted) ? item.currentConverted : convert(item.current, item.curr);
              const pnlConverted = Number.isFinite(item.pnlConverted) ? item.pnlConverted : (Number.isFinite(investConverted) && Number.isFinite(currentConverted) ? (currentConverted - investConverted) : NaN);
              const label = index === 0 ? 'První vklad' : 'Dokup #' + index;
              const baseDate = item.originalDateIn instanceof Date && !Number.isNaN(item.originalDateIn.valueOf()) ? item.originalDateIn : item.dateIn;
              const dateLabel = baseDate ? formatDate(baseDate) : 'N/A';
              return '<tr><td>' + label + ' <span style="color: var(--text-muted);">(' + dateLabel + ')</span></td>' +
                '<td>' + cellNum(investConverted, 0) + '</td>' +
                '<td style="color:' + (pnlConverted >= 0 ? '#34d399' : '#f87171') + ';">' + cellNum(pnlConverted, 0) + '</td>' +
                '<td>' + cellPct(item.ret) + '</td>' +
                '<td>' + (Number.isFinite(item.months) ? cellNum(item.months, 1) + ' měs.' : '—') + '</td>' +
                '<td>' + (Number.isFinite(item.irr) ? cellPct(item.irr) + ' p.a.' : '—') + '</td></tr>';
            }).join('');

            const latestLabel = latestDate ? formatDate(latestDate) : 'N/A';
            const fundCard = '<article class="fund-card">' +
              '<div class="fund-header">' +
              '<div class="fund-name"><span style="width: 12px; height: 12px; border-radius: 999px; background:' + color + ';"></span>' + name + '</div>' +
              '<div class="disclosure">Aktualizováno k ' + latestLabel + '</div>' +
              '</div>' +
              '<div class="fund-metrics">' +
              '<div><span class="fund-metric-label">Aktuální hodnota</span><div class="fund-metric-value">' + cellNum(totalCurrent, 0) + '</div></div>' +
              '<div><span class="fund-metric-label">Celkový zisk / ztráta</span><div class="fund-metric-value" style="color:' + (pnl >= 0 ? '#34d399' : '#f87171') + ';">' + cellNum(pnl, 0) + '</div></div>' +
              '<div><span class="fund-metric-label">Výkonnost (XIRR)</span><div class="fund-metric-value" style="color:' + (Number.isFinite(fundIrr) && fundIrr >= 0 ? '#34d399' : '#f87171') + ';">' + (Number.isFinite(fundIrr) ? cellPct(fundIrr) + ' p.a.' : '—') + '</div></div>' +
              '<div><span class="fund-metric-label">Váž. prům. doba</span><div class="fund-metric-value">' + (Number.isFinite(weightedAvg) ? cellNum(weightedAvg, 1) + ' měs.' : '—') + '</div></div>' +
              '</div>' +
              '<div style="overflow-x: auto; margin-top: 12px;">
                <table class="fund-details">
                  <thead><tr><th>Transakce</th><th>Investice</th><th>Výnos</th><th>Kumulativně</th><th>Doba</th><th>XIRR</th></tr></thead>
                  <tbody>' + detailRows + '</tbody>
                </table>
              </div>' +
              '</article>';
            fragments.push(fundCard);
          });
          fundsContainer.innerHTML = fragments.join('');
        }
      }

      const lineChartContainer = document.getElementById('client-line-chart');
      const pieContainer = document.getElementById('client-pie-chart');
      const pieSlider = document.getElementById('client-pie-slider');
      const pieStart = document.getElementById('client-pie-start');
      const pieCurrent = document.getElementById('client-pie-current');
      const pieEnd = document.getElementById('client-pie-end');
      const tooltip = document.getElementById('chart-tooltip');

      const positionTooltip = (event) => {
        if (!tooltip) return;
        const padding = 18;
        let left = event.clientX + padding;
        let top = event.clientY - padding;
        if (left + tooltip.offsetWidth > window.innerWidth) {
          left = event.clientX - tooltip.offsetWidth - padding;
        }
        if (top < padding) {
          top = event.clientY + padding;
        }
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
      };

      document.addEventListener('mousemove', positionTooltip);

      const showTooltip = (content) => {
        if (!tooltip) return;
        tooltip.innerHTML = content;
        tooltip.classList.add('show');
      };
      const hideTooltip = () => {
        if (!tooltip) return;
        tooltip.classList.remove('show');
      };

      const renderLineChart = () => {
        if (!lineChartContainer) return;
        lineChartContainer.innerHTML = '';
        const deposits = funds.map((item) => ({
          date: item.dateIn,
          amount: Number.isFinite(item.investConverted) ? item.investConverted : convert(item.invest, item.curr),
          fund: item.fund
        })).filter((item) => item.date instanceof Date && !Number.isNaN(item.date.valueOf()) && Number.isFinite(item.amount)).sort((a, b) => a.date - b.date);
        if (!deposits.length) {
          lineChartContainer.innerHTML = '<div class="disclosure">Pro vykreslení grafu jsou potřeba platné transakce.</div>';
          return;
        }

        const portfolioIrr = Number.isFinite(summary.portfolioIrr) ? summary.portfolioIrr : 0;
        const dailyRate = Math.pow(1 + portfolioIrr, 1 / 365.25) - 1;
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const firstDate = deposits[0].date;
        const futureEndDate = new Date(CHART_END_YEAR + '-12-31');
        const totalTimeSpan = futureEndDate - firstDate;
        if (totalTimeSpan <= 0) {
          lineChartContainer.innerHTML = '<div class="disclosure">Projekci lze zobrazit pouze při delším časovém horizontu.</div>';
          return;
        }

        const width = lineChartContainer.clientWidth || 860;
        const height = 360;
        const margin = { top: 24, right: 24, bottom: 56, left: 70 };
        const boundedWidth = width - margin.left - margin.right;
        const boundedHeight = height - margin.top - margin.bottom;

        const allPoints = [];
        let runningValue = 0;
        let lastDate = firstDate;
        let cumulativeContributions = 0;
        allPoints.push({ date: firstDate, value: 0, contributions: 0 });
        deposits.forEach((deposit) => {
          const daysSinceLast = (deposit.date - lastDate) / MS_PER_DAY;
          if (daysSinceLast > 0) {
            runningValue *= Math.pow(1 + dailyRate, daysSinceLast);
            allPoints.push({ date: deposit.date, value: runningValue, contributions: cumulativeContributions });
          }
          runningValue += deposit.amount;
          cumulativeContributions += deposit.amount;
          allPoints.push({ date: deposit.date, value: runningValue, contributions: cumulativeContributions });
          lastDate = deposit.date;
        });
        const valueAtToday = runningValue * Math.pow(1 + dailyRate, (today - lastDate) / MS_PER_DAY);
        allPoints.push({ date: today, value: valueAtToday, contributions: cumulativeContributions });

        const projectionPoints = [{ date: today, value: valueAtToday }];
        for (let year = today.getFullYear() + 1; year <= CHART_END_YEAR; year++) {
          const date = new Date(year + '-12-31');
          const projectedValue = valueAtToday * Math.pow(1 + dailyRate, (date - today) / MS_PER_DAY);
          projectionPoints.push({ date, value: projectedValue });
        }

        const maxValue = Math.max(...allPoints.map((p) => p.value), ...projectionPoints.map((p) => p.value));
        const yMax = Math.ceil((maxValue || 100000) / 100000) * 100000;
        const xScale = (date) => margin.left + ((date - firstDate) / totalTimeSpan) * boundedWidth;
        const yScale = (value) => margin.top + boundedHeight - (value / yMax) * boundedHeight;
        const xToDate = (x) => {
          const clamped = Math.min(Math.max(x, margin.left), margin.left + boundedWidth);
          const ratio = (clamped - margin.left) / boundedWidth;
          return new Date(firstDate.getTime() + ratio * totalTimeSpan);
        };

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        svg.style.width = '100%';
        svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);

        const parts = [];
        const yTicks = 5;
        for (let i = 0; i <= yTicks; i++) {
          const value = (yMax / yTicks) * i;
          const y = yScale(value);
          parts.push('<line x1="' + margin.left + '" y1="' + y + '" x2="' + (width - margin.right) + '" y2="' + y + '" stroke="rgba(148,163,184,0.25)" stroke-dasharray="2 3"></line>');
          parts.push('<text x="' + (margin.left - 10) + '" y="' + (y + 4) + '" fill="rgba(148,163,184,0.75)" font-size="11" text-anchor="end">' + cellNum(value / 1000000, 1) + ' M</text>');
        }
        for (let year = firstDate.getFullYear(); year <= CHART_END_YEAR; year += 2) {
          const date = new Date(year + '-01-01');
          const x = xScale(date);
          parts.push('<text x="' + x + '" y="' + (height - 22) + '" fill="rgba(148,163,184,0.75)" font-size="11" text-anchor="middle">' + year + '</text>');
        }

        const historicalPoints = allPoints.filter((p) => p.date <= today);
        const contributionPath = 'M' + historicalPoints.map((p) => xScale(p.date) + ',' + yScale(p.contributions)).join(' L');
        const valuePath = 'M' + historicalPoints.map((p) => xScale(p.date) + ',' + yScale(p.value)).join(' L');
        const projectionPath = 'M' + projectionPoints.map((p) => xScale(p.date) + ',' + yScale(p.value)).join(' L');
        parts.push('<path d="' + contributionPath + '" fill="none" stroke="rgba(148,163,184,0.35)" stroke-width="2"></path>');
        parts.push('<path d="' + valuePath + '" fill="none" stroke="#34d399" stroke-width="2.5"></path>');
        parts.push('<path d="' + projectionPath + '" fill="none" stroke="#34d399" stroke-width="2.5" stroke-dasharray="5 5"></path>');

        const xToday = xScale(today);
        const yToday = yScale(valueAtToday);
        parts.push('<line x1="' + xToday + '" y1="' + margin.top + '" x2="' + xToday + '" y2="' + (height - margin.bottom) + '" stroke="#38bdf8" stroke-width="1.5"></line>');
        parts.push('<circle cx="' + xToday + '" cy="' + yToday + '" r="5" fill="#38bdf8" stroke="#0f172a" stroke-width="2" data-tooltip-text="Dopočítaná hodnota: ' + cellNum(valueAtToday, 0) + ' ' + outCurr + '"></circle>');

        const snapPoints = [{
          x: xToday,
          y: yToday,
          date: today,
          value: valueAtToday,
          isToday: true,
          tooltip: '<div><strong>Dnes</strong></div><div>Hodnota: ' + cellNum(valueAtToday, 0) + ' ' + outCurr + '</div>'
        }];
        const depositsByDay = deposits.reduce((acc, deposit) => {
          const key = deposit.date.toISOString().split('T')[0];
          if (!acc[key]) acc[key] = { date: deposit.date, entries: [] };
          acc[key].entries.push(deposit);
          return acc;
        }, {});
        const sortedDays = Object.values(depositsByDay).sort((a, b) => a.date - b.date);
        let runningValueForDots = 0;
        let lastDateForDots = firstDate;
        sortedDays.forEach((day) => {
          const daysSinceLast = (day.date - lastDateForDots) / MS_PER_DAY;
          if (daysSinceLast > 0) {
            runningValueForDots *= Math.pow(1 + dailyRate, daysSinceLast);
          }
          const daySum = day.entries.reduce((sum, entry) => sum + entry.amount, 0);
          runningValueForDots += daySum;
          const x = xScale(day.date);
          const y = yScale(runningValueForDots);
          let tooltipText = '';
          if (day.entries.length > 1) {
            tooltipText = '<div><strong>Vklady (' + formatDate(day.date) + ')</strong></div>' + day.entries.map((entry) => '<div>' + entry.fund + ': ' + cellNum(entry.amount, 0) + ' ' + outCurr + '</div>').join('');
          } else {
            const entry = day.entries[0];
            tooltipText = '<div><strong>' + entry.fund + '</strong></div><div>Vklad: ' + cellNum(entry.amount, 0) + ' ' + outCurr + '</div><div>' + formatDate(day.date) + '</div>';
          }
          parts.push('<circle class="line-chart-dot" cx="' + x + '" cy="' + y + '" r="4" fill="#38bdf8" data-tooltip-text="' + tooltipText.replace(/"/g, '&quot;') + '"></circle>');
          snapPoints.push({
            x,
            y,
            date: day.date,
            value: runningValueForDots,
            tooltip: tooltipText
          });
          lastDateForDots = day.date;
        });

        svg.innerHTML = parts.join('');

        const interactionLayer = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        interactionLayer.setAttribute('x', margin.left);
        interactionLayer.setAttribute('y', margin.top);
        interactionLayer.setAttribute('width', boundedWidth);
        interactionLayer.setAttribute('height', boundedHeight);
        interactionLayer.setAttribute('fill', 'transparent');

        const guideLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        guideLine.setAttribute('stroke', 'rgba(148,163,184,0.5)');
        guideLine.setAttribute('stroke-width', '1');
        guideLine.style.opacity = 0;

        const guideCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        guideCircle.setAttribute('r', '4');
        guideCircle.setAttribute('fill', '#38bdf8');
        guideCircle.style.opacity = 0;

        svg.appendChild(guideLine);
        svg.appendChild(guideCircle);
        svg.appendChild(interactionLayer);

        const timelinePoints = [...historicalPoints, ...projectionPoints];

        interactionLayer.addEventListener('mousemove', (event) => {
          const rect = svg.getBoundingClientRect();
          const mouseX = event.clientX - rect.left;
          const snapThreshold = 18;
          let closest = null;
          let minDistance = snapThreshold;
          snapPoints.forEach((point) => {
            const distance = Math.abs(mouseX - point.x);
            if (distance < minDistance) {
              minDistance = distance;
              closest = point;
            }
          });

          let finalX = mouseX;
          let finalY = null;
          let tooltipContent = '';

          if (closest) {
            finalX = closest.x;
            finalY = closest.y;
            tooltipContent = closest.tooltip;
          } else {
            const targetDate = xToDate(mouseX);
            let prevPoint = timelinePoints[0];
            let nextPoint = timelinePoints[timelinePoints.length - 1];
            for (let i = 1; i < timelinePoints.length; i += 1) {
              if (timelinePoints[i].date >= targetDate) {
                nextPoint = timelinePoints[i];
                prevPoint = timelinePoints[i - 1] || timelinePoints[i];
                break;
              }
            }
            const totalSpan = nextPoint.date - prevPoint.date;
            let interpolatedValue = nextPoint.value;
            if (totalSpan > 0) {
              const position = (targetDate - prevPoint.date) / totalSpan;
              interpolatedValue = prevPoint.value + position * (nextPoint.value - prevPoint.value);
            }
            finalY = yScale(interpolatedValue);
            finalX = xScale(targetDate);
            tooltipContent = '<div><strong>' + formatDate(targetDate) + '</strong></div>' +
              '<div>Hodnota: ' + cellNum(interpolatedValue, 0) + ' ' + outCurr + '</div>';
          }

          if (finalY !== null) {
            guideLine.setAttribute('x1', finalX);
            guideLine.setAttribute('x2', finalX);
            guideLine.setAttribute('y1', margin.top);
            guideLine.setAttribute('y2', height - margin.bottom);
            guideCircle.setAttribute('cx', finalX);
            guideCircle.setAttribute('cy', finalY);
            guideLine.style.opacity = 1;
            guideCircle.style.opacity = 1;
            showTooltip(tooltipContent);
          }
        });
        interactionLayer.addEventListener('mouseleave', () => {
          guideLine.style.opacity = 0;
          guideCircle.style.opacity = 0;
          hideTooltip();
        });

        svg.addEventListener('mouseover', (event) => {
          const target = event.target;
          if (target && target.dataset && target.dataset.tooltipText) {
            showTooltip(target.dataset.tooltipText.replace(/&quot;/g, '"'));
          }
        });
        svg.addEventListener('mouseout', (event) => {
          const target = event.target;
          if (target && target.dataset && target.dataset.tooltipText) {
            hideTooltip();
          }
        });

        lineChartContainer.appendChild(svg);
      };

      const setupPieSlider = () => {
        if (!pieSlider || !pieContainer || !funds.length) {
          if (pieContainer) {
            pieContainer.innerHTML = '<div class="disclosure">Pro zobrazení alokace nejsou k dispozici data.</div>';
          }
          return;
        }
        const sortedDates = funds.map((item) => item.dateIn).filter(Boolean).sort((a, b) => a - b);
        if (!sortedDates.length) {
          pieContainer.innerHTML = '<div class="disclosure">Chybí data o načasování investic.</div>';
          return;
        }
        const firstDate = sortedDates[0];
        const endDate = new Date(CHART_END_YEAR + '-12-31');
        pieSlider.min = firstDate.getTime();
        pieSlider.max = endDate.getTime();
        const sliderMax = Number(pieSlider.max);
        const defaultValue = Number.isFinite(sliderMax) ? Math.min(Date.now(), sliderMax) : Date.now();
        pieSlider.value = defaultValue;
        if (pieStart) pieStart.textContent = formatDate(firstDate);
        if (pieEnd) pieEnd.textContent = formatDate(endDate);
        updatePieChart();
        pieSlider.addEventListener('input', updatePieChart);
      };

      const updatePieChart = () => {
        if (!pieSlider || !pieContainer) return;
        const currentDate = new Date(parseInt(pieSlider.value, 10));
        if (pieCurrent) pieCurrent.textContent = formatDate(currentDate);

        const grouped = funds.reduce((acc, item) => {
          if (!item.fund || !(item.dateIn instanceof Date) || item.dateIn > currentDate) return acc;
          if (!acc[item.fund]) {
            acc[item.fund] = { investments: [], irr: null };
          }
          acc[item.fund].investments.push(item);
          if (Number.isFinite(item.irr)) {
            acc[item.fund].irr = item.irr;
          }
          return acc;
        }, {});

        const slices = Object.entries(grouped).map(([name, group]) => {
          const investments = group.investments.slice().sort((a, b) => a.dateIn - b.dateIn);
          if (!investments.length) return null;

          const cashflows = investments.map((inv) => {
            const convertedInvest = Number.isFinite(inv.investConverted) ? inv.investConverted : convert(inv.invest, inv.curr);
            if (!Number.isFinite(convertedInvest)) return null;
            return { date: inv.dateIn, amount: -convertedInvest };
          }).filter(Boolean).sort((a, b) => a.date - b.date);

          let value = 0;
          const fundIrr = Number.isFinite(group.irr) ? group.irr : (Number.isFinite(investments[0]?.irr) ? investments[0].irr : NaN);

          if (cashflows.length && Number.isFinite(fundIrr) && fundIrr > -1) {
            const dailyRate = Math.pow(1 + fundIrr, 1 / 365.25) - 1;
            let runningValue = 0;
            let lastDate = cashflows[0].date;
            cashflows.forEach((cf) => {
              const days = (cf.date - lastDate) / MS_PER_DAY;
              if (Number.isFinite(days) && days > 0) {
                runningValue *= Math.pow(1 + dailyRate, days);
              }
              runningValue += -cf.amount;
              lastDate = cf.date;
            });
            const daysFinal = (currentDate - lastDate) / MS_PER_DAY;
            value = runningValue * Math.pow(1 + dailyRate, Math.max(0, daysFinal));
          } else {
            investments.forEach((inv) => {
              const currentConverted = Number.isFinite(inv.currentConverted) ? inv.currentConverted : convert(inv.current, inv.curr);
              if (Number.isFinite(currentConverted)) {
                value += currentConverted;
              }
            });
          }

          return Number.isFinite(value) && value > 0 ? { name, value } : null;
        }).filter(Boolean);

        renderPieChart(slices);
      };

      const renderPieChart = (dataSet) => {
        pieContainer.innerHTML = '';
        if (!dataSet.length) {
          pieContainer.innerHTML = '<div class="disclosure">V zadaný den nejsou k dispozici data.</div>';
          return;
        }
        const total = dataSet.reduce((sum, slice) => sum + slice.value, 0);
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', '0 0 100 100');
        let angle = -90;
        dataSet.forEach((slice) => {
          const percent = slice.value / total;
          const start = (angle * Math.PI) / 180;
          angle += percent * 360;
          const end = (angle * Math.PI) / 180;
          const outerR = 46;
          const innerR = 24;
          const x1 = 50 + outerR * Math.cos(start);
          const y1 = 50 + outerR * Math.sin(start);
          const x2 = 50 + outerR * Math.cos(end);
          const y2 = 50 + outerR * Math.sin(end);
          const x3 = 50 + innerR * Math.cos(end);
          const y3 = 50 + innerR * Math.sin(end);
          const x4 = 50 + innerR * Math.cos(start);
          const y4 = 50 + innerR * Math.sin(start);
          const largeArc = percent > 0.5 ? 1 : 0;
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', 'M ' + x1 + ',' + y1 + ' A ' + outerR + ',' + outerR + ' 0 ' + largeArc + ',1 ' + x2 + ',' + y2 + ' L ' + x3 + ',' + y3 + ' A ' + innerR + ',' + innerR + ' 0 ' + largeArc + ',0 ' + x4 + ',' + y4 + ' Z');
          const color = getColor(slice.name);
          path.setAttribute('fill', color);
          path.setAttribute('stroke', '#0f172a');
          path.setAttribute('stroke-width', '1.5');
          const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          group.classList.add('pie-segment');
          group.dataset.name = slice.name;
          group.dataset.value = cellNum(slice.value, 0) + ' ' + outCurr;
          group.dataset.percent = cellPct(slice.value / total);
          group.appendChild(path);
          svg.appendChild(group);
        });

        const legend = document.createElement('div');
        legend.style.display = 'grid';
        legend.style.gap = '12px';
        dataSet.forEach((slice) => {
          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.gap = '10px';
          row.innerHTML = '<span style="width:12px;height:12px;border-radius:999px;background:' + getColor(slice.name) + ';"></span>' +
            '<span style="flex:1;">' + slice.name + '</span>' +
            '<span style="font-weight:600;">' + cellPct(slice.value / total) + '</span>';
          legend.appendChild(row);
        });

        const wrapper = document.createElement('div');
        wrapper.style.display = 'grid';
        wrapper.style.gap = '24px';
        wrapper.appendChild(svg);
        wrapper.appendChild(legend);
        pieContainer.appendChild(wrapper);

        pieContainer.querySelectorAll('.pie-segment').forEach((segment) => {
          segment.addEventListener('mouseover', () => {
            showTooltip('<div><strong>' + segment.dataset.name + '</strong></div><div>' + segment.dataset.value + '</div><div>' + segment.dataset.percent + '</div>');
          });
          segment.addEventListener('mouseout', hideTooltip);
        });
      };

      renderLineChart();
      setupPieSlider();
    })();
  <\/script>
</body>
</html>`;

      html = html.replace('id="summary-total-invest">—', `id="summary-total-invest">${investDisplay}`);
      html = html.replace('id="summary-total-current">—', `id="summary-total-current">${currentDisplay}`);
      html = html.replace('id="summary-total-pnl">—', `id="summary-total-pnl"${pnlStyle}>${pnlDisplay}`);
      html = html.replace('id="summary-total-ret">—', `id="summary-total-ret"${retStyle}>${retDisplay}`);
      html = html.replace('id="summary-irr">—', `id="summary-irr"${irrStyle}>${irrDisplay}`);
      html = html.replace('id="summary-duration">—', `id="summary-duration">${durationDisplay}`);
      html = html.replace('id="summary-currency-note">Částky v CZK', `id="summary-currency-note">${currencyNote}`);
      html = html.replace('id="funds-currency">—', `id="funds-currency">${outCurr}`);
      html = html.replace('id="report-currency">—', `id="report-currency">${outCurr}`);
      html = html.replace('id="report-client-name">—', `id="report-client-name">${escapeHtml(clientLabel)}`);
      html = html.replace('id="report-generated-at">—', `id="report-generated-at">${escapeHtml(generatedAtLabel)}`);
      html = html.replace('<div id="client-funds-container" class="space-y-4"></div>', `<div id="client-funds-container" class="space-y-4">${fundsMarkup}</div>`);
      html = html.replace('<div id="client-line-chart" style="margin-top: 24px; min-height: 340px;"></div>', `<div id="client-line-chart" style="margin-top: 24px; min-height: 340px;">${lineChartSafe}</div>`);
      html = html.replace('<div id="client-pie-chart" style="margin-top: 18px;"></div>', `<div id="client-pie-chart" style="margin-top: 18px;">${pieChartSafe}</div>`);
      html = html.replace('id="portfolio-date-note"></div>', `id="portfolio-date-note">${escapeHtml(dateNote)}</div>`);
      html = html.replace('id="client-pie-start">—', `id="client-pie-start">${sliderStartLabel}`);
      html = html.replace('id="client-pie-end">—', `id="client-pie-end">${sliderEndLabel}`);
      return html;
  };

  const createProviderSection = (providerKey) => {
      const providerName = PROVIDERS[providerKey];
      const isAtris = providerKey === 'atris';
      let specialTooltip = '';
      if(isAtris) {
          specialTooltip = `<div class="relative group"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-teal-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg><div class="absolute bottom-full mb-2 w-64 bg-white text-slate-600 text-xs rounded-lg py-2 px-3 opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-10 border border-teal-100 shadow-lg">Upozornění: Pro fondy ATRIS se jako datum zainvestování pro výpočet použije 5. den následujícího měsíce po datu připsání.</div></div>`;
      }
      const section = document.createElement('section');
      section.className = 'card p-7 sm:p-8 space-y-6';
      section.innerHTML = `<div class="flex flex-col gap-4 md:flex-row md:items-start md:justify-between"><div class="space-y-1.5"><h2 class="text-xl font-semibold text-slate-900 flex items-center gap-2"><span>Vstupy – ${providerName.replace('&', '&amp;')}</span>${specialTooltip}</h2><p class="text-sm text-slate-500">Spravujte transakce a sledujte výkonnost jednotlivých fondů.</p></div><div class="flex flex-wrap gap-2 text-sm"><button data-provider="${providerKey}" data-action="add-row" type="button" class="primary-btn px-4 py-2 rounded-xl text-sm font-medium flex items-center gap-2"><span>+ Přidat řádek</span></button><button data-provider="${providerKey}" data-action="add-sample" type="button" class="secondary-btn px-4 py-2 rounded-xl text-sm font-medium">Ukázka</button><button data-provider="${providerKey}" data-action="delete-all" type="button" class="danger-btn px-4 py-2 rounded-xl text-sm font-medium">Smazat vše</button></div></div><div class="overflow-x-auto rounded-2xl border border-teal-100/80 bg-white/80"><table class="w-full text-sm border-separate border-spacing-x-2 text-slate-600"><thead><tr class="text-xs uppercase tracking-[0.18em] text-slate-400"><th class="py-3 pr-3 font-semibold text-left w-[260px]">Fond</th><th class="py-3 pr-3 font-semibold text-right">Čistá investice</th><th class="py-3 pr-3 font-semibold text-left">Datum připsání</th><th class="py-3 pr-3 font-semibold text-right">Počet CP</th><th class="py-3 pr-3 font-semibold text-right border-l border-slate-200/70">Upis. NAV</th><th class="py-3 pr-3 font-semibold text-right">Poslední NAV</th><th class="py-3 pr-3 font-semibold text-right">Aktuální hodnota</th><th class="py-3 pr-3 font-semibold text-left border-l border-slate-200/70">Datum ocenění</th><th class="py-3 pr-3 font-semibold text-left">Měna</th><th class="py-3 font-semibold w-[60px]"></th></tr></thead><tbody data-tbody-for="${providerKey}"></tbody></table></div>`;
      return section;
  };
  const createInputRow = (providerKey, rowData) => {
      const tr = document.createElement('tr');
      tr.className = 'fade-in';
      tr.dataset.id = rowData.id;
      const nameCell = document.createElement('td');
      nameCell.className = 'py-1 pr-3';
      const nameWrap = document.createElement('div');
      nameWrap.className = 'relative flex items-center';
      const nameDiv = document.createElement('div');
      nameDiv.contentEditable = true;
      nameDiv.className = 'editable flex-1 min-w-0 px-2.5 py-1.5 rounded-lg border border-slate-200/70 bg-white focus:border-teal-500 focus:ring-1 focus:ring-teal-400 shadow-sm';
      nameDiv.textContent = rowData.fund || '';
      nameDiv.dataset.ph = 'Název fondu...';
      nameDiv.dataset.key = 'fund';
      nameWrap.appendChild(nameDiv);
      nameCell.appendChild(nameWrap);
      const createCell = (content) => { const td = document.createElement('td'); td.className = 'py-1 align-middle'; td.appendChild(content); return td; };
      const createInput = (key, type, extraClass = '') => {
          const input = document.createElement('input');
          input.type = type;
          input.className = `glass-input px-2.5 py-1.5 rounded-lg border w-full focus:border-teal-500 focus:ring-1 focus:ring-teal-400 transition-all text-slate-900 placeholder:text-slate-400 ${extraClass}`;
          let displayValue = rowData[key] || '';
          if (['invest', 'totalCurrent'].includes(key)) {
              const num = utils.numCZ(displayValue);
              if (isFinite(num)) {
                  displayValue = fmt0.format(num);
              }
          }
          input.value = displayValue;
          if (type === 'text' && key.toLowerCase().includes('date')) { input.placeholder = 'dd.mm.rrrr'; }
          input.dataset.key = key;
          return input;
      };
      const createSelect = (key) => {
          const select = document.createElement('select');
          select.className = 'glass-input px-2.5 py-1.5 rounded-lg border w-full bg-white text-slate-900 focus:border-teal-500 focus:ring-1 focus:ring-teal-400';
          select.dataset.key = key;
          ['CZK', 'EUR'].forEach(c => {
              const option = document.createElement('option');
              option.value = c;
              option.textContent = c;
              if (c === rowData[key]) option.selected = true;
              select.appendChild(option);
          });
          return select;
      };
      const delBtnCell = document.createElement('td');
      delBtnCell.className = 'py-1 text-right';
      const delBtn = document.createElement('button');
      delBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>`;
      delBtn.className = 'p-1.5 text-slate-400 hover:text-rose-600 hover:bg-rose-50 rounded-lg transition-colors';
      delBtn.title = "Smazat řádek";
      delBtn.dataset.action = 'delete-row';
      delBtn.dataset.id = rowData.id;
      delBtn.dataset.provider = providerKey;
      delBtnCell.appendChild(delBtn);
      tr.append(
          nameCell,
          createCell(createInput('invest', 'text', 'tabular text-right')),
          createCell(createInput('dateIn', 'text')),
          createCell(createInput('qty', 'text', 'tabular text-right')),
          createCell(createInput('issueNav', 'text', 'tabular text-right border-l border-slate-200/70')),
          createCell(createInput('currNav', 'text', 'tabular text-right')),
          createCell(createInput('totalCurrent', 'text', 'tabular text-right')),
          createCell(createInput('currDate', 'text', 'border-l border-slate-200/70')),
          createCell(createSelect('curr')),
          delBtnCell
      );
      return tr;
  };
  const renderProviderInputs = (providerKey, newRowId = null) => {
      const tbody = document.querySelector(`[data-tbody-for="${providerKey}"]`);
      if (!tbody) return;
      const fragment = document.createDocumentFragment();
      state.rows[providerKey].forEach(row => { fragment.appendChild(createInputRow(providerKey, row)); });
      tbody.innerHTML = '';
      tbody.appendChild(fragment);
      if (newRowId) {
          const newRowEl = tbody.querySelector(`[data-id="${newRowId}"]`);
          if (newRowEl) { newRowEl.querySelector('[data-key="fund"]').focus(); }
      }
  };
  const renderAllInputs = () => { Object.keys(PROVIDERS).forEach(key => renderProviderInputs(key)); };

  const parseRow = r => ({
      id: r.id,
      fund: utils.normName(r.fund),
      invest: utils.numCZ(r.invest),
      totalCurrent: utils.numCZ(r.totalCurrent),
      dateIn: utils.toDate(r.dateIn),
      qty: utils.numCZ(r.qty),
      issueNav: utils.numCZ(r.issueNav),
      currNav: utils.numCZ(r.currNav),
      currDate: utils.toDate(r.currDate),
      curr: r.curr || 'CZK',
  });
  const getRowStatus = (p) => {
      let missing = [];
      let conflicts = [];
      const hasTotalPath = isFinite(p.invest) && p.invest > 0 && isFinite(p.totalCurrent) && p.totalCurrent > 0 && p.dateIn && p.currDate;
      const hasUnitPath = isFinite(p.issueNav) && p.issueNav > 0 && isFinite(p.currNav) && p.currNav > 0 && (isFinite(p.qty) || isFinite(p.invest)) && p.dateIn && p.currDate;
      if (!p.fund) missing.push('název fondu');
      if (!p.dateIn) missing.push('datum připsání');
      if (!p.currDate) missing.push('datum ocenění');
      if (!hasTotalPath && !hasUnitPath) missing.push('min. vstupů');
      const calculatedInvest = p.qty * p.issueNav;
      if(isFinite(p.invest) && isFinite(calculatedInvest) && Math.abs(p.invest - calculatedInvest) > 1e-2) conflicts.push(`Investice ≠ Počet CP × Upis. NAV`);
      const calculatedCurrent = p.qty * p.currNav;
      if(isFinite(p.totalCurrent) && isFinite(calculatedCurrent) && Math.abs(p.totalCurrent - calculatedCurrent) > 1e-2) conflicts.push(`Akt. hodnota ≠ Počet CP × Posl. NAV`);
      if (conflicts.length > 0) return ['conflict', conflicts.join('; ')];
      if (missing.length > 0) return ['error', `Chybějící pole: ${missing.join(', ')}`];
      return ['ok', ''];
  };
  const processAllRows = () => {
      const processedFunds = [];
      const allCurrencies = new Set();
      Object.entries(state.rows).forEach(([providerKey, providerRows]) => {
          providerRows.forEach(rawRow => {
              allCurrencies.add(rawRow.curr || 'CZK');
              let p = parseRow(rawRow);
              const [status, _] = getRowStatus(p);
              if (status === 'error') return;
              let effectiveDateIn = p.dateIn;
              if (providerKey === 'atris' && p.dateIn) {
                  effectiveDateIn = new Date(p.dateIn.getFullYear(), p.dateIn.getMonth() + 1, 5);
              }
              let invest = p.invest;
              let qty = p.qty;
              let current = p.totalCurrent;
              if (!isFinite(qty) && isFinite(p.invest) && isFinite(p.issueNav) && p.issueNav > 0) qty = p.invest / p.issueNav;
              if (!isFinite(invest) && isFinite(p.qty) && isFinite(p.issueNav) && p.issueNav > 0) invest = p.qty * p.issueNav;
              if (!isFinite(current) && isFinite(qty) && isFinite(p.currNav) && p.currNav > 0) current = qty * p.currNav;
              if (!isFinite(invest) || !isFinite(current) || !effectiveDateIn || !p.currDate) return;
              const months = utils.monthsDiff(effectiveDateIn, p.currDate);
              const ret = (isFinite(invest) && invest > 0 && isFinite(current)) ? (current / invest - 1) : NaN;
              const irr = (isFinite(invest) && isFinite(current) && effectiveDateIn && p.currDate) ? finance.xirr([{ date: effectiveDateIn, amount: -invest }, { date: p.currDate, amount: current }]) : NaN;
              processedFunds.push({
                  ...p,
                  invest, qty, current,
                  pnl: isFinite(invest) && isFinite(current) ? current - invest : NaN,
                  ret, months, irr,
                  dateIn: effectiveDateIn,
                  originalDateIn: p.dateIn
              });
          });
      });
      const { funds, hasMixedCurrencies: hasMixed } = { funds: processedFunds, hasMixedCurrencies: allCurrencies.size > 1 };
      const outCurr = elements.outCurrency?.value || 'CZK';
      const fxRate = utils.numCZ(elements.fxRate?.value);
      const portfolioSummary = calculateSummary(funds, outCurr, fxRate);
      state.lastProcessedData = { funds, hasMixedCurrencies: hasMixed, portfolioSummary };
      return state.lastProcessedData;
  };

  const performFullRecalc = () => {
    const { funds, hasMixedCurrencies, portfolioSummary } = processAllRows();
    const outCurr = elements.outCurrency?.value || 'CZK';
    const fxRate = utils.numCZ(elements.fxRate?.value);
    const statusContainer = elements.statusContainer || document.getElementById('status-container');
    if (statusContainer) {
      if (hasMixedCurrencies && !isFinite(fxRate)) {
        statusContainer.innerHTML = `<div class="rounded-2xl border border-teal-100 bg-teal-50 p-5 text-sm text-teal-900/80 shadow-sm"><strong class="text-teal-900">Chybějící kurz:</strong> Pro správné zobrazení výsledků v cílové měně ${outCurr} je potřeba vyplnit směnný kurz EUR/CZK.</div>`;
      } else {
        statusContainer.innerHTML = '';
      }
    }
    renderResults(funds, outCurr, fxRate, hasMixedCurrencies, portfolioSummary);
    calculateAnnuity();
    return { funds, hasMixedCurrencies, portfolioSummary, outCurr, fxRate };
  };

  const recalculateAndRender = () => {
    performFullRecalc();
  };
  const renderResults = (funds, outCurr, fxRate, hasMixedCurrencies, portfolioSummary) => {
    const convert = (amt, from) => utils.convertAmount(amt, from, outCurr, fxRate);
    const groupedFunds = funds.reduce((acc, f) => { if(!f.fund) return acc; const key = f.fund; if (!acc[key]) acc[key] = []; acc[key].push(f); return acc; }, {});
    Object.values(groupedFunds).forEach(group => group.sort((a, b) => a.dateIn - b.dateIn));
    Object.keys(groupedFunds).forEach(name => getColor(name));
    renderFundsByCard(groupedFunds, outCurr, fxRate);
    renderSummary(portfolioSummary, outCurr);
    renderCharts(groupedFunds, outCurr, fxRate, hasMixedCurrencies, funds, portfolioSummary.portfolioIrr);
  };

  const calculateSummary = (funds, outCurr, fxRate) => {
    const convert = (amt, from) => utils.convertAmount(amt, from, outCurr, fxRate);
    let totalInvestConverted = 0, totalCurrentConverted = 0;
    let cfsForIrr = [];
    let latestDate = null;
    let weightedDurationSum = 0;
    let minValuationDate = null;
    let maxValuationDate = null;
    funds.forEach(r => {
        const convertedInvest = convert(r.invest, r.curr);
        const convertedCurrent = convert(r.current, r.curr);
        if (isFinite(convertedInvest)) {
            totalInvestConverted += convertedInvest;
            cfsForIrr.push({ date: r.dateIn, amount: -convertedInvest });
            if (isFinite(r.months)) {
                weightedDurationSum += convertedInvest * r.months;
            }
        }
        if (isFinite(convertedCurrent)) {
            totalCurrentConverted += convertedCurrent;
        }
        if (r.currDate) {
            if (!minValuationDate || r.currDate < minValuationDate) minValuationDate = r.currDate;
            if (!maxValuationDate || r.currDate > maxValuationDate) maxValuationDate = r.currDate;
        }
        if (r.currDate && (!latestDate || r.currDate > latestDate)) {
            latestDate = r.currDate;
        }
    });
    if (isFinite(totalCurrentConverted) && latestDate) {
        cfsForIrr.push({ date: latestDate, amount: totalCurrentConverted });
    }
    const totalPnl = totalCurrentConverted - totalInvestConverted;
    const totalRet = totalInvestConverted > 0 ? (totalPnl / totalInvestConverted) : NaN;
    const portfolioIrr = finance.xirr(cfsForIrr);
    const weightedAvgMonths = totalInvestConverted > 0 ? weightedDurationSum / totalInvestConverted : NaN;
    return {
        totalInvestConverted, totalCurrentConverted, totalPnl, totalRet, portfolioIrr, weightedAvgMonths,
        minValuationDate, maxValuationDate,
        hasData: totalInvestConverted > 0 || totalCurrentConverted > 0
    };
  };

  const renderFundsByCard = (groupedFunds, outCurr, fxRate) => {
      const container = elements.fundsContainer || document.getElementById('funds-by-card-container');
      if (!container) return;
      container.innerHTML = "";
      if (elements.amountNoteFunds) {
          elements.amountNoteFunds.textContent = `Částky v ${outCurr}`;
      }
      const convert = (amt, from) => utils.convertAmount(amt, from, outCurr, fxRate);
      if (Object.keys(groupedFunds).length === 0) {
          container.innerHTML = `<div class="rounded-2xl border border-slate-200/60 bg-white/70 py-10 text-center text-slate-500">Nejsou k dispozici žádná data pro výpočet.</div>`;
          return;
      }
      Object.entries(groupedFunds).forEach(([name, investments]) => {
          let totalInvest = 0, totalCurrent = 0, weightedDurationSum = 0;
          const cfs = [];
          investments.forEach(inv => {
              const invConverted = convert(inv.invest, inv.curr);
              const currConverted = convert(inv.current, inv.curr);
              if(isFinite(invConverted)) {
                  totalInvest += invConverted;
                  cfs.push({date: inv.dateIn, amount: -invConverted});
                  if(isFinite(inv.months)) {
                      weightedDurationSum += invConverted * inv.months;
                  }
              }
              if(isFinite(currConverted)) {
                  totalCurrent += currConverted;
              }
          });
          const latestDate = investments.reduce((max, i) => i.currDate && i.currDate > max ? i.currDate : max, new Date(0));
          if (isFinite(totalCurrent) && investments.length > 0 && latestDate.getTime() > 0) {
              cfs.push({date: latestDate, amount: totalCurrent});
          }
          const fundIrr = finance.xirr(cfs);
          const pnl = totalCurrent - totalInvest;
          const weightedAvgMonths = totalInvest > 0 ? weightedDurationSum / totalInvest : NaN;
          const pnlClass = pnl >= 0 ? 'text-emerald-600' : 'text-rose-600';
          const fundColor = getColor(name);
          const detailsRows = investments.map((r, i) => {
              const convertedCurrent = convert(r.current, r.curr);
              const convertedInvest = convert(r.invest, r.curr);
              const convertedPnl = isFinite(convertedCurrent) && isFinite(convertedInvest) ? convertedCurrent - convertedInvest : NaN;
              const displayDate = r.originalDateIn || r.dateIn;
              return `<tr class="border-t border-slate-100"><td class="py-2 pr-3 text-slate-600">${i === 0 ? 'První vklad' : `Dokup #${i}`} <span class="text-slate-400">(${displayDate ? displayDate.toLocaleDateString('cs-CZ') : 'N/A'})</span></td><td class="py-2 pr-3 text-right tabular text-slate-700">${cellNum(convertedInvest)}</td><td class="py-2 pr-3 text-right tabular ${convertedPnl >= 0 ? 'text-emerald-600' : 'text-rose-600'}">${cellNum(convertedPnl)}</td><td class="py-2 pr-3 text-right tabular text-slate-700">${cellPct(r.ret)}</td><td class="py-2 pr-3 text-right tabular text-slate-700">${isFinite(r.months) ? cellNum(r.months, 1) + ' měs.' : '—'}</td><td class="py-2 pr-3 text-right tabular text-slate-700">${isFinite(r.irr) ? cellPct(r.irr) + ' p.a.' : '—'}</td></tr>`;
          }).join('');
          const card = document.createElement('div');
          card.className = "card overflow-hidden";
          card.innerHTML = `
              <div class="grid grid-cols-2 md:grid-cols-6 gap-x-6 gap-y-4 p-5 sm:p-6 items-start">
                  <div class="col-span-2">
                    <div class="text-xs uppercase tracking-[0.2em] text-slate-400">Fond</div>
                    <div class="mt-2 font-semibold text-lg text-slate-900 flex items-center gap-3">
                      <span class="inline-flex h-2.5 w-2.5 rounded-full" style="background-color: ${fundColor}"></span>
                      <span class="truncate" title="${name}">${name}</span>
                    </div>
                  </div>
                  <div>
                    <div class="text-xs uppercase tracking-[0.2em] text-slate-400">Aktuální hodnota</div>
                    <div class="mt-2 font-semibold tabular text-base text-slate-900">${cellNum(totalCurrent)}</div>
                    <div class="text-xs text-slate-400">k ${latestDate.getTime() > 0 ? latestDate.toLocaleDateString('cs-CZ') : 'N/A'}</div>
                  </div>
                  <div>
                    <div class="text-xs uppercase tracking-[0.2em] text-slate-400">Čistý výsledek</div>
                    <div class="mt-2 font-semibold tabular text-base ${pnlClass}">${cellNum(pnl)}</div>
                  </div>
                  <div>
                    <div class="text-xs uppercase tracking-[0.2em] text-slate-400">Výkonnost (XIRR)</div>
                    <div class="mt-2 font-semibold tabular text-base ${isFinite(fundIrr) && fundIrr >= 0 ? 'text-emerald-600' : 'text-rose-600'}">${isFinite(fundIrr) ? cellPct(fundIrr) + ' p.a.' : '—'}</div>
                  </div>
                  <div>
                    <div class="text-xs uppercase tracking-[0.2em] text-slate-400">Váž. prům. doba</div>
                    <div class="mt-2 font-semibold tabular text-base text-slate-900">${isFinite(weightedAvgMonths) ? cellNum(weightedAvgMonths, 1) + ' měs.' : '—'}</div>
                  </div>
              </div>
              <details>
                <summary class="text-xs text-slate-500 hover:text-slate-700 cursor-pointer px-5 py-3 bg-slate-50 border-t border-slate-100 flex items-center gap-2">Zobrazit transakce <svg class="summary-arrow w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clip-rule="evenodd" /></svg></summary>
                <div class="px-5 pb-5"><table class="w-full text-sm"><thead><tr class="text-left text-slate-500"><th class="py-2 pr-3 font-semibold">Transakce</th><th class="py-2 pr-3 font-semibold text-right">Investice</th><th class="py-2 pr-3 font-semibold text-right">Výnos</th><th class="py-2 pr-3 font-semibold text-right">Kumulativně</th><th class="py-2 pr-3 font-semibold text-right">Doba (měs.)</th><th class="py-2 pr-3 font-semibold text-right">XIRR p.a.</th></tr></thead><tbody>${detailsRows}</tbody></table></div>
              </details>`;
          container.appendChild(card);
      });
  };
  const renderSummary = (summaryData, outCurr) => {
    const summaryContainer = elements.portfolioSummary || document.getElementById('portfolio-summary-content'); 
    if (elements.amountNotePortfolio) {
        elements.amountNotePortfolio.textContent = `Částky v ${outCurr}`;
    }
    if (!summaryContainer) return;
    if (!summaryData.hasData) {
        summaryContainer.innerHTML = `<div class="rounded-2xl border border-slate-200/60 bg-white/70 py-10 text-center text-slate-500">Žádná data pro souhrn.</div>`;
        return;
    }
    const { totalInvestConverted, totalCurrentConverted, totalPnl, totalRet, portfolioIrr, weightedAvgMonths, minValuationDate, maxValuationDate } = summaryData;
    const pnlClass = totalPnl >= 0 ? 'text-emerald-600' : 'text-rose-600';
    let dateDisclaimer = '';
    if (minValuationDate && maxValuationDate) {
        const minStr = minValuationDate.toLocaleDateString('cs-CZ');
        const maxStr = maxValuationDate.toLocaleDateString('cs-CZ');
        if (minStr === maxStr) {
            dateDisclaimer = `Hodnoty jsou platné k ${maxStr}.`;
        } else {
            dateDisclaimer = `Hodnoty jsou platné k posledním známým datům v rozmezí ${minStr} – ${maxStr}.`;
        }
    }
    summaryContainer.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="space-y-4"><div class="flex justify-between items-baseline pb-3 border-b border-slate-200/70"><span class="text-slate-500">Celkové vklady</span><span class="font-medium tabular text-lg text-slate-900">${cellNum(totalInvestConverted)}</span></div><div class="flex justify-between items-baseline pb-3 border-b border-slate-200/70"><span class="text-slate-500">Aktuální hodnota</span><span class="font-medium tabular text-lg text-slate-900">${cellNum(totalCurrentConverted)}</span></div><div class="flex justify-between items-baseline"><span class="text-slate-500">Čistý zisk / ztráta</span><span class="font-semibold tabular text-lg ${pnlClass}">${cellNum(totalPnl)}</span></div></div><div class="space-y-4"><div class="flex justify-between items-baseline pb-3 border-b border-slate-200/70"><span class="text-slate-500">Kumulativní zhodnocení</span><span class="font-semibold tabular text-lg ${pnlClass}">${cellPct(totalRet)}</span></div><div class="flex justify-between items-baseline pb-3 border-b border-slate-200/70"><span class="text-slate-500">XIRR (časově vážený výnos)</span><span class="font-bold tabular text-lg ${isFinite(portfolioIrr) && portfolioIrr >= 0 ? 'text-emerald-600' : 'text-rose-600'}">${isFinite(portfolioIrr) ? cellPct(portfolioIrr) + ' p.a.' : '—'}</span></div><div class="flex justify-between items-baseline"><span class="text-slate-500">Vážená prům. doba investice</span><span class="font-medium tabular text-lg text-slate-900">${isFinite(weightedAvgMonths) ? `${cellNum(weightedAvgMonths, 1)} měs.` : '—'}</span></div></div></div><div class="text-xs text-slate-400 mt-4 italic">${dateDisclaimer}</div>`;
  };

  const renderCharts = (groupedFunds, outCurr, fxRate, hasMixedCurrencies, funds, portfolioIrr) => {
    const chartsSection = elements.chartsSection || document.getElementById('charts-section');
    const lineCard = elements.lineChartCard || document.getElementById('line-chart-card');
    const pieCard = elements.pieChartCard || document.getElementById('pie-chart-card');
    if (funds.length > 0) {
        lineCard.style.display = 'block';
        const lineContainer = elements.lineChartContainer || document.getElementById('line-chart-container');
        if (lineContainer) {
            renderLineChart(lineContainer, funds, portfolioIrr, outCurr, fxRate);
        }
    } else {
        lineCard.style.display = 'none';
    }
    if (!hasMixedCurrencies || isFinite(fxRate)) {
        const chartData = Object.values(groupedFunds).flat();
        if (chartData.length > 0) {
            pieCard.style.display = 'block';
            setupTimeSlider(funds);
        } else {
            pieCard.style.display = 'none';
        }
    } else {
        pieCard.style.display = 'block';
        const pieContainer = elements.pieChartContainer || document.getElementById('pie-chart-container');
        if (pieContainer) {
        pieContainer.innerHTML = `<div class="text-center py-10 text-slate-500">Pro zobrazení grafu doplňte směnný kurz.</div>`;
        }
    }
    if (chartsSection) {
        chartsSection.style.display = (pieCard.style.display === 'block' || lineCard.style.display === 'block') ? 'block' : 'none';
    }
  };

  const renderLineChart = (container, funds, portfolioIrr, outCurr, fxRate, options = {}) => {
    container.innerHTML = "";
    const convert = (amt, from) => utils.convertAmount(amt, from, outCurr, fxRate);
    const deposits = funds.map(f => ({ date: f.dateIn, amount: convert(f.invest, f.curr), fund: f.fund })).filter(d => isFinite(d.amount)).sort((a,b) => a.date - b.date);
    if (deposits.length === 0) return;
    const displayIrr = isFinite(portfolioIrr) ? portfolioIrr : 0;
    const dailyRate = Math.pow(1 + displayIrr, 1 / 365.25) - 1;
    const today = new Date(); today.setHours(0,0,0,0);
    const firstDate = deposits[0].date;
    const futureEndDate = new Date(`${CHART_END_YEAR}-12-31`);
    const totalTimeSpan = futureEndDate - firstDate;
    if (totalTimeSpan <= 0) {
      container.innerHTML = `<div class="text-center py-10 text-slate-500">Pro vykreslení grafu je potřeba delší časový horizont.</div>`;
      return;
    }
    const allPoints = [];
    let runningValue = 0;
    let lastDate = firstDate;
    let cumulativeContributions = 0;
    allPoints.push({ date: firstDate, value: 0, contributions: 0 });
    for (const deposit of deposits) {
      const daysSinceLast = (deposit.date - lastDate) / MS_PER_DAY;
      if (daysSinceLast > 0) {
        runningValue *= Math.pow(1 + dailyRate, daysSinceLast);
        allPoints.push({ date: deposit.date, value: runningValue, contributions: cumulativeContributions });
      }
      runningValue += deposit.amount;
      cumulativeContributions += deposit.amount;
      allPoints.push({ date: deposit.date, value: runningValue, contributions: cumulativeContributions });
      lastDate = deposit.date;
    }
    const valueAtToday = runningValue * Math.pow(1 + dailyRate, (today - lastDate) / MS_PER_DAY);
    allPoints.push({ date: today, value: valueAtToday, contributions: cumulativeContributions });
    const projectionPoints = [{ date: today, value: valueAtToday }];
    for (let year = today.getFullYear() + 1; year <= CHART_END_YEAR; year++) {
      const nextDate = new Date(year + '-12-31');
      const daysFromToday = (nextDate - today) / MS_PER_DAY;
      const projectedValue = valueAtToday * Math.pow(1 + dailyRate, daysFromToday);
      projectionPoints.push({ date: nextDate, value: projectedValue });
    }
    const width = options.isForPdf ? 800 : container.clientWidth;
    const height = 400;
    const margin = {top: 20, right: 20, bottom: 60, left: 70};
    const boundedWidth = width - margin.left - margin.right;
    const boundedHeight = height - margin.top - margin.bottom;
    const maxValue = Math.max(...allPoints.map(p => p.value), ...projectionPoints.map(p => p.value));
    const yMax = Math.ceil(maxValue / 100000) * 100000 || 100000;
    const xScale = (date) => margin.left + ((date - firstDate) / totalTimeSpan) * boundedWidth;
    const yScale = (value) => margin.top + boundedHeight - (value / yMax) * boundedHeight;
    const xToDate = (x) => new Date(firstDate.getTime() + ((x - margin.left) / boundedWidth) * totalTimeSpan);
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    let innerHTML = '';
    const yAxisTicks = 5;
    for (let i = 0; i <= yAxisTicks; i++) {
      const val = (yMax / yAxisTicks) * i;
      const y = yScale(val);
      innerHTML += `<line class="line-chart-grid-line" x1="${margin.left}" y1="${y}" x2="${width - margin.right}" y2="${y}"></line>`;
      innerHTML += `<text class="line-chart-axis-text" x="${margin.left - 10}" y="${y + 4}" text-anchor="end">${val/1000000} M</text>`;
    }
    for (let year = firstDate.getFullYear(); year <= CHART_END_YEAR; year+=2) {
      if(year < firstDate.getFullYear()) continue;
      const date = new Date(year + '-01-01');
      const x = xScale(date);
      innerHTML += `<text class="line-chart-axis-text" x="${x}" y="${height - 25}" text-anchor="middle">${year}</text>`;
    }
    const historicalPoints = allPoints.filter(p => p.date <= today);
    const contributionPath = "M" + historicalPoints.map(p => `${xScale(p.date)},${yScale(p.contributions)}`).join(" L");
    const valuePath = "M" + historicalPoints.map(p => `${xScale(p.date)},${yScale(p.value)}`).join(" L");
    const projectionPath = "M" + projectionPoints.map(p => `${xScale(p.date)},${yScale(p.value)}`).join(" L");
    innerHTML += `<path d="${contributionPath}" fill="none" stroke="#9ca3af" stroke-width="2"></path>`;
    innerHTML += `<path d="${valuePath}" fill="none" stroke="#10b981" stroke-width="2.5"></path>`;
    innerHTML += `<path d="${projectionPath}" fill="none" stroke="#10b981" stroke-width="2.5" stroke-dasharray="5 5"></path>`;
    const xToday = xScale(today);
    const snapPoints = [{x: xToday, y: yScale(valueAtToday), date: today, value: valueAtToday, isToday: true}];
    if (!options.isForPdf) {
        const depositsByDay = deposits.reduce((acc, deposit) => {
            const day = deposit.date.toISOString().split('T')[0];
            if (!acc[day]) acc[day] = { date: deposit.date, dailyDeposits: [] };
            acc[day].dailyDeposits.push(deposit);
            return acc;
        }, {});
        const sortedDays = Object.values(depositsByDay).sort((a,b) => a.date - b.date);
        let runningValueForDots = 0;
        let lastDateForDots = firstDate;
        sortedDays.forEach(dayData => {
            const daysSinceLast = (dayData.date - lastDateForDots) / MS_PER_DAY;
            if(daysSinceLast > 0){
                 runningValueForDots *= Math.pow(1 + dailyRate, daysSinceLast);
            }
            const totalDayInvestment = dayData.dailyDeposits.reduce((sum, d) => sum + d.amount, 0);
            runningValueForDots += totalDayInvestment;
            const x = xScale(dayData.date);
            const y = yScale(runningValueForDots);
            let tooltipText = '';
            if (dayData.dailyDeposits.length > 1) {
            tooltipText = `<div class="font-bold text-slate-800">Vklady (${dayData.date.toLocaleDateString('cs-CZ')})</div>` +
                    dayData.dailyDeposits.map(d => `<div class="text-sm text-slate-600">${d.fund}: ${cellNum(d.amount, 0)} ${outCurr}</div>`).join('');
            } else {
                const d = dayData.dailyDeposits[0];
                tooltipText = `<div class="text-slate-700">Vklad (${d.fund}): ${cellNum(d.amount, 0)} ${outCurr} (${d.date.toLocaleDateString('cs-CZ')})</div>`;
            }
            const escapedTooltipText = tooltipText.replace(/"/g, '&quot;');
            innerHTML += `<circle class='line-chart-dot' cx="${x}" cy="${y}" r="4" fill="#14b8a6" data-tooltip-text='${escapedTooltipText}'></circle>`;
            snapPoints.push({
                x,
                y,
                date: dayData.date,
                value: runningValueForDots,
                isDeposit: true,
                tooltipText: tooltipText
            });
            lastDateForDots = dayData.date;
        });
    }
    innerHTML += `<line x1="${xToday}" y1="${margin.top}" x2="${xToday}" y2="${height - margin.bottom}" stroke="#0f766e" stroke-width="1.5"></line>`;
    innerHTML += `<circle cx="${xToday}" cy="${yScale(valueAtToday)}" r="5" fill="#0f766e" stroke="white" stroke-width="2" data-tooltip-text="Dopočítaná hodnota ke dnešnímu dni dle XIRR: ${cellNum(valueAtToday,0)} ${outCurr}"></circle>`;
    innerHTML += `<g transform="translate(${margin.left}, ${height - 10})"><circle cx="0" cy="-4" r="4" fill="#10b981"></circle><text class="line-chart-axis-text" x="10" y="0">Hodnota</text><line x1="65" y1="-4" x2="85" y2="-4" stroke="#10b981" stroke-dasharray="3 3" stroke-width="2"></line><text class="line-chart-axis-text" x="95" y="0">Predikce</text><line x1="160" y1="-4" x2="180" y2="-4" stroke="#9ca3af" stroke-width="2"></line><text class="line-chart-axis-text" x="190" y="0">Vklady</text></g>`;
    if (options.isForPdf) {
        const fixedTooltipPoints = [ { date: today, label: 'Dnes' } ];
        const endOfYear = new Date(today.getFullYear(), 11, 31);
        if (endOfYear > today) {
            fixedTooltipPoints.push({ date: endOfYear, label: endOfYear.getFullYear().toString() });
        }
        for (let year = today.getFullYear() + 3; year <= CHART_END_YEAR; year += 3) {
            const date = new Date(year, 11, 31);
            if (date <= futureEndDate) {
                fixedTooltipPoints.push({ date, label: year.toString() });
            }
        }
        fixedTooltipPoints.forEach(point => {
            const daysFromToday = (point.date - today) / MS_PER_DAY;
            const value = valueAtToday * Math.pow(1 + dailyRate, daysFromToday);
            const x = xScale(point.date);
            const y = yScale(value);
            innerHTML += `<g transform="translate(${x}, ${y})">
                <circle r="5" fill="#0f766e" stroke="white" stroke-width="2"></circle>
                <rect x="-40" y="-35" width="80" height="20" rx="5" fill="rgba(255,255,255,0.8)"></rect>
                <text text-anchor="middle" y="-20" font-size="10px" fill="#1f2937">
                    <tspan x="0" dy="0">${point.label}: ${cellNum(value, 0)}</tspan>
                </text>
            </g>`;
        });
    }
    svg.innerHTML = innerHTML;
    if (!options.isForPdf) {
        const interactionLayer = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        interactionLayer.setAttribute('width', boundedWidth);
        interactionLayer.setAttribute('height', boundedHeight);
        interactionLayer.setAttribute('x', margin.left);
        interactionLayer.setAttribute('y', margin.top);
        interactionLayer.setAttribute('fill', 'transparent');
        const guideLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        guideLine.setAttribute('stroke', '#9ca3af');
        guideLine.setAttribute('stroke-width', '1');
        guideLine.style.opacity = 0;
        const guideCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        guideCircle.setAttribute('r', '4');
        guideCircle.setAttribute('fill', '#4b5563');
        guideCircle.style.opacity = 0;
        svg.appendChild(guideLine);
        svg.appendChild(guideCircle);
        svg.appendChild(interactionLayer);
        interactionLayer.addEventListener('mousemove', (e) => {
            const x = e.offsetX;
            const snapThreshold = 10;
            let finalX = x, finalY, finalDate, finalValue, tooltipText;
            let closestSnapPoint = null;
            let minDistance = snapThreshold;
            snapPoints.forEach(p => {
                const dist = Math.abs(x - p.x);
                if (dist < minDistance) {
                    minDistance = dist;
                    closestSnapPoint = p;
                }
            });
            if (closestSnapPoint) {
                finalX = closestSnapPoint.x;
                finalY = closestSnapPoint.y;
                finalDate = closestSnapPoint.date;
                finalValue = closestSnapPoint.value;
                if (closestSnapPoint.isToday) {
                tooltipText = `<div class="font-bold text-slate-800">Dnes: ${finalDate.toLocaleDateString('cs-CZ')}</div><div class="text-slate-600">Dopočítaná hodnota: ${cellNum(finalValue, 0)} ${outCurr}</div>`;
                } else {
                    tooltipText = closestSnapPoint.tooltipText;
                }
            } else {
                finalDate = xToDate(x);
                const fullData = [...allPoints.filter(p => p.date <= today), ...projectionPoints];
                const nextPoint = fullData.find(p => p.date > finalDate);
                const prevPoint = fullData[fullData.indexOf(nextPoint) - 1];
                if(prevPoint && nextPoint){
                    const t = (finalDate - prevPoint.date) / (nextPoint.date - prevPoint.date);
                    finalValue = prevPoint.value + t * (nextPoint.value - prevPoint.value);
                } else {
                    finalValue = allPoints[allPoints.length-1].value;
                }
                finalY = yScale(finalValue);
                tooltipText = `<div class="font-bold text-slate-800">${finalDate.toLocaleDateString('cs-CZ')}</div><div class="text-slate-600">${cellNum(finalValue, 0)} ${outCurr}</div>`;
            }
            guideLine.setAttribute('x1', finalX);
            guideLine.setAttribute('y1', finalY);
            guideLine.setAttribute('x2', finalX);
            guideLine.setAttribute('y2', height - margin.bottom);
            guideCircle.setAttribute('cx', finalX);
            guideCircle.setAttribute('cy', finalY);
            guideLine.style.opacity = 1;
            guideCircle.style.opacity = 1;
            const tooltip = elements.chartTooltip || document.getElementById('chart-tooltip');
            if (tooltip) {
                tooltip.innerHTML = tooltipText;
                tooltip.classList.remove('hidden');
            }
        });
        interactionLayer.addEventListener('mouseout', () => {
            guideLine.style.opacity = 0;
            guideCircle.style.opacity = 0;
            const tooltip = elements.chartTooltip || document.getElementById('chart-tooltip');
            tooltip?.classList.add('hidden');
        });
    }
    container.appendChild(svg);
  };

  const setupTimeSlider = (funds) => {
    const slider = elements.pieSlider || document.getElementById('pie-time-slider');
    if (!slider) return;
    const deposits = funds.map(f => f.dateIn).sort((a,b) => a - b);
    if(deposits.length === 0) return;
    const firstDate = deposits[0];
    const endDate = new Date(`${CHART_END_YEAR}-12-31`);
    const today = new Date();
    slider.min = firstDate.getTime();
    slider.max = endDate.getTime();
    if (!slider.dataset.initialized) {
        slider.value = today.getTime();
        slider.dataset.initialized = 'true';
    }
    if (elements.sliderStartLabel) {
        elements.sliderStartLabel.textContent = firstDate.toLocaleDateString('cs-CZ');
    }
    if (elements.sliderEndLabel) {
        elements.sliderEndLabel.textContent = endDate.toLocaleDateString('cs-CZ');
    }
    updatePieChartFromSlider();
  };
  const updatePieChartFromSlider = () => {
    const { funds } = state.lastProcessedData;
    const outCurr = elements.outCurrency?.value || 'CZK';
    const fxRate = utils.numCZ(elements.fxRate?.value);
    const slider = elements.pieSlider || document.getElementById('pie-time-slider');
    if (!slider) return;
    const convert = (amt, from) => utils.convertAmount(amt, from, outCurr, fxRate);
    const currentDate = new Date(parseInt(slider.value));
    if (elements.sliderCurrentLabel) {
        elements.sliderCurrentLabel.textContent = currentDate.toLocaleDateString('cs-CZ');
    }
    const dataForDate = Object.entries(funds.reduce((acc, f) => { if (!acc[f.fund]) acc[f.fund] = { investments: [], irr: null }; acc[f.fund].investments.push(f); if (isFinite(f.irr)) acc[f.fund].irr = f.irr; return acc; }, {})).map(([name, {investments, irr}]) => {
        let value = 0;
        const cfs = investments
            .filter(inv => inv.dateIn <= currentDate)
            .map(inv => ({ date: inv.dateIn, amount: -convert(inv.invest, inv.curr) }))
            .sort((a,b) => a.date - b.date);
        if (cfs.length > 0) {
            const fundIrr = investments[0]?.irr;
            if (isFinite(fundIrr)) {
                const dailyRate = Math.pow(1 + fundIrr, 1 / 365.25) - 1;
                let runningValue = 0;
                let lastDate = cfs[0].date;
                cfs.forEach(cf => {
                    const days = (cf.date - lastDate) / MS_PER_DAY;
                    runningValue *= Math.pow(1 + dailyRate, days);
                    runningValue += -cf.amount;
                    lastDate = cf.date;
                });
                const daysFinal = (currentDate - lastDate) / MS_PER_DAY;
                value = runningValue * Math.pow(1 + dailyRate, daysFinal);
            }
        }
        return { name, totalCurrent: value };
    }).filter(d => d.totalCurrent > 0);
    const pieContainer = elements.pieChartContainer || document.getElementById('pie-chart-container');
    if (pieContainer) {
        renderPieChart(pieContainer, dataForDate, outCurr);
    }
  };
  const renderPieChart = (container, data, outCurr, options = {}) => {
    container.innerHTML = '';
    if(data.length === 0) {
        container.innerHTML = `<div class="text-center py-10 text-slate-500">Pro zvolené datum nejsou data.</div>`;
        return;
    }
    const pieTotal = data.reduce((sum, d) => sum + d.totalCurrent, 0);
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute('viewBox', '0 0 100 100');
    let angle = -90; const outerRadius = 48; const innerRadius = 25;
    if (data.length === 1 && pieTotal > 0) {
        const d = data[0];
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add('pie-segment');
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute('cx', 50);
        circle.setAttribute('cy', 50);
        circle.setAttribute('r', (outerRadius + innerRadius) / 2);
        circle.setAttribute('stroke', getColor(d.name));
        circle.setAttribute('stroke-width', outerRadius - innerRadius);
        circle.setAttribute('fill', 'none');
        g.appendChild(circle);
        svg.appendChild(g);
    } else {
        data.forEach((d) => {
            const percent = d.totalCurrent / pieTotal; if (percent === 0) return;
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.classList.add('pie-segment'); g.dataset.name = d.name; g.dataset.value = `${cellNum(d.totalCurrent)} ${outCurr}`; g.dataset.percent = cellPct(d.totalCurrent / pieTotal);
            const startAngleRad = (angle * Math.PI) / 180; angle += percent * 360; const endAngleRad = (angle * Math.PI) / 180;
            const x1_outer = 50 + outerRadius * Math.cos(startAngleRad); const y1_outer = 50 + outerRadius * Math.sin(startAngleRad);
            const x2_outer = 50 + outerRadius * Math.cos(endAngleRad); const y2_outer = 50 + outerRadius * Math.sin(endAngleRad);
            const x1_inner = 50 + innerRadius * Math.cos(startAngleRad); const y1_inner = 50 + innerRadius * Math.sin(startAngleRad);
            const x2_inner = 50 + innerRadius * Math.cos(endAngleRad); const y2_inner = 50 + innerRadius * Math.sin(endAngleRad);
            const largeArc = percent > 0.5 ? 1 : 0;
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute('d', `M ${x1_outer},${y1_outer} A ${outerRadius},${outerRadius} 0 ${largeArc},1 ${x2_outer},${y2_outer} L ${x2_inner},${y2_inner} A ${innerRadius},${innerRadius} 0 ${largeArc},0 ${x1_inner},${y1_inner} Z`);
            path.setAttribute('fill', getColor(d.name)); path.setAttribute('stroke', '#fff'); path.setAttribute('stroke-width', '2');
            g.appendChild(path); svg.appendChild(g);
        });
    }
    const legend = data.map((d) => `<div class="flex items-center gap-2 text-sm"><div class="w-3 h-3 rounded-sm" style="background-color: ${getColor(d.name)}"></div><div class="flex-1 truncate" title="${d.name}">${d.name}</div><div class="font-medium tabular">${cellPct(d.totalCurrent/pieTotal)}</div></div>`).join('');
    const gridClass = options.isForPdf ? 'grid-cols-2 items-center' : 'sm:grid-cols-2';
    container.innerHTML = `<div class="grid ${gridClass} gap-6 items-center"><div class="chart-svg-wrapper"></div><div class="space-y-2">${legend}</div></div>`;
    container.querySelector('.chart-svg-wrapper').appendChild(svg);
  };

  const calculateAnnuity = () => {
      const { portfolioSummary, funds } = state.lastProcessedData;
      const { portfolioIrr, totalCurrentConverted } = portfolioSummary;
      const monthlyAnnuity = utils.numCZ(elements.annuityInput?.value);
      const resultDiv = elements.annuityResult || document.getElementById('annuity-result');
      const annualDiv = elements.annuityAnnual || document.getElementById('annuity-annual-equivalent');
      const disclaimer = elements.annuityDisclaimer || document.getElementById('annuity-disclaimer');
      if (!resultDiv || !annualDiv || !disclaimer) {
          return;
      }
      if (!isFinite(monthlyAnnuity) || monthlyAnnuity <= 0) {
          resultDiv.style.display = 'none';
          annualDiv.textContent = '';
          disclaimer.style.display = 'none';
          return;
      }
      disclaimer.style.display = 'block';
      const annualAnnuity = monthlyAnnuity * 12;
      annualDiv.textContent = `(což odpovídá ${cellNum(annualAnnuity, 0)} Kč ročně)`;
      if (!isFinite(portfolioIrr) || portfolioIrr <= 0 || funds.length === 0) {
          resultDiv.innerHTML = 'Pro výpočet renty je potřeba mít v portfoliu data s kladným zhodnocením (XIRR).';
          resultDiv.style.display = 'block';
          return;
      }
      const targetCapital = annualAnnuity / portfolioIrr;
      if (totalCurrentConverted >= targetCapital) {
          resultDiv.innerHTML = `<strong>Gratulujeme!</strong> Vaše portfolio s aktuální hodnotou <strong>${cellNum(totalCurrentConverted, 0)} Kč</strong> je již nyní dostatečně velké, aby generovalo požadovanou roční rentu.`;
          resultDiv.style.display = 'block';
          return;
      }
      const dailyRate = Math.pow(1 + portfolioIrr, 1 / 365.25) - 1;
      let days = 0;
      let futureValue = totalCurrentConverted;
      for (let i = 0; i < 365 * 100; i++) {
          futureValue *= (1 + dailyRate);
          days++;
          if (futureValue >= targetCapital) break;
      }
      if (futureValue < targetCapital) {
          resultDiv.innerHTML = `Při současném tempu růstu se Vám nepodaří dosáhnout cílové částky v rozumném časovém horizontu.`;
          resultDiv.style.display = 'block';
          return;
      }
      const targetDate = new Date();
      targetDate.setDate(targetDate.getDate() + days);
      const monthNames = ["ledna", "února", "března", "dubna", "května", "června", "července", "srpna", "září", "října", "listopadu", "prosince"];
      const formattedDate = `${monthNames[targetDate.getMonth()]} ${targetDate.getFullYear()}`;
      resultDiv.innerHTML = `Pro měsíční rentu <strong>${cellNum(monthlyAnnuity, 0)} Kč</strong> potřebujete kapitál o velikosti přibližně <strong>${cellNum(targetCapital, 0)} Kč</strong>. Při současném tempu růstu byste této částky mohli dosáhnout okolo <strong>${formattedDate}</strong>.`;
      resultDiv.style.display = 'block';
  };

  const handleInputChange = (e) => {
    const target = e.target;
    const key = target.dataset.key;
    if (!key) return;
    const tr = target.closest('tr');
    if (!tr) return;
    const id = parseInt(tr.dataset.id, 10);
    const providerKey = tr.closest('tbody').dataset.tbodyFor;
    const row = state.rows[providerKey].find(r => r.id === id);
    if (!row) return;
    if (target.type === 'checkbox') {
        row[key] = target.checked;
    } else {
        row[key] = target.isContentEditable ? target.textContent : target.value;
    }
    if (['invest', 'qty', 'issueNav', 'currNav', 'totalCurrent'].includes(key)) {
        const p = parseRow(row);
        if (isFinite(p.invest) && isFinite(p.issueNav) && p.issueNav > 0 && (!row.qty || utils.numCZ(row.qty) <= 0)) {
            row.qty = String(p.invest / p.issueNav);
            tr.querySelector('[data-key="qty"]').value = row.qty;
        } else if (isFinite(p.qty) && isFinite(p.issueNav) && p.qty > 0 && (!row.invest || utils.numCZ(row.invest) <= 0)) {
            row.invest = String(p.qty * p.issueNav);
            tr.querySelector('[data-key="invest"]').value = row.invest;
        }
        if (isFinite(p.qty) && isFinite(p.currNav) && p.currNav > 0 && (!row.totalCurrent || utils.numCZ(row.totalCurrent) <= 0)) {
             row.totalCurrent = String(p.qty * p.currNav);
             tr.querySelector('[data-key="totalCurrent"]').value = row.totalCurrent;
        }
    }
    updateInputHighlights(tr, row);
    scheduleRecalc();
    saveState();
  };

  const updateInputHighlights = (tr, row) => {
      const parsed = parseRow(row || {});
      const fields = ['invest', 'dateIn', 'qty', 'issueNav', 'currNav', 'totalCurrent', 'currDate'];
      fields.forEach(field => {
          const input = tr.querySelector(`[data-key="${field}"]`);
          if (input) input.classList.remove('input-highlight');
      });

      if (!parsed || !parsed.fund) {
          return;
      }

      const markMissing = (...keys) => {
          keys.forEach(field => {
              const input = tr.querySelector(`[data-key="${field}"]`);
              if (!input) return;
              const currentValue = row?.[field];
              if (currentValue === undefined || String(currentValue).trim() === '') {
                  input.classList.add('input-highlight');
              }
          });
      };

      if (!parsed.dateIn) markMissing('dateIn');
      if (!parsed.currDate) markMissing('currDate');

      const hasInvest = Number.isFinite(parsed.invest) && parsed.invest > 0;
      const hasQty = Number.isFinite(parsed.qty) && parsed.qty > 0;
      const hasIssueNav = Number.isFinite(parsed.issueNav) && parsed.issueNav > 0;
      const hasCurrent = Number.isFinite(parsed.totalCurrent);
      const hasNav = Number.isFinite(parsed.currNav) && parsed.currNav > 0;

      if (!hasInvest && !hasQty) {
          markMissing('invest');
      } else if (!hasInvest && hasQty && !hasIssueNav) {
          markMissing('issueNav');
      }

      if (!hasCurrent && !hasNav) {
          markMissing('currNav', 'totalCurrent');
      }
  };

  const init = () => {
    elements.fxRate = document.getElementById('fx-rate');
    elements.outCurrency = document.getElementById('out-curr');
    elements.statusContainer = document.getElementById('status-container');
    elements.toastContainer = document.getElementById('toast-container');
    elements.lastSavedIndicator = document.getElementById('last-saved-indicator');
    elements.providerSections = document.getElementById('provider-sections');
    elements.fundsContainer = document.getElementById('funds-by-card-container');
    elements.amountNoteFunds = document.getElementById('amount-note-funds');
    elements.portfolioSummary = document.getElementById('portfolio-summary-content');
    elements.amountNotePortfolio = document.getElementById('amount-note-portfolio');
    elements.lineChartCard = document.getElementById('line-chart-card');
    elements.pieChartCard = document.getElementById('pie-chart-card');
    elements.chartsSection = document.getElementById('charts-section');
    elements.lineChartContainer = document.getElementById('line-chart-container');
    elements.lineChartTitle = document.getElementById('line-chart-title');
    elements.pieChartContainer = document.getElementById('pie-chart-container');
    elements.pieSlider = document.getElementById('pie-time-slider');
    elements.sliderStartLabel = document.getElementById('slider-start-date-label');
    elements.sliderCurrentLabel = document.getElementById('slider-current-date-label');
    elements.sliderEndLabel = document.getElementById('slider-end-date-label');
    elements.annuityInput = document.getElementById('annuity-input');
    elements.annuityAnnual = document.getElementById('annuity-annual-equivalent');
    elements.annuityResult = document.getElementById('annuity-result');
    elements.annuityDisclaimer = document.getElementById('annuity-disclaimer');
    elements.chartTooltip = document.getElementById('chart-tooltip');
    elements.importFile = document.getElementById('import-file-input');
    elements.clientNameInput = document.getElementById('client-name');

    const currentYearEl = document.getElementById('current-year');
    if (currentYearEl) {
        currentYearEl.textContent = new Date().getFullYear();
    }
    if (elements.lineChartTitle) {
        elements.lineChartTitle.textContent = `Vývoj hodnoty portfolia s predikcí do roku ${CHART_END_YEAR}`;
    }

    const providerContainer = elements.providerSections;
    if (providerContainer) {
        Object.keys(PROVIDERS).forEach(key => providerContainer.appendChild(createProviderSection(key)));
    }
    document.addEventListener('click', (e) => {
        const button = e.target.closest('button[data-action]'); if (!button) return;
        const { action, provider, id } = button.dataset;
        if (action === 'add-row') { const newId = ++rowSeq; state.rows[provider].push({ id: newId, fund: '', curr: 'CZK' }); renderProviderInputs(provider, newId); }
        if (action === 'delete-row') { const rowElement = button.closest('tr'); rowElement.className = 'fade-out'; rowElement.addEventListener('animationend', () => { state.rows[provider] = state.rows[provider].filter(r => r.id !== parseInt(id,10)); rowElement.remove(); scheduleRecalc(); saveState(); }); }
        if (action === 'delete-all') { if (confirm(`Opravdu chcete smazat všechny řádky pro ${PROVIDERS[provider]}?`)) { state.rows[provider] = []; renderProviderInputs(provider); scheduleRecalc(); saveState(); } }
        if (action === 'export-json') exportState();
        if (action === 'import-json') elements.importFile?.click();
        if (action === 'export-presentation') exportClientPresentation();
        if (action === 'add-sample') {
            const today = new Date().toISOString().split('T')[0];
            const SAMPLES = {
                avant: [ { id: ++rowSeq, fund: 'r2p invest SICAV, a.s.', invest: '100000', dateIn: '15.03.2021', issueNav: '1.05', currNav: '1.25', currDate: today, curr: 'CZK' } ],
                codya: [ { id: ++rowSeq, fund: 'CODYA Real Estate Fund', invest: '250000', dateIn: '20.11.2020', issueNav: '10.0', currNav: '14.2', currDate: today, curr: 'CZK' }, { id: ++rowSeq, fund: 'CODYA Opportunity', invest: '120000', dateIn: '10.01.2023', issueNav: '100', currNav: '118', currDate: today, curr: 'CZK' } ],
                atris: [ { id: ++rowSeq, fund: 'ATRIS Global Equities', invest: '15000', dateIn: '30.05.2022', issueNav: '150', currNav: '195', currDate: today, curr: 'EUR' } ],
                jt: [ { id: ++rowSeq, fund: 'J&T Opportunity CZK', invest: '500000', dateIn: '01.07.2019', issueNav: '1.0', currNav: '1.48', currDate: today, curr: 'CZK' } ]
            };
            const sampleData = SAMPLES[provider].map(s => ({...s, qty: '', totalCurrent: ''}));
            state.rows[provider].push(...sampleData);
            renderProviderInputs(provider); scheduleRecalc(); showToast(`Ukázková data pro ${PROVIDERS[provider]} byla načtena.`); saveState();
        }
    });
    elements.fxRate?.addEventListener('input', scheduleRecalc);
    elements.outCurrency?.addEventListener('change', scheduleRecalc);
    elements.annuityInput?.addEventListener('input', calculateAnnuity);
    elements.clientNameInput?.addEventListener('input', (e) => {
        state.meta.clientName = e.target.value;
    });
    elements.clientNameInput?.addEventListener('blur', (e) => {
        const trimmed = (e.target.value || '').trim();
        if (trimmed !== e.target.value) {
            e.target.value = trimmed;
        }
        state.meta.clientName = trimmed;
        saveState();
    });
    const providerSections = elements.providerSections;
    if (providerSections) {
        providerSections.addEventListener('input', (e) => {
            if (e.target.matches('input, select')) handleInputChange(e);
        });
        providerSections.addEventListener('focusout', (e) => {
            if (e.target.isContentEditable) handleInputChange(e);
            const key = e.target.dataset.key;
            if (key === 'invest' || key === 'totalCurrent' || e.target.id === 'annuity-input') {
                const num = utils.numCZ(e.target.value);
                if (isFinite(num)) {
                    e.target.value = fmt0.format(num);
                } else {
                    e.target.value = '';
                }
            }
        });
        providerSections.addEventListener('focusin', (e) => {
            const key = e.target.dataset.key;
            if (key === 'invest' || key === 'totalCurrent' || e.target.id === 'annuity-input') {
                const num = utils.numCZ(e.target.value);
                if (isFinite(num)) {
                    e.target.value = num;
                }
            }
        });
        providerSections.addEventListener('keydown', e => { if (e.key === 'Enter' && e.target.isContentEditable) { e.preventDefault(); e.target.blur(); } });
    }
    elements.annuityInput?.addEventListener('focusin', (e) => {
        const num = utils.numCZ(e.target.value);
        if (isFinite(num)) {
            e.target.value = num;
        }
    });
    elements.annuityInput?.addEventListener('focusout', (e) => {
        const num = utils.numCZ(e.target.value);
        if (isFinite(num)) {
            e.target.value = fmt0.format(num);
        } else {
            e.target.value = '';
        }
    });
    elements.importFile?.addEventListener('change', (e) => { if (e.target.files.length > 0) { importState(e.target.files[0]); e.target.value = ''; } });
    elements.pieSlider?.addEventListener('input', updatePieChartFromSlider);
    const tooltip = elements.chartTooltip || document.getElementById('chart-tooltip');
    document.addEventListener('mousemove', e => {
        let newLeft = e.pageX + 15;
        let newTop = e.pageY + 15;
        if (tooltip.offsetWidth && newLeft + tooltip.offsetWidth > window.innerWidth) {
            newLeft = e.pageX - tooltip.offsetWidth - 15;
        }
        tooltip.style.left = `${newLeft}px`;
        tooltip.style.top = `${newTop}px`;
    });
    document.addEventListener('mouseover', e => {
        const segment = e.target.closest('.pie-segment');
        const dot = e.target.closest('.line-chart-dot, circle[data-tooltip-text]');
        if (segment) {
            tooltip.innerHTML = `<div class="font-bold text-slate-800">${segment.dataset.name}</div><div class="text-slate-600">${segment.dataset.value} (${segment.dataset.percent})</div>`;
            tooltip.classList.remove('hidden');
        } else if (dot && dot.dataset.tooltipText) {
            tooltip.innerHTML = dot.dataset.tooltipText.replace(/&quot;/g, '"');
            tooltip.classList.remove('hidden');
        }
    });
    document.addEventListener('mouseout', e => { if(e.target.closest('.pie-segment, .line-chart-dot, circle[data-tooltip-text]')) { tooltip.classList.add('hidden'); } });
    window.addEventListener('beforeunload', () => saveState(true));
    loadState();
  };
  init();
});
</script>
</body>
</html>
