<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investiční Kalkulačka</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        :root {
            color-scheme: light;
            --color-bg-start: #FDFEFF;
            --color-bg-end: #F8F9FA;
            --color-primary: #0d2c54;
            --color-accent: #4DB1C8;
            --color-text: #33373D;
            --color-muted: #888B90;
            --color-border: #EAECEE;
            --color-border-strong: #D0E0E8;
            --color-card: #FFFFFF;
            --color-shadow: 0 10px 25px -10px rgba(13, 44, 84, 0.1);
            --color-shadow-strong: 0 18px 38px -18px rgba(13, 44, 84, 0.15);
        }
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap');
        *, *::before, *::after { box-sizing: border-box; }
        body {
            font-family: 'Montserrat', ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Helvetica Neue", sans-serif;
            scroll-behavior: smooth;
            background: linear-gradient(180deg, var(--color-bg-start) 0%, var(--color-bg-end) 100%);
            color: var(--color-text);
            min-height: 100vh;
            margin: 0;
            -webkit-font-smoothing: antialiased;
        }
        a { color: inherit; text-decoration: none; }
        .tabular-nums { font-variant-numeric: tabular-nums; }
        details > summary { list-style: none; cursor: pointer; }
        details > summary::-webkit-details-marker { display: none; }
        details > summary .summary-arrow { transition: transform 0.2s ease; }
        details[open] > summary .summary-arrow { transform: rotate(90deg); }
        #toast-container { position: fixed; top: 1.5rem; right: 1.5rem; z-index: 50; display: flex; flex-direction: column; gap: 0.75rem; }
        .toast {
            display: flex;
            align-items: center;
            padding: 1rem 1.1rem;
            border-radius: 0.9rem;
            border: 1px solid var(--color-border);
            box-shadow: var(--color-shadow);
            background: var(--color-card);
            color: var(--color-text);
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.4s cubic-bezier(0.21, 1.02, 0.73, 1);
        }
        .toast.show { opacity: 1; transform: translateX(0); }
        .toast-success { border-color: rgba(77, 177, 200, 0.45); background: rgba(77, 177, 200, 0.15); color: var(--color-primary); }
        .toast-error { border-color: rgba(229, 62, 62, 0.45); background: rgba(229, 62, 62, 0.15); color: #b42318; }
        .app-shell { max-width: 1200px; margin: 0 auto; padding: 0 1.75rem; }
        @media (max-width: 640px) { .app-shell { padding: 0 1.1rem; } }
        header.brand-header { padding: 2.75rem 0 4rem; position: relative; }
        .brand-backdrop {
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(13, 44, 84, 0.08) 0%, rgba(13, 44, 84, 0) 75%);
            border-bottom-left-radius: 56px;
            border-bottom-right-radius: 56px;
        }
        .brand-header-inner { position: relative; z-index: 1; display: grid; gap: 2.5rem; }
        @media (min-width: 1024px) {
            .brand-header-inner { grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr); align-items: center; }
        }
        .brand-logo { font-weight: 700; font-size: 1.15rem; letter-spacing: 0.28em; text-transform: uppercase; color: var(--color-primary); display: inline-flex; align-items: center; gap: 0.35rem; }
        .brand-logo span { color: var(--color-accent); }
        .hero-kicker {
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            padding: 0.45rem 1rem;
            border-radius: 999px;
            background: rgba(13, 44, 84, 0.08);
            border: 1px solid rgba(13, 44, 84, 0.18);
            font-size: 0.68rem;
            letter-spacing: 0.22em;
            text-transform: uppercase;
            color: var(--color-primary);
            font-weight: 600;
        }
        .hero-title { font-size: clamp(2.25rem, 5vw, 3.4rem); font-weight: 700; letter-spacing: -0.02em; margin: 1rem 0 1.25rem; color: var(--color-primary); text-transform: uppercase; }
        .hero-description { font-size: 1rem; line-height: 1.7; max-width: 560px; color: rgba(51, 55, 61, 0.78); }
        .hero-card-stack { display: grid; gap: 1.25rem; }
        .surface-card {
            background: var(--color-card);
            border-radius: 1.5rem;
            border: 1px solid var(--color-border);
            box-shadow: var(--color-shadow);
            padding: 1.9rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
        }
        .surface-card:hover { border-color: var(--color-border-strong); box-shadow: var(--color-shadow-strong); transform: translateY(-2px); }
        .surface-card small {
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            font-size: 0.7rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--color-primary);
            font-weight: 600;
        }
        .surface-card h3 { margin: 0.8rem 0 0.75rem; font-size: 1.1rem; font-weight: 600; color: var(--color-text); }
        .surface-card p { margin: 0; font-size: 0.95rem; line-height: 1.6; color: rgba(51, 55, 61, 0.75); }
        main { margin-top: -72px; position: relative; z-index: 2; }
        @media (max-width: 768px) { main { margin-top: -48px; } }
        .content-stack { display: flex; flex-direction: column; gap: 2.5rem; padding-bottom: 4.5rem; }
        .card-section { background: var(--color-card); border-radius: 1.5rem; border: 1px solid var(--color-border); box-shadow: var(--color-shadow); padding: clamp(1.65rem, 2.5vw, 2.5rem); transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        .card-section:hover { border-color: var(--color-border-strong); box-shadow: var(--color-shadow-strong); }
        .card-header { display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1.5rem; }
        @media (min-width: 768px) { .card-header { flex-direction: row; justify-content: space-between; align-items: flex-start; } }
        .card-header-title { font-size: 1.35rem; font-weight: 600; letter-spacing: -0.01em; color: var(--color-primary); text-transform: uppercase; }
        .card-header-sub { font-size: 0.95rem; color: rgba(51, 55, 61, 0.75); max-width: 580px; }
        .badge-pill { display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.35rem 0.85rem; border-radius: 999px; background: rgba(13, 44, 84, 0.08); border: 1px solid rgba(13, 44, 84, 0.18); font-size: 0.68rem; letter-spacing: 0.22em; text-transform: uppercase; color: var(--color-primary); font-weight: 600; }
        .meta-deck { display: flex; flex-wrap: wrap; gap: 0.75rem; }
        .meta-card { border: 1px solid var(--color-border); background: rgba(255, 255, 255, 0.72); border-radius: 0.9rem; padding: 0.75rem 1rem; color: var(--color-primary); display: flex; flex-direction: column; gap: 0.35rem; min-width: 190px; box-shadow: var(--color-shadow); }
        .meta-label { font-size: 0.65rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--color-muted); font-weight: 600; }
        .meta-value { font-size: 0.95rem; font-weight: 600; color: var(--color-primary); }
        .meta-card .input { width: 100%; }
        .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.45rem; padding: 0.65rem 1.35rem; border-radius: 0.9rem; font-weight: 600; font-size: 0.85rem; letter-spacing: 0.01em; cursor: pointer; border: 1px solid transparent; transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background-color 0.2s ease; }
        .btn:hover { transform: translateY(-2px); }
        .btn-primary { background: var(--color-primary); border-color: var(--color-primary); color: #fff; box-shadow: var(--color-shadow); }
        .btn-primary:hover { background: #0a2344; box-shadow: var(--color-shadow-strong); }
        .btn-secondary { background: rgba(77, 177, 200, 0.12); color: var(--color-primary); border-color: rgba(77, 177, 200, 0.55); }
        .btn-secondary:hover { background: rgba(77, 177, 200, 0.2); border-color: var(--color-accent); box-shadow: var(--color-shadow); }
        .btn-secondary.active { background: var(--color-primary); color: #fff; border-color: var(--color-primary); box-shadow: var(--color-shadow-strong); }
        .btn-danger { background: rgba(229, 62, 62, 0.12); color: #b42318; border-color: rgba(229, 62, 62, 0.35); }
        .btn-danger:hover { background: rgba(229, 62, 62, 0.18); box-shadow: var(--color-shadow); }
        .control-bar { display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; }
        .input, select { font-family: inherit; border-radius: 0.9rem; border: 1px solid var(--color-border); padding: 0.55rem 0.9rem; background: rgba(255, 255, 255, 0.92); transition: border-color 0.2s ease, box-shadow 0.2s ease; font-size: 0.9rem; color: var(--color-text); }
        .input:focus, select:focus { outline: none; border-color: var(--color-accent); box-shadow: 0 0 0 3px rgba(77, 177, 200, 0.25); }
        .input::placeholder { color: var(--color-muted); }
        .input-ghost { background: rgba(255,255,255,0.6); }
        .icon-button { width: 2.25rem; height: 2.25rem; border-radius: 50%; border: 1px solid var(--color-border); background: rgba(255, 255, 255, 0.9); color: var(--color-muted); display: inline-flex; align-items: center; justify-content: center; transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease, background-color 0.2s ease; }
        .icon-button:hover { border-color: var(--color-border-strong); color: #b42318; background: rgba(229, 62, 62, 0.12); box-shadow: var(--color-shadow); }
        table { width: 100%; border-collapse: separate; border-spacing: 0; }
        thead th { font-size: 0.75rem; font-weight: 600; letter-spacing: 0.04em; text-transform: uppercase; color: var(--color-muted); padding: 0.75rem 0.75rem; border-bottom: 1px solid var(--color-border); background: rgba(253, 254, 255, 0.85); position: sticky; top: 0; z-index: 1; }
        tbody td { padding: 0.85rem 0.75rem; border-bottom: 1px solid var(--color-border); font-size: 0.9rem; color: var(--color-text); }
        tbody tr:hover { background: rgba(77, 177, 200, 0.06); }
        tbody tr:last-child td { border-bottom: none; }
        .table-actions { text-align: right; }
        .table-input { width: 100%; border-radius: 0.85rem; border: 1px solid var(--color-border); padding: 0.55rem 0.85rem; background: rgba(255, 255, 255, 0.92); font-size: 0.9rem; color: var(--color-text); transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        .table-input:focus { outline: none; border-color: var(--color-accent); box-shadow: 0 0 0 3px rgba(77, 177, 200, 0.25); }
        .table-select { width: 100%; }
        .info-grid { display: grid; gap: 1.25rem; }
        @media (min-width: 768px) { .info-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); } }
        .info-card { border: 1px solid var(--color-border); border-radius: 1.35rem; padding: 1.35rem; background: var(--color-card); box-shadow: var(--color-shadow); transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        .info-card:hover { border-color: var(--color-border-strong); box-shadow: var(--color-shadow-strong); }
        .info-card-title { font-size: 0.78rem; letter-spacing: 0.08em; text-transform: uppercase; color: var(--color-muted); font-weight: 600; }
        .info-card-value { font-size: 1.65rem; font-weight: 600; color: var(--color-primary); margin-top: 0.6rem; }
        .info-card-sub { font-size: 0.75rem; color: var(--color-muted); margin-top: 0.35rem; }
        .highlight-positive { color: #228b22; font-weight: 600; }
        .highlight-negative { color: #b42318; font-weight: 600; }
        .tooltip {
            position: absolute;
            z-index: 10;
            padding: 0.6rem 0.8rem;
            background: var(--color-card);
            border: 1px solid var(--color-border);
            box-shadow: var(--color-shadow);
            border-radius: 0.75rem;
            font-size: 0.85rem;
            color: var(--color-text);
            pointer-events: none;
            display: none;
        }
        .tooltip.show { display: block; }
        .chart-container { position: relative; height: 22rem; }
        .chart-axis-text { fill: var(--color-muted); font-size: 0.68rem; font-family: 'Montserrat', ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Helvetica Neue", sans-serif; }
        .chart-grid-line { stroke: #E5E8EE; stroke-dasharray: 2 3; }
        .chart-deposit-line { stroke: var(--color-border-strong); stroke-dasharray: 5 4; stroke-width: 2; fill: none; }
        .chart-line-accent { stroke: var(--color-accent); stroke-width: 2.6; fill: none; }
        .chart-line-primary { stroke: var(--color-primary); stroke-width: 2.4; fill: none; }
        .chart-line-danger { stroke: #E25050; stroke-width: 2.4; fill: none; }
        .chart-dot { stroke: #fff; stroke-width: 2; }
        .legend { display: flex; flex-wrap: wrap; gap: 1.2rem; margin-top: 1rem; font-size: 0.8rem; color: var(--color-muted); }
        .legend-item { display: inline-flex; align-items: center; gap: 0.35rem; }
        .legend-dot { width: 0.6rem; height: 0.6rem; border-radius: 50%; }
        .pie-legend { display: grid; gap: 0.65rem; }
        .pie-legend-item { display: flex; align-items: center; justify-content: space-between; border: 1px solid var(--color-border); border-radius: 0.9rem; padding: 0.65rem 0.85rem; background: rgba(255, 255, 255, 0.9); box-shadow: var(--color-shadow); }
        .pie-legend-name { font-weight: 600; color: var(--color-text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .pie-legend-value { color: var(--color-primary); font-weight: 600; }
        .pie-segment { cursor: pointer; transition: transform 0.2s ease, filter 0.2s ease; transform-origin: center center; }
        .pie-segment:hover { transform: scale(1.04); filter: drop-shadow(0 10px 16px rgba(13, 44, 84, 0.18)); }
        .responsive-grid-two { display: grid; gap: 2.5rem; align-items: center; }
        @media (min-width: 768px) { .responsive-grid-two { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
        .note-block { border: 1px solid var(--color-border); border-radius: 1.2rem; padding: 1.25rem; background: var(--color-card); box-shadow: var(--color-shadow); font-size: 0.9rem; color: rgba(51, 55, 61, 0.85); }
        .note-block.alert { border-color: rgba(229, 62, 62, 0.35); background: rgba(229, 62, 62, 0.08); color: #9b2c2c; }
        footer { padding: 3rem 0; color: var(--color-muted); font-size: 0.75rem; text-align: center; }
        @media (max-width: 768px) {
            .hero-description { font-size: 0.95rem; }
            .card-header { gap: 0.5rem; }
        }
        @media print {
            body { background: #fff; }
            .card-section, .surface-card, .info-card, .pie-legend-item, .note-block { box-shadow: none !important; }
            #toast-container, .tooltip { display: none !important; }
            .btn { display: none !important; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div id="toast-container"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef, Fragment } = React;

        const Y = 15; // Projection years
        const czk = new Intl.NumberFormat("cs-CZ", { style: "currency", currency: "CZK", maximumFractionDigits: 0 });
        const pct = new Intl.NumberFormat("cs-CZ", { style: "percent", minimumFractionDigits: 2, maximumFractionDigits: 2 });
        
        const parse = (v) => (typeof v === "string" ? Number(v.replace(/[^\d.,-]/g, "").replace(",", ".")) : Number(v)) || 0;
        const createFund = (name, r) => ({ id: crypto.randomUUID(), name, returnStr: String(r), amountStr: "0", amountStrY1: "0", failureYear: 0 });

        const formatRecoveryTime = (years) => {
            if (years === null) return "nedojde k zotavení";
            if (years < 0) return "ihned";
            if (years <= 0.08) return "< 1 měsíc";
            const y = Math.floor(years);
            const m = Math.round((years % 1) * 12);
            let result = [];
            if (y > 0) result.push(`${y} ${y === 1 ? "rok" : y < 5 ? "roky" : "let"}`);
            if (m > 0) result.push(`${m} ${m === 1 ? "měsíc" : m < 5 ? "měsíce" : "měsíců"}`);
            return result.length > 0 ? result.join(" a ") : "okamžitě";
        };
        
        const showToast = (message, type = 'success') => {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `<span>${message}</span>`;
            container.appendChild(toast);
            requestAnimationFrame(() => toast.classList.add('show'));
            setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000);
        };

        const MoneyInput = ({ value, onChange }) => {
            const [currentValue, setCurrentValue] = useState(value);
            const ref = useRef(null);

            useEffect(() => {
                if (document.activeElement !== ref.current) {
                    const numValue = parse(value);
                    setCurrentValue(numValue > 0 ? czk.format(numValue) : '');
                }
            }, [value]);
            
            const handleFocus = (e) => {
                const numericValue = parse(e.target.value);
                setCurrentValue(numericValue === 0 ? '' : numericValue);
            };

            const handleBlur = (e) => {
                const numericValue = parse(e.target.value);
                onChange(String(numericValue));
                setCurrentValue(numericValue > 0 ? czk.format(numericValue) : '');
            };

            const handleChange = (e) => {
                setCurrentValue(e.target.value);
            };

            return <input ref={ref} type="text" inputMode="numeric" className="table-input tabular-nums" style={{ textAlign: 'right' }} value={currentValue} onChange={handleChange} onFocus={handleFocus} onBlur={handleBlur} autoComplete="off" />;
        };

        const InfoCard = ({ title, value, subValue }) => (
            <div className="info-card">
                <div className="info-card-title">{title}</div>
                <div className="info-card-value tabular-nums">{value}</div>
                {subValue && <div className="info-card-sub">{subValue}</div>}
            </div>
        );

        const ReportHero = ({ lastSaved, clientName, onClientNameChange }) => (
            <header className="brand-header">
                <div className="brand-backdrop"></div>
                <div className="app-shell brand-header-inner">
                    <div>
                        <div className="brand-logo">Fair<span>Life</span></div>
                        <span className="hero-kicker">FKI nákup · report vizual</span>
                        <h1 className="hero-title">Investiční kalkulačka</h1>
                        <p className="hero-description">
                            Vytvářejte přehledné scénáře nákupu fondů, sdílejte výsledky s klienty a slaďte je s reportovacím vizuálem FairLife.
                        </p>
                        <div className="meta-deck" style={{ marginTop: '1.75rem' }}>
                            <label className="meta-card">
                                <span className="meta-label">Jméno klienta</span>
                                <input className="input input-ghost" value={clientName} onChange={e => onClientNameChange(e.target.value)} placeholder="Např. Jana Nováková" />
                            </label>
                            <div className="meta-card">
                                <span className="meta-label">Naposledy uloženo</span>
                                <span className="meta-value">{lastSaved ? `Dnes ${lastSaved}` : '—'}</span>
                            </div>
                            <div className="meta-card">
                                <span className="meta-label">Měna reportu</span>
                                <span className="meta-value">CZK</span>
                            </div>
                        </div>
                    </div>
                    <div className="hero-card-stack">
                        <div className="surface-card">
                            <small>Správa portfolia</small>
                            <h3>Import, export i reset v bezpečném prostoru</h3>
                            <p>
                                Automatické ukládání a strukturované exporty zjednoduší sdílení dat s klienty i interním týmem.
                            </p>
                        </div>
                        <div className="surface-card">
                            <small>Analytické nástroje</small>
                            <h3>Srovnání scénářů, grafy i simulace rizik</h3>
                            <p>
                                Sledujte vývoj výnosů, diverzifikaci portfolia a připravte se na nečekané události díky jednotnému reportovacímu vizuálu.
                            </p>
                        </div>
                    </div>
                </div>
            </header>
        );

        function App() {
            const [lastSaved, setLastSaved] = useState(null);
            const [clientName, setClientName] = useState('');

            const [codya, setCodya] = useState([
                createFund("PFFL", 7.5), createFund("Fond reverzních hypoték", 6.65), createFund("Silverline R.E.", 10), createFund("Vigo Direct", 8),
                createFund("Adax", 12), createFund("Julius Meinl fond", 14.5), createFund("Penta R.E.", 14), createFund("Penta Equity", 14),
                createFund("Artefin - Henry IF", 8.5), createFund("FČKD", 7.5)
            ]);
            const [avant, setAvant] = useState([
                createFund("r2p invest", 8.5), createFund("Gartal", 7), createFund("Realia", 6), createFund("EBM", 8), createFund("Wero", 8),
                createFund("Vihorev", 8.5), createFund("Real Luxembourg", 8), createFund("Aguila", 7.5), createFund("Spilberk", 7), createFund("Semper", 11)
            ]);
            
            const getTimeString = () => new Date().toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' });

            useEffect(() => { 
                try { 
                    const s = localStorage.getItem('investmentCalculatorState'); 
                    if (s) {
                        const d = JSON.parse(s);
                        if (d.codya) setCodya(d.codya);
                        if (d.avant) setAvant(d.avant);
                        if (d.clientName) setClientName(d.clientName);
                        showToast("Data byla úspěšně načtena.");
                    }
                    setLastSaved(getTimeString());
                } catch (e) { 
                    showToast("Nepodařilo se načíst uložená data.", 'error'); 
                } 
            }, []);
            
            useEffect(() => { 
                try { 
                    const stateToSave = { codya, avant, clientName };
                    localStorage.setItem('investmentCalculatorState', JSON.stringify(stateToSave));
                    setLastSaved(getTimeString());
                } catch (e) {
                    console.error("Failed to save state:", e);
                }
            }, [codya, avant, clientName]);

            const exportState = () => {
                try {
                    const stateToSave = { codya, avant, clientName };
                    const blob = new Blob([JSON.stringify(stateToSave, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const sanitizedClient = clientName.trim().replace(/\s+/g, '-').replace(/[^\w-]/g, '').toLowerCase();
                    const fileLabel = sanitizedClient || 'portfolio';
                    a.download = `${fileLabel}-${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast("Portfolio bylo úspěšně exportováno.");
                } catch (e) {
                    showToast("Chyba při exportu portfolia.", "error");
                    console.error("Export failed:", e);
                }
            };
            
            const importState = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedState = JSON.parse(e.target.result);
                        if (importedState.codya && importedState.avant) {
                            setCodya(importedState.codya);
                            setAvant(importedState.avant);
                            if (typeof importedState.clientName === 'string') setClientName(importedState.clientName);
                            showToast("Portfolio bylo úspěšně importováno.");
                        } else {
                            throw new Error("Invalid file structure");
                        }
                    } catch (err) {
                        showToast("Chyba při importu souboru.", "error");
                        console.error("Import failed:", err);
                    }
                };
                reader.readAsText(file);
                event.target.value = null;
            };
            
            const resetAll = () => {
                const resetAmounts = (funds) => funds.map(f => ({ ...f, amountStr: '0', amountStrY1: '0', failureYear: 0 }));
                setCodya(resetAmounts);
                setAvant(resetAmounts);
                showToast("Celé portfolio bylo vynulováno.");
            };
            
            const portfolioAnalysis = useMemo(() => {
                const allFunds = [...codya, ...avant].map(f => ({ 
                    ...f, 
                    amount: parse(f.amountStr), 
                    amountY1: parse(f.amountStrY1),
                    r: parse(f.returnStr) / 100,
                    failureYear: parseInt(f.failureYear, 10) || 0
                }));

                const initialFunds = allFunds.filter(f => f.amount > 0 || f.amountY1 > 0);
                if (initialFunds.length === 0) return { hasData: false };

                const totalInvestedInitial = allFunds.reduce((sum, f) => sum + f.amount, 0);
                const totalInvestedY1 = allFunds.reduce((sum, f) => sum + f.amountY1, 0);
                const totalInvestedWithFollowUp = totalInvestedInitial + totalInvestedY1;

                const initiallyInvestedFunds = allFunds.filter(f => f.amount > 0);
                const weightedSumInitial = initiallyInvestedFunds.reduce((sum, f) => sum + f.amount * f.r, 0);
                const weightedReturnInitial = totalInvestedInitial > 0 ? weightedSumInitial / totalInvestedInitial : 0;

                const hasFollowUpInvestment = totalInvestedY1 > 0;
                const hasFailure = allFunds.some(f => f.failureYear > 0);
                
                const projection = [];
                let totalLoss = 0;
                let failureEvents = [];
                let recoveryTime = null;

                let baselineValue = totalInvestedInitial;
                let followUp = { value: totalInvestedInitial, activeFunds: allFunds.filter(f=>f.amount > 0).map(f => ({...f, currentValue: f.amount})) };
                let failure = { value: totalInvestedInitial, activeFunds: allFunds.filter(f=>f.amount > 0).map(f => ({...f, currentValue: f.amount})) };

                for (let year = 1; year <= Y; year++) {
                    const yearData = { year };

                    const baselineStart = baselineValue;
                    const baselineInterest = baselineStart * weightedReturnInitial;
                    baselineValue += baselineInterest;
                    yearData.baseline = { start: baselineStart, interest: baselineInterest, end: baselineValue };

                    ['followUp', 'failure'].forEach(type => {
                        const scenario = type === 'followUp' ? followUp : failure;
                        const start = scenario.value;

                        const currentRate = start > 0 ? scenario.activeFunds.reduce((s,f) => s + (f.currentValue/start) * f.r, 0) : 0;
                        const interest = start * currentRate;
                        scenario.activeFunds.forEach(f => { f.currentValue *= (1 + f.r); });
                        
                        if (year === 1 && totalInvestedY1 > 0) {
                             allFunds.forEach(origF => {
                                if(origF.amountY1 > 0){
                                    const existing = scenario.activeFunds.find(af => af.id === origF.id);
                                    if(existing) {
                                        existing.currentValue += origF.amountY1;
                                    } else {
                                        scenario.activeFunds.push({...origF, currentValue: origF.amountY1});
                                    }
                                }
                           });
                        }
                        const valueAfterDeposit = scenario.activeFunds.reduce((s,f) => s+f.currentValue, 0);

                        let loss = 0;
                        let valueBeforeCrash = valueAfterDeposit;
                        if (type === 'failure' && hasFailure) {
                            const failingThisYear = scenario.activeFunds.filter(f => f.failureYear === year);
                            if (failingThisYear.length > 0) {
                                loss = failingThisYear.reduce((s,f) => s + f.currentValue, 0);
                                totalLoss += loss;
                                failureEvents.push({ year, loss });
                                scenario.activeFunds = scenario.activeFunds.filter(f => f.failureYear !== year);
                            }
                        }
                        
                        scenario.value = scenario.activeFunds.reduce((s,f) => s+f.currentValue, 0);
                        yearData[type] = { start, interest, end: scenario.value, loss, valueBeforeCrash };
                    });

                    projection.push(yearData);
                }

                if (hasFailure) {
                    let lastYearBelowInvestment = -1;
                    let lastCrashYearBeforeRecovery = -1;
                    projection.forEach(p => {
                        if (p.failure.end < totalInvestedWithFollowUp) {
                            lastYearBelowInvestment = p.year;
                            const relevantCrashes = failureEvents.filter(e => e.year <= p.year);
                            if(relevantCrashes.length > 0) {
                                lastCrashYearBeforeRecovery = Math.max(...relevantCrashes.map(e => e.year));
                            }
                        }
                    });
                    if (lastYearBelowInvestment !== -1 && lastCrashYearBeforeRecovery !== -1) {
                         for (let i = lastYearBelowInvestment - 1; i < projection.length; i++) {
                            const pCurrent = projection[i];
                            const pPrev = projection[i-1] || { failure: { end: totalInvestedInitial }};
                            if(pPrev.failure.end < totalInvestedWithFollowUp && pCurrent.failure.end >= totalInvestedWithFollowUp){
                                const needed = totalInvestedWithFollowUp - pPrev.failure.end;
                                const gain = pCurrent.failure.end - pPrev.failure.end;
                                const partial = gain > 0 ? needed / gain : 0;
                                recoveryTime = (pCurrent.year - lastCrashYearBeforeRecovery) + partial;
                                break;
                            }
                         }
                    } else if(totalInvestedInitial > 0 && projection[0] && projection[0].failure.end >= totalInvestedWithFollowUp){
                       recoveryTime = 0;
                    }
                }
                
                const investedFundsInitial = allFunds.filter(f => f.amount > 0).map(f => ({ name: f.name, amount: f.amount }));
                const fundsAfterY1 = allFunds.map(f => {
                    let amountAfterY1 = (f.amount * (1 + (projection[0]?.baseline.interest / projection[0]?.baseline.start || 0) )) + f.amountY1;
                    return { name: f.name, amount: amountAfterY1 };
                }).filter(f => f.amount > 0);

                const weightedReturnAfterY1 = projection[1] ? projection[1].followUp.interest / projection[1].followUp.start : weightedReturnInitial;

                return {
                    hasData: true, totalInvestedInitial, weightedReturnInitial,
                    hasFollowUpInvestment, totalInvestedWithFollowUp, weightedReturnAfterY1,
                    hasFailure, totalLoss, recoveryTime, failureEvents,
                    projection, 
                    investedFundsInitial, fundsAfterY1
                };
            }, [codya, avant]);
            
            return (
                <Fragment>
                    <ReportHero lastSaved={lastSaved} clientName={clientName} onClientNameChange={setClientName} />
                    <main>
                        <div className="app-shell content-stack">
                            <DataManagement
                                onExport={exportState}
                                onImport={importState}
                                onReset={resetAll}
                                lastSaved={lastSaved}
                                clientName={clientName}
                            />
                            <Summary analysis={portfolioAnalysis} clientName={clientName} />
                            <Group title="CODYA" list={codya} setList={setCodya} portfolioTotal={portfolioAnalysis.totalInvestedInitial || 0} />
                            <Group title="AVANT" list={avant} setList={setAvant} portfolioTotal={portfolioAnalysis.totalInvestedInitial || 0} />
                            <LineChart analysis={portfolioAnalysis} />
                            <PieChart analysis={portfolioAnalysis} />
                            <ProjectionTable analysis={portfolioAnalysis} />
                            <AnnuityCalculator analysis={portfolioAnalysis} />
                            <section className="card-section">
                                <details>
                                    <summary style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '0.85rem 1rem', borderRadius: '1rem', border: '1px solid var(--color-border)', background: 'rgba(77,177,200,0.08)', fontWeight: 600, color: 'var(--color-primary)' }}>
                                        <span>Vysvětlivky a použité metriky</span>
                                        <svg className="summary-arrow" width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clipRule="evenodd" /></svg>
                                    </summary>
                                    <div className="note-block" style={{ marginTop: '1rem' }}>
                                        <h4 style={{ marginBottom: '0.75rem', fontWeight: 600, color: 'var(--color-primary)' }}>Co je to vážené průměrné zhodnocení?</h4>
                                        <p style={{ fontSize: '0.9rem', color: 'var(--color-text)' }}>Jedná se o průměrné očekávané zhodnocení celého portfolia. Výpočet zohledňuje, jak velká část portfolia je v jednotlivých fondech. Fond, do kterého jste investovali více peněz, má na výsledný průměr větší vliv.</p>
                                    </div>
                                </details>
                            </section>
                        </div>
                    </main>
                    <footer className="app-shell" style={{ paddingBottom: '3rem', textAlign: 'center', fontSize: '0.75rem', color: 'var(--color-muted)' }}>
                        © {new Date().getFullYear()} Ondřej Lacina · Nástroj slouží pouze pro ilustrativní účely.
                    </footer>
                </Fragment>
            );
        }

        const DataManagement = ({ onExport, onImport, onReset, lastSaved, clientName }) => {
            const fileInputRef = useRef(null);
            const todayIso = new Date().toISOString().slice(0, 10);
            const sanitizedClient = clientName.trim().replace(/\s+/g, '-').replace(/[^\w-]/g, '').toLowerCase();
            const exportPreview = `${sanitizedClient || 'portfolio'}-${todayIso}.json`;
            return (
                <section className="card-section">
                    <input type="file" ref={fileInputRef} onChange={onImport} accept=".json" style={{ display: 'none' }} />
                    <div className="card-header">
                        <div>
                            <span className="badge-pill">Správa dat</span>
                            <h2 className="card-header-title">Synchronizujte portfolio během vteřiny</h2>
                            <p className="card-header-sub">
                                Importujte aktuální stav investic, sdílejte klientům exporty a udržujte historii bezpečně uloženou v prohlížeči.
                            </p>
                        </div>
                        <div className="control-bar">
                            <button onClick={onExport} className="btn btn-primary">Exportovat .json</button>
                            <button onClick={() => fileInputRef.current?.click()} className="btn btn-secondary">Importovat .json</button>
                            <button onClick={onReset} className="btn btn-danger">Reset portfolia</button>
                        </div>
                    </div>
                    <div className="info-grid" style={{ marginTop: '1.75rem' }}>
                        <div className="note-block">
                            <strong style={{ display: 'block', fontSize: '0.68rem', letterSpacing: '0.2em', textTransform: 'uppercase', color: 'var(--color-primary)', marginBottom: '0.6rem' }}>
                                Tip pro prezentaci
                            </strong>
                            Změny se ukládají automaticky. Export si můžete stáhnout pro potřeby klienta nebo interní archivaci.
                        </div>
                        <div className="note-block">
                            <div className="meta-label" style={{ marginBottom: '0.5rem' }}>Poslední synchronizace</div>
                            <div className="meta-value">{lastSaved || 'Čeká na první záznam'}</div>
                        </div>
                        <div className="note-block">
                            <div className="meta-label" style={{ marginBottom: '0.5rem' }}>Název exportu</div>
                            <div className="meta-value" style={{ textTransform: 'none' }}>{exportPreview}</div>
                        </div>
                    </div>
                </section>
            );
        };
        
        const SegmentSummary = ({ analysis, title }) => {
            if (!analysis || !analysis.hasData) return null;
            const { totalInvested, weightedReturn } = analysis;
            return (
                <div style={{ marginTop: '1.75rem' }}>
                    <span className="badge-pill">Souhrn {title}</span>
                    <div className="info-grid" style={{ marginTop: '1rem' }}>
                        <InfoCard title={`Investováno v ${title}`} value={czk.format(totalInvested)} />
                        <InfoCard title="Očekávaný roční výnos" value={pct.format(weightedReturn)} />
                    </div>
                </div>
            );
        };

        const Group = ({ title, list, setList, portfolioTotal }) => {
            const add = () => setList(p => [...p, createFund("Nový fond", 5)]);
            const remove = (id) => setList(p => p.filter(f => f.id !== id));
            const reset = () => setList(p => p.map(f => ({...f, amountStr: '0', amountStrY1: '0', failureYear: 0})));
            const patchFund = (id, patch) => setList(p => p.map(f => f.id === id ? { ...f, ...patch } : f));

            const handleDemo = () => {
                 let demoData;
                const codyaDemoFunds = ["PFFL", "Silverline R.E.", "Adax", "Penta R.E."];
                const avantDemoFunds = ["r2p invest", "Vihorev", "Real Luxembourg", "Semper"];
                if (title === 'CODYA') demoData = list.map(f => codyaDemoFunds.includes(f.name) ? { ...f, amountStr: '250000' } : { ...f, amountStr: '0' });
                else if (title === 'AVANT') demoData = list.map(f => avantDemoFunds.includes(f.name) ? { ...f, amountStr: '250000' } : { ...f, amountStr: '0' });
                if (demoData) setList(demoData);
            };
            
            const segmentAnalysis = useMemo(() => {
                const fundsInSegment = list.map(f => ({ ...f, amount: parse(f.amountStr), r: parse(f.returnStr) / 100 }));
                const investedFunds = fundsInSegment.filter(f => f.amount > 0);
                if (investedFunds.length === 0) return { hasData: false, totalInvested: 0, weightedReturn: 0 };
                const totalInvested = investedFunds.reduce((sum, f) => sum + f.amount, 0);
                const weightedSum = investedFunds.reduce((sum, f) => sum + f.amount * f.r, 0);
                const weightedReturn = totalInvested > 0 ? weightedSum / totalInvested : 0;
                return { hasData: true, totalInvested, weightedReturn };
            }, [list]);

            const groupTotal = segmentAnalysis.totalInvested;

            return (
                <section className="card-section">
                    <div className="card-header">
                        <div>
                            <span className="badge-pill">Vstupy {title}</span>
                            <h2 className="card-header-title">Vstupy – {title}</h2>
                            <p className="card-header-sub">Spravujte transakce a sledujte výkonnost jednotlivých fondů partnerů.</p>
                        </div>
                        <div className="control-bar">
                            <button onClick={handleDemo} className="btn btn-secondary">Ukázka</button>
                            <button onClick={reset} className="btn btn-danger">Smazat vše</button>
                            <button onClick={add} className="btn btn-primary">Přidat řádek</button>
                        </div>
                    </div>
                    <div style={{ marginTop: '1.5rem', overflowX: 'auto' }}>
                        <table>
                            <thead>
                                <tr>
                                    <th style={{ minWidth: '180px' }}>Fond</th>
                                    <th style={{ minWidth: '140px' }}>Oček. zhodnocení</th>
                                    <th style={{ minWidth: '150px', textAlign: 'right' }}>Počáteční vklad</th>
                                    <th style={{ minWidth: '150px', textAlign: 'right' }}>Vklad po 1. roce</th>
                                    <th style={{ minWidth: '150px' }}>Krach po roce</th>
                                    <th style={{ minWidth: '140px', textAlign: 'right' }}>Podíl ve skupině</th>
                                    <th style={{ minWidth: '140px', textAlign: 'right' }}>Podíl v portfoliu</th>
                                    <th style={{ width: '56px' }}></th>
                                </tr>
                            </thead>
                            <tbody>
                                {list.map(f => {
                                    const amount = parse(f.amountStr);
                                    const segmentShare = groupTotal > 0 ? amount / groupTotal : 0;
                                    const portfolioShare = portfolioTotal > 0 ? amount / portfolioTotal : 0;
                                    return (
                                        <tr key={f.id}>
                                            <td>
                                                <input
                                                    className="table-input"
                                                    defaultValue={f.name}
                                                    onBlur={e => patchFund(f.id, { name: e.target.value })}
                                                />
                                            </td>
                                            <td>
                                                <div style={{ position: 'relative' }}>
                                                    <input
                                                        type="text"
                                                        inputMode="decimal"
                                                        className="table-input"
                                                        style={{ paddingRight: '2.5rem', textAlign: 'right' }}
                                                        defaultValue={f.returnStr}
                                                        onBlur={e => patchFund(f.id, { returnStr: e.target.value })}
                                                    />
                                                    <span style={{ position: 'absolute', right: '0.85rem', top: '50%', transform: 'translateY(-50%)', fontSize: '0.85rem', color: 'var(--color-muted)' }}>%</span>
                                                </div>
                                            </td>
                                            <td style={{ textAlign: 'right' }}><MoneyInput value={f.amountStr} onChange={v => patchFund(f.id, { amountStr: v })} /></td>
                                            <td style={{ textAlign: 'right' }}><MoneyInput value={f.amountStrY1} onChange={v => patchFund(f.id, { amountStrY1: v })} /></td>
                                            <td>
                                                <select
                                                    className="table-input table-select"
                                                    value={f.failureYear}
                                                    onChange={e => patchFund(f.id, { failureYear: parseInt(e.target.value, 10) })}
                                                >
                                                    <option value="0">Nikdy</option>
                                                    {Array.from({ length: Y }, (_, i) => i + 1).map(year => (
                                                        <option key={year} value={year}>Po {year}. roce</option>
                                                    ))}
                                                </select>
                                            </td>
                                            <td className="tabular-nums" style={{ textAlign: 'right' }}>{pct.format(segmentShare)}</td>
                                            <td className="tabular-nums" style={{ textAlign: 'right' }}>{pct.format(portfolioShare)}</td>
                                            <td className="table-actions">
                                                <button onClick={() => remove(f.id)} className="icon-button" aria-label="Smazat řádek">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>
                                                </button>
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                    <SegmentSummary analysis={segmentAnalysis} title={title} />
                </section>
            );
        };

        const Summary = ({ analysis, clientName }) => {
            if (!analysis.hasData) {
                return (
                    <section className="card-section">
                        <span className="badge-pill">Souhrn portfolia</span>
                        <h2 className="card-header-title" style={{ marginTop: '1rem' }}>Zadejte první investici</h2>
                        <p className="card-header-sub">Vyplňte alespoň jeden fond, aby se zobrazil souhrn včetně scénářů a projekcí.</p>
                    </section>
                );
            }

            const totalContributions = analysis.hasFollowUpInvestment ? analysis.totalInvestedWithFollowUp : analysis.totalInvestedInitial;
            const latestProjection = analysis.projection[analysis.projection.length - 1];
            const projectedValue = latestProjection ? latestProjection.baseline.end : totalContributions;
            const netGain = projectedValue - totalContributions;
            const totalReturnPct = totalContributions > 0 ? netGain / totalContributions : 0;
            const annualReturn = analysis.hasFollowUpInvestment ? analysis.weightedReturnAfterY1 : analysis.weightedReturnInitial;
            const breakEven = analysis.projection.find(p => p.baseline.end >= totalContributions);
            const horizonMonths = Math.max(1, Math.round((breakEven ? breakEven.year : Y) * 12));

            const metrics = [
                { title: 'Vaše celkové vklady', value: czk.format(totalContributions) },
                { title: 'Aktuální hodnota', value: czk.format(projectedValue) },
                { title: 'Čistý výnos', value: czk.format(netGain) },
                { title: 'Celkové zhodnocení', value: pct.format(totalReturnPct) },
                { title: 'Průměrný roční výnos', value: pct.format(annualReturn) },
                { title: 'Předpokládaná doba investice', value: `${horizonMonths} měs.` }
            ];

            const alertMessage = analysis.hasFailure
                ? 'Portfolio obsahuje simulaci krachu fondu. Sledujte níže dobu zotavení a kumulativní ztrátu.'
                : 'Souhrn vychází z aktuálně zadaných investic. Přidejte další vklady nebo aktualizujte výnosy pro přesnější projekce.';

            return (
                <section className="card-section">
                    <div className="card-header">
                        <div>
                            <span className="badge-pill">Souhrn portfolia</span>
                            <h2 className="card-header-title">Souhrn portfolia {clientName ? `· ${clientName}` : ''}</h2>
                            <p className="card-header-sub">Klíčové ukazatele, které určují celkovou velikost portfolia a výkon Vašich investic.</p>
                        </div>
                        <div className="meta-deck">
                            <div className="meta-card">
                                <span className="meta-label">Klient</span>
                                <span className="meta-value" style={{ textTransform: 'none' }}>{clientName || 'Nepřiřazeno'}</span>
                            </div>
                            <div className="meta-card">
                                <span className="meta-label">Částky</span>
                                <span className="meta-value">CZK</span>
                            </div>
                        </div>
                    </div>
                    <div className="note-block alert" style={{ marginTop: '1.5rem' }}>{alertMessage}</div>
                    <div className="info-grid" style={{ marginTop: '1.5rem' }}>
                        {metrics.map(metric => (
                            <InfoCard key={metric.title} title={metric.title} value={metric.value} />
                        ))}
                    </div>
                    <div className="info-grid" style={{ marginTop: '1.75rem' }}>
                        <div className="note-block" style={{ borderColor: 'var(--color-border)', background: 'rgba(255,255,255,0.95)' }}>
                            <div className="meta-label" style={{ marginBottom: '0.6rem' }}>Základní scénář</div>
                            <div style={{ display: 'grid', gap: '0.5rem', fontSize: '0.9rem', color: 'var(--color-text)' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <span>Počáteční investice</span>
                                    <span className="tabular-nums meta-value" style={{ fontSize: '0.95rem' }}>{czk.format(analysis.totalInvestedInitial)}</span>
                                </div>
                                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <span>Očekávaný roční výnos</span>
                                    <span className="tabular-nums meta-value" style={{ fontSize: '0.95rem' }}>{pct.format(analysis.weightedReturnInitial)}</span>
                                </div>
                            </div>
                        </div>
                        {analysis.hasFollowUpInvestment && (
                            <div className="note-block" style={{ borderColor: 'rgba(77, 177, 200, 0.45)', background: 'rgba(77, 177, 200, 0.12)' }}>
                                <div className="meta-label" style={{ marginBottom: '0.6rem', color: 'var(--color-primary)' }}>Scénář s dalším vkladem</div>
                                <div style={{ display: 'grid', gap: '0.5rem', fontSize: '0.9rem', color: 'var(--color-text)' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                        <span>Celkem investováno</span>
                                        <span className="tabular-nums meta-value" style={{ fontSize: '0.95rem' }}>{czk.format(analysis.totalInvestedWithFollowUp)}</span>
                                    </div>
                                    <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                        <span>Očekávaný roční výnos</span>
                                        <span className="tabular-nums meta-value" style={{ fontSize: '0.95rem' }}>{pct.format(analysis.weightedReturnAfterY1)}</span>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    {analysis.hasFailure && (
                        <div className="info-grid" style={{ marginTop: '1.75rem' }}>
                            <InfoCard title="Celková kumulativní ztráta" value={`-${czk.format(analysis.totalLoss)}`} />
                            <InfoCard title="Doba zotavení na celkový vklad" value={formatRecoveryTime(analysis.recoveryTime)} subValue="od posledního relevantního krachu" />
                        </div>
                    )}
                </section>
            );
        };
        
        const useResizeObserver = (ref) => {
            const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
            useEffect(() => {
                const observeTarget = ref.current;
                if (!observeTarget) return;
                const observer = new ResizeObserver(entries => { if (entries[0]) setDimensions(entries[0].contentRect); });
                observer.observe(observeTarget);
                return () => observer.unobserve(observeTarget);
            }, [ref]);
            return dimensions;
        };
        
        const useChartLogic = (analysis, width, height) => {
            return useMemo(() => {
                if (!analysis.hasData || width === 0) return { hasData: false };
                
                const { projection, totalInvestedInitial, totalInvestedWithFollowUp, hasFollowUpInvestment, hasFailure } = analysis;
                const margin = { top: 20, right: 20, bottom: 40, left: 70 };
                
                const allValues = projection.flatMap(p => [p.baseline.end, p.followUp.end, p.failure ? p.failure.end : 0]);

                const yMax = Math.max(...allValues, totalInvestedWithFollowUp) * 1.05;
                const xMax = Y;

                const xScale = (year) => margin.left + (year / xMax) * (width - margin.left - margin.right);
                const yScale = (value) => height - margin.bottom - (value / yMax) * (height - margin.top - margin.bottom);
                
                const scaledBaseline = [{x: xScale(0), y: yScale(totalInvestedInitial)}, ...projection.map(p => ({ x: xScale(p.year), y: yScale(p.baseline.end) }))];
                
                let scaledFollowUp = [];
                if (hasFollowUpInvestment) {
                    scaledFollowUp.push({x: xScale(0), y: yScale(totalInvestedInitial)});
                    scaledFollowUp.push({ x: xScale(1), y: yScale(projection[0].baseline.end) });
                    scaledFollowUp.push({ x: xScale(1), y: yScale(projection[0].followUp.end) });
                    projection.slice(1).forEach(p => {
                        scaledFollowUp.push({ x: xScale(p.year), y: yScale(p.followUp.end) });
                    });
                }

                let scaledFailure = [];
                if(hasFailure) {
                    scaledFailure.push({ x: xScale(0), y: yScale(totalInvestedInitial) });
                    projection.forEach(p => {
                        if (p.year === 1 && hasFollowUpInvestment) {
                            scaledFailure.push({ x: xScale(1), y: yScale(projection[0].baseline.end) });
                            scaledFailure.push({ x: xScale(1), y: yScale(p.failure.valueBeforeCrash) });
                        }
                        if (p.failure.loss > 0) {
                             scaledFailure.push({ x: xScale(p.year), y: yScale(p.failure.valueBeforeCrash) });
                             scaledFailure.push({ x: xScale(p.year), y: yScale(p.failure.end) });
                        } else {
                             const lastPoint = scaledFailure[scaledFailure.length-1];
                             if(!lastPoint || lastPoint.x !== xScale(p.year)){
                                scaledFailure.push({ x: xScale(p.year), y: yScale(p.failure.end) });
                             } else {
                                 lastPoint.y = yScale(p.failure.end);
                             }
                        }
                    });
                }

                const scaledDepositsPoints = [];
                scaledDepositsPoints.push({ x: xScale(0), y: yScale(totalInvestedInitial) });
                if (hasFollowUpInvestment) {
                    scaledDepositsPoints.push({ x: xScale(1), y: yScale(totalInvestedInitial) });
                    scaledDepositsPoints.push({ x: xScale(1), y: yScale(totalInvestedWithFollowUp) });
                    scaledDepositsPoints.push({ x: xScale(Y), y: yScale(totalInvestedWithFollowUp) });
                } else { scaledDepositsPoints.push({ x: xScale(Y), y: yScale(totalInvestedInitial) }); }

                const yAxisTicks = Array.from({ length: 6 }).map((_, i) => ({ value: (yMax / 5) * i, y: yScale((yMax / 5) * i) }));
                const xAxisTicks = Array.from({ length: Math.floor(Y / 5) + 1 }).map((_, i) => ({ year: i * 5, x: xScale(i * 5) }));

                return { hasData: true, margin, width, height, scaledBaseline, scaledFollowUp, yAxisTicks, xAxisTicks, yScale, xMax, scaledDepositsPoints, scaledFailure, analysis };
            }, [analysis, width, height]);
        };

        const createPath = (points) => {
             if (points.length < 2) return ""; return "M " + points.map(p => `${p.x},${p.y}`).join(" L ");
        };

        const LineChart = ({ analysis }) => {
            const containerRef = useRef(null);
            const svgRef = useRef(null);
            const dimensions = useResizeObserver(containerRef);
            const [tooltip, setTooltip] = useState(null);
            const chartData = useChartLogic(analysis, dimensions.width, dimensions.height);
            const animationFrameId = useRef();

            const handleMouseMove = (e) => {
                if (!chartData.hasData || !svgRef.current) return;
                const clientX = e.clientX; const clientY = e.clientY;
                cancelAnimationFrame(animationFrameId.current);
                animationFrameId.current = requestAnimationFrame(() => {
                    if (!svgRef.current) return;
                    const { margin, width, yScale, xMax, analysis } = chartData;
                    const svg = svgRef.current;
                    const rect = svg.getBoundingClientRect();
                    const mouseX = Math.max(margin.left, Math.min(clientX - rect.left, width - margin.right));
                    const yearFractional = (mouseX - margin.left) / (width - margin.left - margin.right) * xMax;

                    const interpolate = (projection, key = 'end') => {
                        if (!projection || projection.length === 0) return 0;
                        const yearFloor = Math.floor(yearFractional);
                        const yearCeil = Math.ceil(yearFractional);
                        if (yearFloor < 1) {
                            const startValue = analysis.totalInvestedInitial;
                            const firstYear = projection[0];
                            if (!firstYear) return startValue;
                            return startValue + (firstYear[key] - startValue) * yearFractional;
                        }
                        const p1 = projection[yearFloor - 1];
                        const p2 = projection[yearCeil - 1] || projection[projection.length - 1];
                        if (!p1 || !p2) return 0;
                        const t = yearFractional - yearFloor;
                        return p1[key] + (p2[key] - p1[key]) * t;
                    };

                    const valBaseline = interpolate(analysis.projection.map(p => p.baseline));
                    const valFollowUp = analysis.hasFollowUpInvestment ? interpolate(analysis.projection.map(p => p.followUp)) : null;
                    const valFailure = analysis.hasFailure ? interpolate(analysis.projection.map(p => p.failure)) : null;

                    const date = new Date();
                    date.setDate(date.getDate() + yearFractional * 365.25);
                    setTooltip({ x: mouseX, yBaseline: yScale(valBaseline), yFollowUp: valFollowUp ? yScale(valFollowUp) : null, yFailure: valFailure ? yScale(valFailure) : null, mouseX: clientX - rect.left, mouseY: clientY - rect.top, date: date.toLocaleDateString('cs-CZ'), valBaseline, valFollowUp, valFailure });
                });
            };

            const handleMouseLeave = () => { cancelAnimationFrame(animationFrameId.current); setTooltip(null); };

            return (
                <section className="card-section">
                    <div className="card-header" style={{ marginBottom: '1.5rem' }}>
                        <div>
                            <span className="badge-pill">Vývoj portfolia</span>
                            <h2 className="card-header-title">Vývoj hodnoty portfolia do roku {new Date().getFullYear() + Y}</h2>
                            <p className="card-header-sub">Simulace porovnává základní scénář, dodatečný vklad a stres test s krachy fondů.</p>
                        </div>
                    </div>
                    <div ref={containerRef} className="chart-container">
                        {!chartData.hasData ? (
                            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: 'var(--color-muted)' }}>Zadejte investici pro zobrazení grafu.</div>
                        ) : (
                            <svg ref={svgRef} width="100%" height="100%" onMouseMove={handleMouseMove} onMouseLeave={handleMouseLeave}>
                                <g>
                                    {chartData.yAxisTicks.map(({ value, y }) => (
                                        <g key={y}>
                                            <line className="chart-grid-line" x1={chartData.margin.left} y1={y} x2={chartData.width - chartData.margin.right} y2={y}></line>
                                            <text className="chart-axis-text" x={chartData.margin.left - 8} y={y + 4} textAnchor="end">{(value/1000000).toFixed(1)} M</text>
                                        </g>
                                    ))}
                                    {chartData.xAxisTicks.map(({ year, x }) => <text key={year} className="chart-axis-text" x={x} y={chartData.height - chartData.margin.bottom + 16} textAnchor="middle">{year === 0 ? "Dnes" : new Date().getFullYear() + year}</text>)}
                                </g>
                                <path d={createPath(chartData.scaledDepositsPoints)} className="chart-deposit-line" />
                                <path d={createPath(chartData.scaledBaseline)} className="chart-line-accent" />
                                {analysis.hasFollowUpInvestment && <path d={createPath(chartData.scaledFollowUp)} className="chart-line-primary" />}
                                {analysis.hasFailure && <path d={createPath(chartData.scaledFailure)} className="chart-line-danger" />}
                                <circle cx={chartData.scaledBaseline[0]?.x} cy={chartData.scaledBaseline[0]?.y} r="5" fill="var(--color-accent)" className="chart-dot" />

                                {tooltip && (
                                    <g className="pointer-events-none">
                                        <line stroke="var(--color-muted)" strokeWidth="1" y1={chartData.margin.top} y2={chartData.height - chartData.margin.bottom} x1={tooltip.x} x2={tooltip.x}></line>
                                        <circle r="5" fill="var(--color-accent)" className="chart-dot" cx={tooltip.x} cy={tooltip.yBaseline}></circle>
                                        {tooltip.yFollowUp && <circle r="5" fill="var(--color-primary)" className="chart-dot" cx={tooltip.x} cy={tooltip.yFollowUp}></circle>}
                                        {tooltip.yFailure && <circle r="5" fill="#E25050" className="chart-dot" cx={tooltip.x} cy={tooltip.yFailure}></circle>}
                                    </g>
                                )}
                            </svg>
                        )}
                        <div className={`tooltip ${tooltip ? 'show' : ''}`} style={tooltip ? { left: tooltip.mouseX + 15, top: tooltip.mouseY + 15 } : undefined}>
                            {tooltip && (
                                <>
                                    <div style={{ fontWeight: 600, marginBottom: '0.35rem' }}>{tooltip.date}</div>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.4rem' }}><span className="legend-dot" style={{ background: 'var(--color-accent)' }}></span><span className="tabular-nums">{czk.format(tooltip.valBaseline)}</span></div>
                                    {tooltip.valFollowUp && <div style={{ display: 'flex', alignItems: 'center', gap: '0.4rem', marginTop: '0.3rem' }}><span className="legend-dot" style={{ background: 'var(--color-primary)' }}></span><span className="tabular-nums">{czk.format(tooltip.valFollowUp)}</span></div>}
                                    {tooltip.valFailure && <div style={{ display: 'flex', alignItems: 'center', gap: '0.4rem', marginTop: '0.3rem' }}><span className="legend-dot" style={{ background: '#E25050' }}></span><span className="tabular-nums">{czk.format(tooltip.valFailure)}</span></div>}
                                </>
                            )}
                        </div>
                    </div>
                    {chartData.hasData && (
                        <div className="legend">
                            <div className="legend-item"><span className="legend-dot" style={{ background: 'var(--color-accent)' }}></span><span>Základní</span></div>
                            {analysis.hasFollowUpInvestment && <div className="legend-item"><span className="legend-dot" style={{ background: 'var(--color-primary)' }}></span><span>S vkladem</span></div>}
                            {analysis.hasFailure && <div className="legend-item"><span className="legend-dot" style={{ background: '#E25050' }}></span><span>Při krachu</span></div>}
                            <div className="legend-item"><span className="legend-dot" style={{ background: 'transparent', border: `2px dashed var(--color-border-strong)` }}></span><span>Vklady</span></div>
                        </div>
                    )}
                </section>
            );
        };
        
        const PieChart = ({ analysis }) => {
            const [view, setView] = useState('initial');
            const tooltipRef = useRef(null);
            if (!analysis.hasData) return null;
            const { investedFundsInitial, fundsAfterY1, hasFollowUpInvestment } = analysis;
            const dataToShow = view === 'initial' || !hasFollowUpInvestment ? investedFundsInitial : fundsAfterY1;
            const title = view === 'initial' || !hasFollowUpInvestment ? 'Počáteční alokace portfolia' : 'Alokace po 1. roce';
            const pieTotal = dataToShow.reduce((sum, d) => sum + d.amount, 0);
            const CHART_COLORS = ['#4DB1C8', '#0d2c54', '#6CBFD2', '#A7D9E5', '#F3B0A0', '#F3D0A0', '#9FC6D9', '#D4E9F0'];
            let angle = -90;
            const segments = dataToShow.map((d, i) => {
                const percent = pieTotal > 0 ? d.amount / pieTotal : 0;
                const pathData = `M ${50 + 48*Math.cos(angle*Math.PI/180)},${50 + 48*Math.sin(angle*Math.PI/180)} A 48,48 0 ${percent > 0.5 ? 1:0},1 ${50 + 48*Math.cos((angle+percent*360)*Math.PI/180)},${50 + 48*Math.sin((angle+percent*360)*Math.PI/180)} L ${50 + 30*Math.cos((angle+percent*360)*Math.PI/180)},${50 + 30*Math.sin((angle+percent*360)*Math.PI/180)} A 30,30 0 ${percent > 0.5 ? 1:0},0 ${50 + 30*Math.cos(angle*Math.PI/180)},${50 + 30*Math.sin(angle*Math.PI/180)} Z`;
                angle += percent * 360;
                return { ...d, path: pathData, color: CHART_COLORS[i % CHART_COLORS.length], percent };
            });

            const handleSegmentMouseMove = (e, segment) => {
                const tooltip = tooltipRef.current; if (!tooltip) return;
                tooltip.innerHTML = `<div class="meta-label" style="margin-bottom:0.35rem">${segment.name}</div><div class="meta-value" style="text-transform:none">${czk.format(segment.amount)} · ${pct.format(pieTotal > 0 ? segment.amount / pieTotal : 0)}</div>`;
                tooltip.classList.add('show');
                tooltip.style.left = `${e.pageX + 15}px`;
                tooltip.style.top = `${e.pageY + 15}px`;
            };
            const handleSegmentMouseOut = () => { const tooltip = tooltipRef.current; if (tooltip) tooltip.classList.remove('show'); };

            return (
                <section className="card-section">
                    <div className="card-header" style={{ marginBottom: '1.75rem' }}>
                        <div>
                            <span className="badge-pill">Alokace portfolia</span>
                            <h2 className="card-header-title">{title}</h2>
                            <p className="card-header-sub">Rozložení kapitálu mezi jednotlivé fondy s důrazem na jednotnou prezentaci.</p>
                        </div>
                        {hasFollowUpInvestment && (
                            <div className="control-bar">
                                <button onClick={() => setView('initial')} className={`btn btn-secondary${view === 'initial' ? ' active' : ''}`}>
                                    Start
                                </button>
                                <button onClick={() => setView('afterY1')} className={`btn btn-secondary${view === 'afterY1' ? ' active' : ''}`}>
                                    Po 1. roce
                                </button>
                            </div>
                        )}
                    </div>
                    <div className="tooltip" ref={tooltipRef}></div>
                    <div className="responsive-grid-two">
                        <div style={{ width: '100%', maxWidth: '260px', margin: '0 auto' }}>
                            <svg viewBox="0 0 100 100">{segments.map((seg, i) => (<path key={i} d={seg.path} fill={seg.color} stroke="#fff" strokeWidth="1" className="pie-segment" onMouseMove={(e) => handleSegmentMouseMove(e, seg)} onMouseOut={handleSegmentMouseOut} />))}</svg>
                        </div>
                        <div className="pie-legend" style={{ maxHeight: '18rem', overflowY: 'auto', paddingRight: '0.25rem' }}>
                            {segments.map((seg, i) => (
                                <div key={i} className="pie-legend-item">
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.6rem', flex: '1 1 auto', minWidth: 0 }}>
                                        <span className="legend-dot" style={{ background: seg.color, border: '1px solid rgba(13,44,84,0.12)' }}></span>
                                        <span className="pie-legend-name" title={seg.name}>{seg.name}</span>
                                    </div>
                                    <span className="pie-legend-value tabular-nums">{pct.format(pieTotal > 0 ? seg.amount / pieTotal : 0)}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </section>
            );
        };
        
        const ProjectionTable = ({ analysis }) => {
            if (!analysis.hasData) return null;

            const { projection, totalInvestedInitial, totalInvestedY1, hasFollowUpInvestment, hasFailure, failureEvents } = analysis;
            const today = new Date();
            const formatDate = (date) => date.toLocaleDateString('cs-CZ', { day: 'numeric', month: 'numeric', year: 'numeric' });

            return (
                <section className="card-section">
                    <div className="card-header" style={{ marginBottom: '1.5rem' }}>
                        <div>
                            <span className="badge-pill">Časová osa</span>
                            <h2 className="card-header-title">Detailní srovnání projekcí</h2>
                            <p className="card-header-sub">Vývoj portfolia v jednotlivých scénářích včetně dalších vkladů a simulovaných ztrát.</p>
                        </div>
                        <div className="meta-card" style={{ minWidth: 'auto' }}>
                            <span className="meta-label">Výchozí datum</span>
                            <span className="meta-value" style={{ textTransform: 'none' }}>{today.toLocaleDateString('cs-CZ')}</span>
                        </div>
                    </div>
                    <div style={{ overflowX: 'auto', maxHeight: '28rem', border: '1px solid var(--color-border)', borderRadius: '1.5rem' }}>
                        <table>
                            <thead>
                                <tr>
                                    <th>Datum</th>
                                    <th>Událost</th>
                                    <th style={{ textAlign: 'right' }}>Hodnota (bez další inv.)</th>
                                    {hasFollowUpInvestment && <th style={{ textAlign: 'right' }}>Hodnota (s další inv.)</th>}
                                    {hasFailure && <th style={{ textAlign: 'right' }}>Hodnota (při krachu)</th>}
                                </tr>
                            </thead>
                            <tbody>
                                <tr style={{ background: 'rgba(77,177,200,0.08)', fontWeight: 600 }}>
                                    <td className="tabular-nums">{formatDate(today)}</td>
                                    <td>Počáteční vklad</td>
                                    <td className="tabular-nums" style={{ textAlign: 'right' }}>{czk.format(totalInvestedInitial)}</td>
                                    {hasFollowUpInvestment && <td className="tabular-nums" style={{ textAlign: 'right' }}>{czk.format(totalInvestedInitial)}</td>}
                                    {hasFailure && <td className="tabular-nums" style={{ textAlign: 'right' }}>{czk.format(totalInvestedInitial)}</td>}
                                </tr>
                                {projection.map((p) => {
                                    const futureDate = new Date(); futureDate.setFullYear(futureDate.getFullYear() + p.year);
                                    const isY1 = p.year === 1;
                                    const failureThisYear = hasFailure ? failureEvents.find(e => e.year === p.year) : null;
                                    return (
                                        <Fragment key={p.year}>
                                            <tr>
                                                <td className="tabular-nums" style={{ verticalAlign: 'top' }}>{formatDate(futureDate)}</td>
                                                <td style={{ verticalAlign: 'top' }}>Po {p.year}. roce</td>
                                                <td className="tabular-nums" style={{ textAlign: 'right' }}>
                                                    <div style={{ fontWeight: 600 }}>{czk.format(p.baseline.end)}</div>
                                                    <div style={{ fontSize: '0.75rem', color: '#1f7a1f' }}>+{czk.format(p.baseline.interest)}</div>
                                                </td>
                                                {hasFollowUpInvestment && (
                                                    <td className="tabular-nums" style={{ textAlign: 'right' }}>
                                                        <div style={{ fontWeight: 600 }}>{czk.format(p.followUp.end)}</div>
                                                        <div style={{ fontSize: '0.75rem', color: '#1f7a1f' }}>+{czk.format(p.followUp.interest)}</div>
                                                    </td>
                                                )}
                                                {hasFailure && (
                                                    <td className="tabular-nums" style={{ textAlign: 'right' }}>
                                                        <div style={{ fontWeight: 600 }}>{czk.format(p.failure.end)}</div>
                                                        <div style={{ fontSize: '0.75rem', color: '#1f7a1f' }}>+{czk.format(p.failure.interest)}</div>
                                                    </td>
                                                )}
                                            </tr>
                                            {isY1 && hasFollowUpInvestment && (
                                                <tr style={{ background: 'rgba(77,177,200,0.12)', fontWeight: 500 }}>
                                                    <td className="tabular-nums">{formatDate(futureDate)}</td>
                                                    <td>Dodatečná investice</td>
                                                    <td style={{ textAlign: 'center' }}>-</td>
                                                    <td className="tabular-nums" style={{ textAlign: 'right', color: 'var(--color-primary)' }}>+{czk.format(totalInvestedY1)}</td>
                                                    {hasFailure && <td style={{ textAlign: 'center' }}>-</td>}
                                                </tr>
                                            )}
                                            {failureThisYear && (
                                                <tr style={{ background: 'rgba(229,62,62,0.12)', fontWeight: 500 }}>
                                                    <td className="tabular-nums">{formatDate(futureDate)}</td>
                                                    <td>Krach fondu / Ztráta</td>
                                                    <td style={{ textAlign: 'center' }}>-</td>
                                                    {hasFollowUpInvestment && <td style={{ textAlign: 'center' }}>-</td>}
                                                    <td className="tabular-nums" style={{ textAlign: 'right', color: '#b42318' }}>-{czk.format(failureThisYear.loss)}</td>
                                                </tr>
                                            )}
                                        </Fragment>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                </section>
            );
        };

        const AnnuityCalculator = ({ analysis }) => {
            const [monthlyAnnuityStr, setMonthlyAnnuityStr] = useState('');
            const monthlyAnnuity = useMemo(() => parse(monthlyAnnuityStr), [monthlyAnnuityStr]);
            const annualAnnuity = useMemo(() => monthlyAnnuity * 12, [monthlyAnnuity]);
            const annuityResult = useMemo(() => {
                if (!analysis.hasData || analysis.projection.length === 0) return null;
                const hasFollowUp = analysis.hasFollowUpInvestment;

                const relevantProjection = hasFollowUp ? analysis.projection.map(p => p.followUp) : analysis.projection.map(p => p.baseline);
                const lastYear = relevantProjection[relevantProjection.length - 1];
                const relevantReturn = lastYear.interest / lastYear.start;

                if (relevantReturn <= 0 || monthlyAnnuity <= 0) return null;

                const targetCapital = annualAnnuity / relevantReturn;
                const startingCapital = hasFollowUp ? (analysis.projection[0].baseline.end + analysis.totalInvestedY1) : analysis.totalInvestedInitial;

                if (startingCapital >= targetCapital) return { type: 'sufficient', totalInvested: analysis.totalInvestedInitial };

                const yearsNeeded = Math.log(targetCapital / startingCapital) / Math.log(1 + relevantReturn);
                const targetDate = new Date();
                const startYearOffset = hasFollowUp ? 1 : 0;
                targetDate.setFullYear(targetDate.getFullYear() + Math.floor(yearsNeeded + startYearOffset), targetDate.getMonth() + ((yearsNeeded + startYearOffset) % 1) * 12);
                return { type: 'future', monthlyAnnuity, targetCapital, targetDate: targetDate.toLocaleDateString('cs-CZ', { month: 'long', year: 'numeric' }) };
            }, [monthlyAnnuity, annualAnnuity, analysis]);
            if (!analysis.hasData) return null;
            return (
                <section className="card-section">
                    <div className="card-header" style={{ marginBottom: '1.5rem' }}>
                        <div>
                            <span className="badge-pill">Dlouhodobá renta</span>
                            <h2 className="card-header-title">Kalkulačka nekonečné renty</h2>
                            <p className="card-header-sub">Odhad potřebného kapitálu pro požadovanou měsíční rentu při zachování jistiny.</p>
                        </div>
                        <span className="meta-label" style={{ alignSelf: 'flex-end' }}>Pracuje s očekávaným výnosem portfolia</span>
                    </div>
                    <div className="control-bar" style={{ marginBottom: '1.25rem' }}>
                        <label className="meta-label" style={{ marginBottom: 0 }}>Požadovaná měsíční renta</label>
                        <div style={{ flex: '1 1 240px', maxWidth: '260px' }}><MoneyInput value={monthlyAnnuityStr} onChange={setMonthlyAnnuityStr} /></div>
                        {annualAnnuity > 0 && <span className="meta-value" style={{ fontSize: '0.85rem', textTransform: 'none' }}>(odpovídá {czk.format(annualAnnuity)} ročně)</span>}
                    </div>
                    {annuityResult && (
                        <div className="note-block" style={{ background: 'rgba(77,177,200,0.12)', borderColor: 'rgba(77,177,200,0.4)', marginTop: '0.5rem' }}>
                            {annuityResult.type === 'sufficient' && (
                                <span><strong>Gratulujeme!</strong> Portfolio s aktuální hodnotou <strong>{czk.format(annuityResult.totalInvested)}</strong> již dokáže generovat požadovanou rentu.</span>
                            )}
                            {annuityResult.type === 'future' && (
                                <span>Pro měsíční rentu <strong>{czk.format(annuityResult.monthlyAnnuity)}</strong> je potřeba kapitál přibližně <strong>{czk.format(annuityResult.targetCapital)}</strong>. Při současném tempu růstu byste této částky mohli dosáhnout okolo <strong>{annuityResult.targetDate}</strong>.</span>
                            )}
                        </div>
                    )}
                    <p className="meta-label" style={{ marginTop: '1.5rem', textTransform: 'none', color: 'var(--color-muted)' }}>
                        * Výpočet předpokládá výběr pouze zhodnocení portfolia, zatímco jistina zůstává investovaná.
                    </p>
                </section>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
